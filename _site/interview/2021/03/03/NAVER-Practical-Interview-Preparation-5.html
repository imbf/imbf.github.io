<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="B7c_ecRqLF3-nPb0TKaSDlu3xHPQXRZkwl-UcutOMgo" />


  <title>[실무 면접 준비 - 5] 자료구조 & Java (Data Structrue & Java)</title>
  <meta name="description" content="">
  
  <meta name="author" content="배종진">
  <meta name="copyright" content="&copy; 배종진 2021">
  

  <!-- External libraries -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css">

  <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
  <link rel="shortcut icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  
  <!-- Facebook OGP cards -->
  <meta property="og:description" content="" />
  <meta property="og:url" content="http://localhost:4000/interview/2021/03/03/NAVER-Practical-Interview-Preparation-5.html">
  <meta property="og:site_name" content="Green Frog Developer" />
  <meta property="og:title" content="[실무 면접 준비 - 5] 자료구조 & Java (Data Structrue & Java)" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/logo.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="612" />
  <meta property="og:image:height" content="605" />
  

  
  <!-- Twitter: card tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[실무 면접 준비 - 5] 자료구조 & Java (Data Structrue & Java)">
  <meta name="twitter:description" content="">
  <meta name="twitter:image" content="http://localhost:4000/assets/logo.png">
  <meta name="twitter:url" content="http://localhost:4000/interview/2021/03/03/NAVER-Practical-Interview-Preparation-5.html">
  

  

  <!-- Site styles -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/interview/2021/03/03/NAVER-Practical-Interview-Preparation-5.html">
	<link rel="alternate" type="application/rss+xml" title="Green Frog Developer" href="http://localhost:4000/feed.xml" />
	
	<!-- Tooltips -->
	<script type="text/javascript">
		window.tooltips = []
	</script>
</head>


  <body>

    <header class="navigation" role="banner">
  <div class="navigation-wrapper">
    <a href="/" class="logo">
      
      <img src="/assets/logo.png" alt="Green Frog Developer">
      
    </a>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
      <i class="fa fa-bars"></i>
    </a>
    <nav role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
        
	

	

	

	
	<li class="nav-link"><a href="/portfolio/">Portfolio</a>
	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </nav>
  </div>
</header>


    <div class="page-content">
        <div class="post">

<div class="post-header-container " >
  <div class="scrim ">
    <header class="post-header">
      <h1 class="title">[실무 면접 준비 - 5] 자료구조 & Java (Data Structrue & Java)</h1>
      <p class="info">by <strong>Green Frog Developer</strong></p>
    </header>
  </div>
</div>

<div class="wrapper">

 <span class="page-divider">
  <span class="one"></span>
  <span class="two"></span>
</span>
 

<section class="post-meta">
  <div class="post-date">March 3, 2021</div>
  <div class="post-categories">
  in 
    
    <!-- <a href="/category/Interview">Interview</a> (default) -->
    <a href="/category/Interview">Interview</a>
    
  
  </div>
</section>

<article class="post-content">
  <hr />

<h2 id="자료구조data-structure">자료구조(Data Structure)</h2>

<hr />

<h3 id="array란-무엇인가요">Array란 무엇인가요?</h3>

<p><strong>Array는 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조를 나타냅니다.</strong> 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스로 해당 원소에 접근할 수 있습니다.</p>

<ul>
  <li>원소의 인덱스 값을 알고 있으면 검색 및 수정에는 O(1)의 시간이 걸리지만 삽입이나 삭제등이 필요한 경우에는 원소들을 shift 해주어야 하기 때문에 O(n)의 시간이 걸립니다.</li>
</ul>

<h3 id="linkedlist란-무엇인가요">LinkedList란 무엇인가요?</h3>

<p><strong>LinkedList란 각 노드가 데이터와 포인터를 가지고 연결되어 있는 방식으로 데이터를 저장하는 자료 구조를 나타냅니다.</strong> 링크드 리스트의 종류로는 단일 링크드리스트, 이중 링크드리스트, 원형 링크드리스트 등이 존재합니다.</p>

<ul>
  <li>링크드리스트의 경우 인덱스가 존재하지 않기 때문에 검색 및 수정시 첫 번째 노드부터 순차적으로 모든 노드를 검색해야 합니다. 따라서 링크드리스트의 검색과 수정시 시간 복잡도는 O(1) 입니다.</li>
  <li>링크드리스트의 경우 노드의 삭제와 삽입시 O(1)만에 해결할 수 있지만, 원하는 위치에 원소를 삽입하거나 삭제하는 경우 위치를 검색하는 시간이 필요하므로 O(n)의 시간이 걸립니다.</li>
</ul>

<h3 id="선형-자료구조와-비선형-자료구조의-차이는-무엇인가요">선형 자료구조와 비선형 자료구조의 차이는 무엇인가요?</h3>

<p><strong>선형 자료구조는 데이터 요소들이 저장되어 있는 모습을 표현했을 때 직선이고, 비선형 자료구조는 데이터 요소들이 저장되어 있는 모습을 표현했을 때 직선이 아닌 것을 의미합니다.</strong></p>

<ul>
  <li>선형 자료구조의 대표적인 예는 Array, Queue 등이 있고, 비선형 자료구조의 대표적인 예는 Tree, Graph 등이 있습니다.</li>
</ul>

<h3 id="stack이란-무엇인가요">Stack이란 무엇인가요?</h3>

<p><strong>Stack이란 선형 자료구조의 일종으로 Last In First Out(LIFO)의 특징을 가지고 있습니다.</strong> 즉, Stack에 먼저 들어가게 된 원소는 맨 바닥에 깔리게 되고, 가장 늦게 들어간 원소는 그 위에 쌓이고 호출 시 가장 위에 있는 녀석이 호출되는 구조입니다.</p>

<ul>
  <li>LIFO의 특징을 사용하려는 것이 아닌 Stack의 CRUD 시간 복잡도는 계산할 이유가 없는 것 같습니다. Stack 이외에도 CRUD를 위한 더 좋은 자료구조를 사용할 수 있을 것 같네요.</li>
</ul>

<h3 id="queue란-무엇인가요">Queue란 무엇인가요?</h3>

<p><strong>Queue란 선형 자료구조의 일종으로 First In First Out(FIFO)의 특징을 가지는 자료 구조를 의미합니다.</strong></p>

<ul>
  <li>FIFO의 특징을 사용하려는 것이 아닌 Queue의 CRUD 시간 복잡도를 굳이 구해보자면
    <ul>
      <li>삽입
        <ul>
          <li>맨 뒷 부분에 삽입 시 O(1)</li>
          <li>원하는 위치에 삽입 시 O(n)</li>
        </ul>
      </li>
      <li>삭제, 수정, 검색
        <ul>
          <li>원하는 노드를 삭제, 수정, 검색할 시 O(n)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="tree란-무엇인가요">Tree란 무엇인가요?</h3>

<p><strong>트리는 비선형 자료구조로써 node들과 이를 연결하는 edge들로 구성되어 있습니다.</strong></p>

<ul>
  <li>트리는 하나의 루트 노드를 갖습니다.</li>
  <li>트리에는 싸이클이 존재하지 않습니다.</li>
  <li>순서나 규칙이 없는 트리의 경우 CRUD시 시간 복잡도는 트리의 모든 노드를 탐색해야 하기 때문에 O(n)의 시간이 걸립니다.</li>
</ul>

<h3 id="binary-tree이진-트리란-무엇인가요">Binary Tree(이진 트리)란 무엇인가요?</h3>

<p><strong>이진 트리란 각각의 노드가 최대 두 개의 자식 노드를 갖는 트리를 의미합니다.</strong> 이진 트리의 종류로는 완전 이진 트리, 포화 이진 트리, 정 이진 트리 등이 존재합니다.</p>

<ul>
  <li>완전 이진 트리(Complete Binary Tree) : 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있고 마지막 레벨의 노드가 왼쪽에서 오른쪽으로 채워지는 이진 트리를 의미합니다.</li>
  <li>정 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리를 의미합니다.</li>
  <li>포화 이진 트리(Perfect Binary Tree) : 모든 내부(Internal) 노드가 두 개의 자식 노드를 가지며 모든 leaf 노드가 동일한 레벨을 갖는 트리를 의미합니다.</li>
  <li>노드 간의 규칙이 없는 이진 트리의 경우 CRUD시 시간 복잡도는 트리의 모든 노드를 탐색해야 하기 때문에 O(n)의 시간이 걸립니다.</li>
</ul>

<h3 id="binary-search-tree이진-탐색-트리-bst란-무엇인가요">Binary Search Tree(이진 탐색 트리, BST)란 무엇인가요?</h3>

<p><strong>이진 탐색 트리란 서로 중복된 데이터를 갖는 노드가 없다는 가정하에 부모 노드가 왼쪽 자식 노드보다 크고 오른쪽 자식 노드보다는 작다는 규칙을 만족하는 이진 트리를 Binary Search Tree 라고 합니다.</strong></p>

<ul>
  <li>이진 탐색 트리에서 CRUD의 시간 복잡도는 O(h) 즉, 높이에 비례합니다.</li>
  <li>시간 복잡도를 h가 아닌 n으로 표현해 보았을 때 완전 이진 트리의 경우에는 O(log n)으로 표현할 수도 있으나, 편향 트리(Skewed Tree) 즉, 한 쪽으로만 노드가 추가되는 경우 시작 복잡도는 O(n)입니다.</li>
  <li>이진 탐색 트리가 편향 트리가 되는 문제를 해결하기 위해 서브 트리의 레벨을 비교해서 균형을 맞추는 Rebalancing 기법이 등장 했으며 이러한 기법을 구현한 대표적인 트리는 Red-Black Tree 입니다.</li>
</ul>

<p><img src="/assets/interview/naver-practical-interview-preparation5-1.png" style="width:50%" /></p>

<h3 id="binary-heap이란-무엇인가요">Binary Heap이란 무엇인가요?</h3>

<p><strong>Binary Heap이란 최대 또는 최소를 빠르게 찾아내기 위해 만들어진 완전이진트리(CBT)로써 부모노드와 자식 노드간에 대소 관계가 성립합니다.</strong> 이러한 대소 관계를 기반으로 Heap은 Max Heap과 Min Heap으로 나눌 수 있습니다.</p>

<ul>
  <li>Heap에 존재하는 노드들의 최대 및 최소를 검색하기 위한 시간 복잡도는 O(1) 입니다.</li>
  <li>연산 후 heap의 대소 관계 구조를 계속 유지하기 위해서는 제거된 루트 노트를 대체할 다른 노드가 필요합니다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지합니다.</li>
  <li>heapify 연산을 수행하는데 걸리는 시간 복잡도는 O(log n)이기 때문에 결국 최대 및 최소를 검색하는데 걸리는 시간은 O(log n) 입니다.</li>
  <li>최대 최소가 아닌 다른 노드들의 CRUD 시간 복잡도는 O(log n) 입니다.</li>
</ul>

<h3 id="binary-heap과-binary-search-tree는-각각-어떠한-경우에-사용하는게-좋나요">Binary Heap과 Binary Search Tree는 각각 어떠한 경우에 사용하는게 좋나요?</h3>

<p><strong>Heap은 최대 및 최소 노드를 연산<code class="highlighter-rouge">(O(1), heapify를 포함한다면 O(log n))</code>하는데 유용하지만, BST는 모든 노드를 연산(O(log n))하는데 유용합니다.</strong></p>

<h3 id="red-black-tree란-무엇인가요-업데이트">Red-Black Tree란 무엇인가요? (업데이트)</h3>

<p><strong>Red Black Tree(RBT) 란 자가 균형 이진 탐색 트리의 한 종류로써 이진 탐색 트리(BST)의 단점인 편향성을 색깔을 통해서 보완하기 위한 자료구조 입니다.</strong> 즉, 트리의 노드의 개수가 동일할 경우 depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어 입니다.</p>

<ul>
  <li>RBT의 CRUD 시간 복잡도는 O(log n)이다.</li>
  <li>Root node 부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. (balanced 상태)</li>
  <li>노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL 들을 leaf node로 간주한다.</li>
</ul>

<p><img src="/assets/interview/naver-practical-interview-preparation5-2.png" style="width:80%" /></p>

<p><strong>Red-Black Tree의 정의</strong></p>

<ul>
  <li>각 노드는 <code class="highlighter-rouge">Red</code> or <code class="highlighter-rouge">Black</code> 색깔을 갖는다.</li>
  <li>Root node의 색깔은 <code class="highlighter-rouge">Black</code>이다.</li>
  <li>각 leaf node(NIL)의 색깔은 <code class="highlighter-rouge">black</code>이다.</li>
  <li>어떤 노드의 색깔이 <code class="highlighter-rouge">red</code>라면 두 개의 children의 색깔은 모두 <code class="highlighter-rouge">black</code>이다.
    <ul>
      <li>어떤 노드의 색깔이 <code class="highlighter-rouge">black</code>이라면 두 개의 children 의 색깔은 모두 <code class="highlighter-rouge">red</code>이다.</li>
    </ul>
  </li>
  <li>각 노드에 대해서 노드로부터 그 노드의 자손인 leaf node로 가는 경로들은 모두 같은 수의 <code class="highlighter-rouge">Black</code> 노드를 포함한다. 이를 <strong>Black-Height</strong> 라고 한다.
    <ul>
      <li>Black-Height : 노드 x 로부터 노드 x 를 포함하지 않는 leaf node 까지의 simple path 상에 있는 black nodes 들의 개수</li>
    </ul>
  </li>
</ul>

<p><strong>Red-Black Tree 노드 삽입</strong></p>

<ol>
  <li>BST의 특성을 유지하면서 색깔이 <code class="highlighter-rouge">red</code>인 노드를 삽입한다.</li>
  <li>삽입한 노드가 색깔 규칙에 어긋난다면 노드의 색깔을 조정하고, Black-Height에 위배된다면 rotation을 통해 height를 조정한다.</li>
</ol>

<p><strong>Red-Black Tree 노드 삭제</strong></p>

<ol>
  <li>BST의 특성을 유지하면서 해당 노드를 삭제한다.</li>
  <li>지워진 노드의 색깔이 Black 이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotation하고 노드의 색깔을 조정한다.
    <ul>
      <li>지워진 노드의 색깔이 red라면 어떠한 문제도 발생하지 않는다.</li>
    </ul>
  </li>
</ol>

<h3 id="hash-table이란-무엇인가요">Hash Table이란 무엇인가요?</h3>

<p><strong>Hash Table이란 임의의 길이를 가진 키를 고정된 길이의 Hash Code로 변환시켜서 이를 인덱스로 사용하여 데이터를 저장하는 자료구조를 의미합니다.</strong></p>

<h3 id="hash-function이란-무엇인가요">Hash Function이란 무엇인가요?</h3>

<p><strong>Hash Function이란 임의의 길이를 가진 데이터를 고정된 길이를 가진 고유한 데이터로 변환시키는 함수</strong>를 의미합니다. 이러한 함수로부터 얻어지는 값을 해시 값, 해시코드 짧게 말해서 해시라고도 합니다.</p>

<ul>
  <li>어설픈 Hash Function을 사용한다면 서로 다른 두 개의 키가 같은 해시 값으로 표현될 수 있는데 이를 <strong>충돌(Collision)</strong>이라고 합니다.</li>
  <li>해시는 <strong>등호(=) 연산에만 특화</strong>되어 있기 때문에 <u>부등호 연산(&gt;, &lt;)이 자주 사용되는 데이터베이스 검색을 위해서는 적절하지 않습니다.</u> =&gt; 이런 경우 B+ Tree 알고리즘을 자주 사용합니다.</li>
  <li><strong>충돌(Collision)이 많아질수록 Search에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워집니다.</strong></li>
  <li>hash function을 1:1 맵핑으로 만드는 것보다 Collision을 최소화하는 방향으로 설계하고 발생하는 Collision에 대비해 어떻게 대응할 것인가가 중요하다.</li>
</ul>

<h3 id="hash-collision-resolve-방식에는-어떠한-방법이-존재하나요">Hash Collision Resolve 방식에는 어떠한 방법이 존재하나요?</h3>

<ol>
  <li>
    <p><strong>Open Address 방식 (개방 주소법)</strong></p>

    <p><strong>해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식입니다.</strong> 다른 해시 버킷을 찾기 위해 다양한 방법이 존재하는데 대표적인 방법으로는 순차적으로 비어있는 버킷을 찾을 때까지 계속 탐색하는 Linear Probing 방식이 존재합니다.</p>

    <ul>
      <li>해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 높아지기 때문에 시간 복잡도가 O(n)에 가까워진다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Separate Chaining 방식 (분리 연결법)</strong></p>

    <p><strong>Hash Table의 각 버킷이 여러 값을 저장할 수 있는 자료 구조를 가리키도록 만드는 방법을 의미합니다.</strong> 이를 구현할 수 있는 방법으로는 LinkedList를 사용하는 방식과 Tree를 사용하는 방식이 존재합니다. Java util 에서는 HashMap을 Separate Chaining 방식을 사용하여 구현하고 있습니다.</p>

    <ul>
      <li><strong>Separate Chaining Using LinkedList :</strong> 각각의 버킷들을 LinkedList로 만들어 충돌(Collision)이 발생하면 해당 bucket의 list에 값을 추가하는 방식이다.</li>
      <li><strong>Separate Chaining Using Tree :</strong> 각각의 버킷들을 Tree로 만들어 충돌(Collision)이 발생하면 해당 bucket의 tree에 값을 추가하는 방식입니다.</li>
      <li>Tree는 LinkedList에 비해 메모리 사용량이 많기 때문에 데이터 개수가 적을 때는 링크드리스트를 사용하는게 유리하지만, 개수가 많을 경우 Tree의 시간 복잡도가 LinkedList보다 빠르기 때문에 Tree를 사용하는게 더 유리하다.</li>
    </ul>
  </li>
</ol>

<h3 id="graph란-무엇인가요">Graph란 무엇인가요?</h3>

<p><strong>Graph란 Node들과 이를 연결하는 Edge들을 모아 놓은 자료구조입니다.</strong> 방향 및 비방향 그래프가 모두 존재하며, 사이클 및 self-loop가 존재해도 무방합니다. 그래프는 인접 행렬과 인접 리스트로 구현할 수 있습니다.</p>

<h3 id="graph-탐색에는-어떠한-방법이-존재하나요">Graph 탐색에는 어떠한 방법이 존재하나요?</h3>

<p>그래프는 따로 규칙이 존재하지 않기 때문에 모든 정점을 탐색해야만 합니다. <strong>특정 정점을 기준으로 넓게 탐색하기 전에 깊게 탐색하는 방법인 DFS(Depth First Search)와 깊게 탐색하기 전에 넓게 탐색하는 방법인 BFS(Breadth First Search)가 존재합니다</strong>.</p>

<ul>
  <li>DFS는 Stack 및 재귀를 사용해서 구현하면 쉽구요, BFS는 Queue를 사용해서 구현하면 쉽습니다.</li>
  <li>DFS와 BFS를 인접리스트로 구현할 경우에 시간 복잡도는 O(V+E) 이구요, 인접 행렬로써 구현할 경우에 시간복잡도는 O(V^2) 입니다.</li>
</ul>

<h3 id="minimum-spanning-tree">Minimum Spanning Tree</h3>

<p><strong>Minimum Spanning Tree란 그래프의 여러 Spanning Tree 중 edge의 가중치 합이 최소인 Spanning tree를 의미합니다.</strong></p>

<blockquote>
  <p>Spanning Tree란 그래프의 모든 정점이 Cycle 없이 연결된 형태를 의미합니다.</p>
</blockquote>

<h3 id="minimum-spanning-tree를-구하는-알고리즘에는-어떤-방법이-존재하나요">Minimum Spanning Tree를 구하는 알고리즘에는 어떤 방법이 존재하나요?</h3>

<p><strong>Minimum Spanning Tree를 구하는 알고리즘에는 Edge 값이 가장 작은 것부터 탐색하는 탐욕적인 방법으로 대표적으로 Kruskal Algorithm과 Prim Algorithm이 존재합니다.</strong></p>

<ul>
  <li><strong>Kruskal Algorithm</strong>이란 Edge없이 vertex로만 구성된 그래프를 만들어서 weight가 제일 작은 edge 부터 검토후 cycle이 생기지 않는 경우에만 edge를 추가하는 방법을 의미하구요 시간 복잡도는 O(ElogE) 입니다.</li>
  <li><strong>Prim Algorithm</strong>이란 한 개의 vertex로 구성된 그래프 A를 만들어서 그래프 A 내부에 있는 vertex와 외부에 있는 vertex 사이의 edge를 연결했을 때 가장 작은 weight를 가진 vertex와 edge를 그래프 A에 추가하는 방법을 의미하구요 시간 복잡도는 O(ElogV)입니다.</li>
</ul>

<hr />

<h2 id="java">Java</h2>

<hr />

<h3 id="java-8의-특징은-무엇인가요">Java 8의 특징은 무엇인가요??</h3>

<p>Java 8의 주요 특징으로는 자바에 <strong>함수형 프로그래밍이</strong> 처음으로 도입되었다는 것입니다. 새롭게 도입된 기능으로는 <strong>Stream API, Lambda Expression, Method Reference, Optional Class, Functional Interface, Default Methods</strong> 등이 있습니다.</p>

<h3 id="java-9의-특징은-무엇인가요">Java 9의 특징은 무엇인가요??</h3>

<p>Java 9의 주요 특징으로는 <strong>모듈화</strong>가 도입되었다는 것입니다. <strong>Package와 여러 데이터 자원을 포함하는 Module을 런타임시에 가져옴으로써 더 잘 구조화된 어플리케이션을 작성할 수 있게 되었고 성능을 향상시킬 수 있게 되었습니다.</strong></p>

<h3 id="java-10의-특징은-무엇인가요">Java 10의 특징은 무엇인가요?</h3>

<p>Java 10의 주요 특징으로는 <strong>Local Variable Type Inference</strong>가 도입되었다는 것입니다. <strong>자바는 기존의 엄격한 타입 선언 방식에서 탈피하여 컴파일러에게 타입을 추론할 수 있게끔 해 개발자가 직접 지역 변수 타입을 작성하는 것을 없애 생산성을 증가시킬 수 있게 되었습니다.</strong></p>

<h3 id="java-11의-특징은-무엇인가요">Java 11의 특징은 무엇인가요?</h3>

<p>Java 11의 주요 특징으로는 <strong>새로운 HTTP 클라이언트인 <code class="highlighter-rouge">HttpClient</code></strong>가 등장했다는 것입니다. <strong>해당 라이브러리를 사용해서 개발자는 어플리케이션의 많고 복잡한 요구사항들을 처리할 수 있게 되었습니다.</strong></p>

<h3 id="stream-api란-무엇인가요">Stream API란 무엇인가요?</h3>

<p><strong>Stream API란 자바에서의 일련의 데이터 요소인 배열이나 컬렌션 등을 처리하기 위해 함수형 스타일을 지원해주는 API 입니다.</strong> Stream API를 사용하면 멀티 스레드를 활용해서 병렬로 연산을 수행할 수 있고, 내부 반복으로 연산을 수행하기 때문에 코드가 매우 간단해집니다.</p>

<h3 id="functional-interface란-무엇인가요">Functional Interface란 무엇인가요?</h3>

<p><strong>Functional Interface란 정확히 하나의 추상 메서드가 정의된 인터페이스를 의미합니다.</strong> 함수형 인터페이스의 예로는 Predicate, Comparator, Runnable 인터페이스 등이 존재합니다.</p>

<h3 id="lamda-expression이란-무엇인가요">Lamda Expression이란 무엇인가요?</h3>

<p><strong>Lamda Expression이란 Functional Interface를 구현하는 객체를 만들지 않고도 추상 메서드를 구현해서 해당 인터페이스 사용할 수 있는 표현식을 의미합니다.</strong> 특정 인터페이스를 사용하기 위해 일회용 객체를 만들지 않아도 됨으로 성능면에서 좋다고 생각합니다.</p>

<h3 id="method-reference란-무엇인가요">Method Reference란 무엇인가요?</h3>

<p>Method Reference는 기존에 정의된 메서드와 동일한 람다 표현식을 매번 작성하는데 발생하는 불편함에서 나온 기법이며 <strong>람다 표현식을 직접 작성하는 대신에 기존의 메서드 정의를 이용하는 방법</strong>입니다. 이를 통해 개발자는 중복된 코드를 없앨 수 있으며 자연스레 생산성과 가독성 증가 효과를 얻을 수 있다고 생각합니다.</p>

<h3 id="optional-클래스는-무엇인가요">Optional 클래스는 무엇인가요?</h3>

<p>Optional 클래스는 Java 8에서 새롭게 등장한 클래스이구요 <strong>util 패키지</strong>에 속해 있습니다. <strong>Optional 클래스는 자바 프로그래머들이 가장 자주 접하는 예외인 NPE(NullPointerException)를 관리 하기 위해 기존 객체를 감싼 Wrapper Class 입니다.</strong></p>

<h3 id="default-method는-무엇인가요">Default Method는 무엇인가요?</h3>

<p><strong>Default Method는 인터페이스에서 메서드 정의 뿐만 아니라 구현도 포함하는 메서드를 만들기 위해 사용되어집니다.</strong> 해당 인터페이스를 구현하는 클래스는 인터페이스의 Default Method도 상속받기 때문에 최소한의 추상 메서드만 구현하면 됩니다. <strong>즉, 디폴트 메서드를 통해 인터페이스는 서브 클래스가 구현해야하는 최소한의 인터페이스 스펙을 유지할 수 있습니다.</strong></p>

<h3 id="추상클래스와-인터페이스의-차이는-무엇인가요">추상클래스와 인터페이스의 차이는 무엇인가요?</h3>

<p>추상 클래스는 추상화된 클래스를 의미하고 인터페이스는 클래스에서 구현해야 하는 스펙을 의미합니다. 이러한 이유에서 추상 클래스와 인터페이스의 가장 큰 차이는 <strong>사용법</strong>에서 존재한다고 생각합니다. <strong>추상 클래스는 멤버 변수와, 메소드 명세, 구현 등 모든 부분이 상속 되기 때문에 코드의 재사용을 위해서 사용하는 경우가 많고 인터페이스는 Java 8 이전에는 메서드 명세만 상속되었기 때문에 메소드 명세의 상속을 위해서 사용된다고 생각합니다.</strong></p>

<p>또한 단일 상속만을 지원하는 자바의 특성상 클래스를 상속하는 추상화 계층이 많아질수록 상속되는 클래스간에 결합도가 증가하기 때문에 관련 도메인에 잘 맞추어서 인터페이스와 추상클래스를 적절히 사용해야 한다고 생각합니다.</p>

<h3 id="오버라이딩overriding과-오버로딩overloading은-각각-무엇인가요">오버라이딩(Overriding)과 오버로딩(Overloading)은 각각 무엇인가요?</h3>

<p><strong>오버라이딩이란 서브클래스가 상속받은 메서드를 해당 클래스에 맞게 재구현 하는 것을 의미</strong>하구요 <strong>오버로딩이란 동일한 메서드 이름이지만 매개 변수 타입이나 개수가 다른 즉, 다른 명세를 가진 함수를 같은 클래스내에 만드는 것을 의미</strong>합니다.</p>

<ul>
  <li>리턴 타입이 다른 경우는 오버로딩이 아닙니다. 컴파일러는 메서드 시그니처를 통해서 메서드 간의 차이를 식별합니다. 메서드 시그니처가 동일한 경우 리턴 타입이 달라도 컴파일 에러가 발생합니다. (같은 클래스에 동일한 메서드가 존재할 수 없기 때문)</li>
</ul>

<blockquote>
  <h3 id="메서드-시그니처method-signature"><strong>메서드 시그니처(Method Signature)</strong></h3>

  <p><strong>Java에서 메서드 시그니처란 메서드 정의에서 메서드 이름과 매개변수 리스트의 조합을 말한다.</strong></p>
</blockquote>

<h3 id="업캐스팅up-casting과-다운캐스팅down-casting이란-무엇인가요">업캐스팅(Up Casting)과 다운캐스팅(Down Casting)이란 무엇인가요?</h3>

<p><strong>업캐스팅이란 슈퍼 클래스의 변수에 서브 클래스의 인스턴스가 들어가는 것</strong>을 의미하구요, <strong>다운캐스팅이란 업캐스팅 된 변수의 타입을 서브 클래스 타입으로 변경하는 것</strong>을 의미합니다. <u>서브 클래스는 슈퍼 클래스의 명세를 상속받기 때문에 슈퍼 클래스의 변수에 들어가서 슈퍼 클래스 인스턴스인 것처럼 사용될 수 있는 것은 당연하구요, 업캐스팅 된 변수의 타입이 다시 서브 클래스로 돌아와서 다시 본인의 클래스 변수인 것처럼 사용될 수 있는 것도 당연합니다.</u></p>

<h3 id="제네릭generic이란-무엇인가요">제네릭(Generic)이란 무엇인가요?</h3>

<p><strong>제네릭(Generic)이란 컴파일 타임에 강한 타입체크와 불필요한 캐스팅 코드를 삭제하기 위해서 사용하는 기능입니다.</strong> 제네릭 사용을 통해서 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있었고 매번 Object나 bounded type으로 캐스팅 시 발생하는 반복적인 코드를 없앨 수 있었습니다.</p>

<h3 id="제네릭generic을-사용해-보셨나요">제네릭(Generic)을 사용해 보셨나요?</h3>

<p>많은 프레임워크와 라이브러리에서 제네릭을 사용해 보았지만 Pinpoint Webhook 프로젝트에서 제네릭을 사용했던 경험이 가장 기억에 남습니다. <strong>상위 추상 클래스인 AgentChecker가 검색하는 Metric 타입을 제네릭 타입으로 지정해 놓고 이를 상속하는 서브 타입의 Checker에서 제네릭 타입을 설정해 구현한 경험이 생각 납니다.</strong></p>

<p><strong>이를 통해서 특정 Metric을 검색하는 Checker클래스를 여러개 만들 필요가 없었고, 컴파일 시에 타입 에러를 볼 수 있어서 확실한 장점이 있었지만, 처음 코드를 보는 사람들한테는 어려워서 가독성 측면에서는 좋지 않았던 것 같습니다.</strong></p>

<h3 id="string과-stringbuffer-stringbuilder의-차이를-설명해주세요">String과 StringBuffer, StringBuilder의 차이를 설명해주세요.</h3>

<p><strong>String과 StringBuffer, StringBuilder는 모두 문자열을 다룰 수 있는 java.lang 패키지의 클래스입니다. 하지만 String은 불변 객체이구요, StringBuffer와 StringBuilder는 가변 객체 입니다. StringBuffer는 멀티스레드 환경에서 thread-safe하게 동작할 수 있는 동기화 기능을 지원해주구요, StringBuilder는 동기화 기능을 지원해주지 않아서 멀티스레드 환경에서 thread-safe하지 않습니다.</strong></p>

<blockquote>
  <h3 id="불변-객체immutable-object">불변 객체(Immutable Object)</h3>

  <p>불변 객체란 객체 생성 후에 그 상태나 값을 바꿀 수 없는 객체를 말합니다.</p>
</blockquote>

<h3 id="annotation이란-무엇인가요">Annotation이란 무엇인가요?</h3>

<p><strong>애노테이션(Annotation)이란 Java 버젼 5부터 추가된 기능으로 소스코드에 메타데이터 정보를 추가하기 위해 사용되어집니다. 애노테이션은 컴파일 타임에 컴파일러에게 특정 정보를 제공해 주기 위해 사용되어지거나, 런타임에 JVM에게 특정 정보를 제공해 주기 위해서 사용되어집니다.</strong></p>

<blockquote>
  <h3 id="메타데이터metadata">메타데이터(Metadata)</h3>

  <p>데이터에 관한 구조화된 데이터로, 다른 데이터를 설명해 주는 데이터이다. 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 대하여 부여되는 데이터이다. 어떤 데이터 즉 구조화된 정보를 분석, 분류하고 부가적 정보를 추가하기 위해 그 데이터 뒤에 함께 따라가는 정보를 말한다.</p>
</blockquote>

<h3 id="java-collection-framework에-대해서-설명해주세요">Java Collection Framework에 대해서 설명해주세요.</h3>

<p><strong>자바에서 Collection이란 데이터의 집합과 그룹을 의미하며 이를 저장하고 연산할 수 있는 집합을 Collection Framework라고 합니다.</strong> Collection 프레임워크는 크게 두개의 명세로 나눌 수 있는데요 <strong>순서나 집합적인 저장 공간의 명세를 나타내는 Collection 인터페이스와 키와 값으로 데이터를 핸들링하는 명세를 정의하는 Map 인터페이스로 나눌 수 있습니다.</strong></p>

<p>Set, List, Queue 인터페이스가 Collection 인터페이스를 상속해서 각 특성에 맞게 명세를 구체화하구요, HashMap, TreeMap 등이 Map 인터페이스를 구현해서 컬렉션 프레임워크를 형성합니다.</p>

<p><img src="/assets/interview/naver-practical-interview-preparation5-3.jpg" style="width:100%" /></p>

<h3 id="set-list-queue의-차이를-설명해주실-수-있나요">Set, List, Queue의 차이를 설명해주실 수 있나요?</h3>

<p><strong>List 인터페이스는 객체의 순서가 존재하며 원소가 중복될 수 있는 명세</strong>를 가지고 있습니다. List 인터페이스의 대표적인 구현체로는 ArrayList(동기화 보장 x)가 있습니다.</p>

<p><strong>Queue 인터페이스는 FIFO의 특성을 갖고 있으며 원소가 중복될 수 있는 명세</strong>를 가지고 있습니다. Queue 인터페이스의 대표적인 구현체로는 LinkedList가 있습니다.</p>

<p><strong>Set 인터페이스는 원소의 집합을 의미하며 원소의 순서가 없고 동일한 원소를 중복 저장할 수 없는 명세</strong>를 가지고 있습니다. Set 인터페이스의 대표적인 구현체로는 HashSet, TreeSet 등이 있습니다.</p>

<h3 id="linkedlist와-arraylist의-차이는-무엇인가요">LinkedList와 ArrayList의 차이는 무엇인가요?</h3>

<p><strong>ArrayList는 내부적으로 원소를 배열에서 관리하고, LinkedList는 노드에 데이터를 저장하고 포인터를 사용해서 앞 뒤의 노드와 연결지어 데이터를 관리합니다.</strong></p>

<p>삽입 및 삭제시 LinkedList는 O(1)의 시간이 걸리고, ArrayList는 O(n)의 시간이 걸립니다. 하지만 인덱스를 통해서 검색시 ArrayList는 O(1)의 시간이 걸리고 LinkedList는 O(n)의 시간이 걸립니다. 인덱스를 통해서 데이터를 관리하고 싶은 경우 ArrayList를 사용하면 좋을 것 같구요, 그렇지 않다면 LinkedList를 사용하면 좋을것 같습니다.</p>

<h3 id="hashmap은-무엇인가요">HashMap은 무엇인가요?</h3>

<p><strong>HashMap은 Hash Function을 사용해서 Key를 Hash값으로 바꾼 뒤 이를 사용해서 데이터를 관리 및 연산하는 데이터 구조를 의미합니다.</strong> HashMap의 CRUD 시간 복잡도는 O(1)이지만, 충돌(Collision)이 자주나는 경우 시간 복잡도는 O(n)까지 안좋아질 수 있음으로 Open Address나 Separate Chaining 방식을 고려해야 합니다.</p>

<h3 id="hashmap과-hashtable의-차이를-아시나요">HashMap과 HashTable의 차이를 아시나요?</h3>

<p><strong>HashTable은 동기화 기능을 제공해주기 때문에 멀티 스레드 환경에서 Thread-Safe하고, HashMap은 동기화 기능을 제공해주지 않기 때문에 멀티 스레드 환경에서 Non Thread-Safe 합니다.</strong></p>

<h3 id="arraylist와-vector의-차이는-무엇인가요">ArrayList와 Vector의 차이는 무엇인가요?</h3>

<p>ArrayList와 Vector의 차이는 <strong>동기화 기능 제공의 유무</strong>라고 생각합니다. <strong>Vector는 동기화 기능을 제공해주기 때문에 멀티 스레드 환경에서 Thread-Safe하고, ArrayList는 동기화 기능을 제공해주지 않기 때문에 멀티 스레드 환경에서 Non Thread-Safe 합니다.</strong></p>

<h3 id="treemap과-treeset의-차이는-무엇인가요">TreeMap과 TreeSet의 차이는 무엇인가요?</h3>

<p><strong>TreeSet과 TreeMap은 모두 Red Black Tree를 기반으로하는 자료구조입니다.</strong> 가장 큰 차이라고 하면 Set과 Map의 차이입니다.</p>

<blockquote>
  <h3 id="red-black-tree">Red Black Tree</h3>

  <p>Red Black Tree는 Balanced Binary Search Tree의 일종으로써 BST에서 발생하는 편향성 문제를 색깔을 통해서 자체적으로 해결하는 자료구조입니다.</p>
</blockquote>


</article>



<section class="tags">
  <strong>Tags:</strong> <a href="/tag/Data-Structre">Data-Structre</a>,&nbsp;<a href="/tag/LinkedList">LinkedList</a>,&nbsp;<a href="/tag/Array">Array</a>,&nbsp;<a href="/tag/Queue">Queue</a>,&nbsp;<a href="/tag/Map">Map</a>,&nbsp;<a href="/tag/Set">Set</a>,&nbsp;<a href="/tag/Java">Java</a>,&nbsp;<a href="/tag/Abstract">Abstract</a>,&nbsp;<a href="/tag/Interface">Interface</a>,&nbsp;<a href="/tag/Generic">Generic</a>
</section>



<section class="rss">
  <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
</section>

<section class="share">
  <span>Share: </span>
  
    
    
    
    
    
    
    
    
  
    
    
    
      <a href="//www.facebook.com/sharer.php?t=%5B%EC%8B%A4%EB%AC%B4+%EB%A9%B4%EC%A0%91+%EC%A4%80%EB%B9%84+-+5%5D+%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0+%26+Java+%28Data+Structrue+%26+Java%29&u=http%3A%2F%2Flocalhost%3A4000%2Finterview%2F2021%2F03%2F03%2FNAVER-Practical-Interview-Preparation-5.html"
        onclick="window.open(this.href, 'facebook-share', 'width=550,height=255');return false;">
        <i class="fa fa-facebook-square fa-lg"></i>
      </a>
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
      <a href="//www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Finterview%2F2021%2F03%2F03%2FNAVER-Practical-Interview-Preparation-5.html"
        onclick="window.open(this.href, 'linkedin-share', 'width=550,height=255');return false;">
        <i class="fa fa-linkedin-square fa-lg"></i>
      </a>
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
</section>




</div>
</div>

    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h3 class="footer-heading">Green Frog Developer</h3>

    <div class="site-navigation">

      <p><strong>Site Map</strong></p>
      <ul class="pages">
				
	

	

	

	
	<li class="nav-link"><a href="/portfolio/">Portfolio</a>
	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </div>

    <div class="site-contact">

      <p><strong>Contact</strong></p>
      <ul class="social-media-list">
        <li>
          <a href="mailto:qowhdwlsdk@gmail.com">
            <i class="fa fa-envelope-o"></i>
            <span class="username">qowhdwlsdk@gmail.com</span>
          </a>
        </li>

        
          
        
          
          <li>
            <a href="https://www.facebook.com/profile.php?id=100046067473526" title="Friend me on Facebook">
              <i class="fa fa-facebook"></i>
              <span class="username">배종진</span>
            </a>
          </li>
          
        
          
          <li>
            <a href="https://github.com/imbf" title="Fork me on GitHub">
              <i class="fa fa-github"></i>
              <span class="username">imbf</span>
            </a>
          </li>
          
        
          
          <li>
            <a href="https://www.linkedin.com/in/%EC%A2%85%EC%A7%84-%EB%B0%B0-9992251a8/" title="Connect with me on LinkedIn">
              <i class="fa fa-linkedin"></i>
              <span class="username">배종진</span>
            </a>
          </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        

      </ul>
    </div>

    <div class="site-signature">
      <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
      <p class="text">객체지향을 사랑하고 클린코드에 관심이 많습니다. 질문을 좋아하고 생각하는 것을 좋아합니다.
</p>
    </div>

  </div>

</footer>

<!-- Scripts -->
<script src="//code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.1/js/lightbox.min.js"></script>
<script src="//unpkg.com/popper.js@1"></script>
<script src="//unpkg.com/tippy.js@5"></script>

<script type="text/javascript">
$(document).ready(function() {
  // Default syntax highlighting
  hljs.initHighlightingOnLoad();

  // Header
  var menuToggle = $('#js-mobile-menu').unbind();
  $('#js-navigation-menu').removeClass("show");
  menuToggle.on('click', function(e) {
    e.preventDefault();
    $('#js-navigation-menu').slideToggle(function(){
      if($('#js-navigation-menu').is(':hidden')) {
        $('#js-navigation-menu').removeAttr('style');
      }
    });
  });

	// Enable tooltips via Tippy.js
	if (Array.isArray(window.tooltips)) {
		window.tooltips.forEach(function(tooltip) {
			var selector = tooltip[0];
			var config = tooltip[1];
			tippy(selector, config);
		})
	}
});

</script>






  </body>

</html>
