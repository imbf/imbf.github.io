<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Green Frog Developer</title>
    <description>객체지향을 사랑하고 클린코드에 관심이 많습니다. 질문을 좋아하고 생각하는 것을 좋아합니다.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 28 Feb 2021 00:20:17 +0900</pubDate>
    <lastBuildDate>Sun, 28 Feb 2021 00:20:17 +0900</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>[실무 면접 준비 - 1] 인턴 프로젝트 (Booking Recommendation System)</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;booking-recommendation-system&quot;&gt;Booking Recommendation System&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;인턴-기간-동안에-개발한-예약-추천-시스템에-대해-저희에게-간단히-설명해-주실-수-있나요&quot;&gt;인턴 기간 동안에 개발한 예약 추천 시스템에 대해 저희에게 간단히 설명해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;제가 이번 인턴 기간 동안에 개발한 예약 추천 시스템은 과거 예약 데이터를 사용해 네이버 예약 사용자들이 특정 업체 선택 시 선택한 업체와 가장 유사한 업체, 선택한 업체의 사용자들이 가장 선호하는 업체와 업종을 추천해 주는 시스템을 만들었습니다.&lt;/p&gt;

&lt;h3 id=&quot;인턴-기간-동안에-진행한-추천-시스템-개발을-통해-얻은-점이-있나요&quot;&gt;인턴 기간 동안에 진행한 추천 시스템 개발을 통해 얻은 점이 있나요?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DB부터 Front-End까지의 End-To-End 개발로 전체적인 시스템 아키텍처에 대한 이해가 높아질 수 있는 계기가 되었습니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;지금까지 많은 프로젝트를 진행하면서 서비스에 필요한 서버 단이나 DB 단만 개발해 왔습니다. 하지만 이번 인턴 기간을 통해 추천 시스템을 처음부터 끝까지 End-To-End로 개발해 전체적인 시스템 아키텍처에 대한 이해가 높아질 수 있는 계기가 되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;서비스를 만들기 위해 시스템의 구현 뿐만 아니라 운영도 아주 중요한 요소라는 점을 깨닫는 계기가 되었습니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;사실 학생 때는 시스템이 정상동작하는 것만 신경썻는데, 막상 인스턴스가 많은 시스템을 구현해보니 DB Lock에 의한 일시적인 에러나 서버 인스턴스에 문제가 생기는 등 운영상의 이슈가 발생했습니다. 예전에는 해당 이슈가 일어난 인스턴스들을 재시작하면 문제가 해결되는 줄 알았으나 이는 일시적인 문제 해결일 뿐이고, 서비스를 위해서는 시스템의 정상적인 운영도 꼭 필요하다는 점을 깨닫게 되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기본기의 중요성에 대해서 깨닫는 계기가 되었습니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;추천 시스템을 구현하면서 Spring Boot Web을 제외한 대부분의 인스턴스들은 처음 학습하였습니다. 새로운 기술들을 빠르게 학습하고 적용하기 위해서는 전체 시스템을 이해할 수 있는 능력인 기본기가 가장 중요하다고 느끼게 되었고 현재에도 운영체제(공룡책)을 정독하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;추천-시스템-개발간에-가장-어려웠던-점은-무엇인가요&quot;&gt;추천 시스템 개발간에 가장 어려웠던 점은 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추천 시스템을 개발하면서 가장 어려웠던 점은 추천을 위해서 추천 알고리즘을 기획하고 설계했던 부분이 가장 어려웠던 것 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;제 서비스에서 추천 알고리즘의 성능 평가는 사용자들의 객관적인 지표가 존재하지 않기 때문에 주관적으로 평가가 되어지는데, 좋은 추천 알고리즘을 위해서는 대부분의 사람들이 선호할만한 업체나 업종을 추천하는 알고리즘을 개발했어야만 했고, 이러한 알고리즘을 개발하기 위해서 사용되어지는 모든 로직과 상수값, 기준점들이 다 마땅한 이유가 있어야만 했었고, 그러한 고민 속에서도 추천 알고리즘이 제 자신만의 색깔을 잃어버리면 안됬었습니다. 종합해보자면 저는 좀 더 특별하고, 재미있고, 성능 좋은 알고리즘을 만들기 위해서 많이 고민했던 것 같습니다. 당연히 추천 서비스는 처음 해보는 거라서 추천 알고리즘의 기획과 설계가 많이 어려웠지만 이를 위해 A4용지로 20장도 넘게 그림을 그리는 것을 통해서 머리속의 생각들을 정리할 수 있었고 이를 통해 재미있고 좋은 알고리즘이 나올 수 있었던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;추천-시스템을-개발하시면서-분명히-시간이-부족했을텐데-어떠한-부분을-더-챙기고-싶었나요&quot;&gt;추천 시스템을 개발하시면서 분명히 시간이 부족했을텐데… 어떠한 부분을 더 챙기고 싶었나요?&lt;/h3&gt;

&lt;p&gt;사실 더 개발하고 싶은 부분은 너무 많았습니다. 추천 알고리즘 개선부터 Redis나 Batch의 장애 대응 고도화, 배치에 병렬 프로그래밍 도입 등 다양한 부분을 더 개발 하고 싶었는데, 일단 기간 내에 서비스를 완성하는 것이 가장 중요하니 어느 정도 개발된 부분에 대해서는 만족했어야만 했습니다. &lt;strong&gt;이러한 많은 부분 중에서 그래도 가장 관심있는 부분은 장애 대응 고도화입니다.&lt;/strong&gt; 현재 Batch나 Redis에 장애 대응 전략을 세워서 개발하였지만 아직 부족한 부분이 몇가지 존재해서 현재에도 계속 공부하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떻게-장애-대응을-고도화-시키고-싶으시나요&quot;&gt;어떻게 장애 대응을 고도화 시키고 싶으시나요?&lt;/h3&gt;

&lt;p&gt;일단 현재 Batch Process에 장애 대응을 위해서 Skip, Retry, Back-off 전략을 구현한 상태이며 &lt;strong&gt;Batch Process 실패시 알람을 보내는 클라이언트 부분을 개발하고 싶습니다.&lt;/strong&gt; 두 번째로는 현재 Redis 장애 대응을 위해 Master-Replica 운영 모델을 도입해서 적용 했는데, 좀 더 &lt;strong&gt;장애 대응을 자동화 하기 위해서 Redis Sentinel이나 Redis Cluster 운영 모델을 도입하고 싶습니다. 아니면 Health Checker도 도입해보고 싶습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;health-checker란-무엇인가요&quot;&gt;Health Checker란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Health check는 서버의 상태를 주기적으로 체크하여 서버의 상태가 통신이 불가능할 경우 서버에 특정 조치를 취해 서비스를 원활하게 제공하기 위해 이용되는 방법이다.&lt;/strong&gt; 서버의 상태를 주기적으로 점검하는 방법으로는 Link, ARP, ICMP, TCP, Script 방식이 있으며, 헬스체크에서는 서버로 일정 시간 간격으로 서비스에 대하여 Open과 Close를 반복적으로 진행하여 서비스 제공 가능 유무를 점검합니다. 아마 제가 구현하고 싶은 방식은 가장 익숙한 TCP 방식이지 않을까 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;헬스체크를 위해 사용되는 패킷의 종류, 패킷을 전송하는 주기와 서버의 응답을 기다리는 시간, 응답이 수신 되지 않았을 때 다시 패킷을 보내주는 횟수는 사용자의 설정에 따라 동작합니다. 전송 주기가 짧을 수록 서버의 장애 여부를 정확하게 파악할 수 있지만, 이는 네트워크의 부하가 될 수 있음으로 문맥을 잘 고려해서 설정 해야만 합니다.&lt;/p&gt;

&lt;h3 id=&quot;네이버-예약에-추천-시스템이-왜-필요할까요&quot;&gt;네이버 예약에 추천 시스템이 왜 필요할까요?&lt;/h3&gt;

&lt;p&gt;현 시대에 사는 사람들은 인터넷에 너무나 많은 정보가 존재하기 때문에 자신이 어떠한 정보를 원하는지 조차도 잘 알지 못합니다. 이러한 상황은 네이버 예약 사용자들에게도 동일하게 발생한다고 생각합니다. 너무나 많은 업체 및 상품들이 등록되어 있어서 사용자들은 어떤 업체를 예약해야될지 잘 알지 못합니다. 이러한 불편함을 해결해주고자 수 많은 업체를 필터링해서 사용자가 선호할만한 업체를 추천해주는 시스템이 네이버 예약에 꼭 필요하다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;추천-시스템의-기대-효과는-무엇인가요&quot;&gt;추천 시스템의 기대 효과는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;추천 시스템의 대표적인 기대 효과로는 네이버 예약 사용자들의 서비스 만족도 증가 효과를 기대할 수 있구요, 또한 추천 시스템으로부터 발생한 다양한 지표를 활용해서 새로운 이벤트를 기획할 수도 있습니다. 이 뿐만 아니라 평소라면 검색하지 못할 다양한 업체를 추천 시스템을 통해서 추천해줌으로써 사용자의 예약의 폭 확장을 불러일으킬 수도 있습니다. 결국 추천 시스템을 통해서 예약 서비스의 성장을 이룰 수 있다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;여러-추천-대상-중-왜-업체를-추천하게-되었나요&quot;&gt;여러 추천 대상 중 왜 업체를 추천하게 되었나요?&lt;/h3&gt;

&lt;p&gt;예약 추천 시스템을 기획해 보았을 때 추천 대상은 크게 업종과 업체, 상품으로 나눌 수 있었습니다. 이들간의 관계를 살펴보면 업종은 업체를 포함하고 업체는 상품을 포함합니다. 업종을 추천하게 된다면 사용자들은 같은 업종에 속한 수 많은 업체 중 특정 업체를 선택해야만 하는 불편함이 발생했고, 상품을 추천하기에는 동일한 업체임에도 불구하고 등록된 상품들의 다양성이 너무 심해서 알고리즘의 성능이 좋지 않을것 같았습니다. 이러한 이유에서 업체 추천이 가장 적절하다고 생각해서 업체를 추천하는 시스템을 기획하게 되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;패치&quot;&gt;패치&lt;/h3&gt;

  &lt;ol&gt;
    &lt;li&gt;정지 없이 서버 패치를 한 방법 새 버전으로 준비된 서버들을(site B) 미리 준비한다.&lt;/li&gt;
    &lt;li&gt;기존 서버로의 추가 유입을 막고(Drain) 새 버전 서버로 유입되도록 바꿉니다(Redirect)&lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;Draining과 Redirecting을 계속하여 두 개의 Site를 뒤집는(Flip) 방식으로 서비스의 중단 없이 패치를 적용합니다.&lt;/p&gt;

      &lt;p&gt;&lt;img src=&quot;/assets/interview/naver-practical-interview-preparation1-3.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;Flip이 완료되면 모든 접속이 새 Site로 붙게되며 기존 Site는 deactivate 됩니다.&lt;/li&gt;
  &lt;/ol&gt;

  &lt;h3 id=&quot;장애&quot;&gt;장애&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;장애는 피할 수 없다. 장애에 견디고 복구 가능한지가 중요하다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;모든 서비스는 Health Check 프로토콜을 구현하고 있습니다. Health Check가 실패한 경우를 모니터링하여 장애를 감지합니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;SPOF&lt;/strong&gt; 를 피하기 위해 동종 서비스들은 개념적으로 Pool에 담겨 있고 장애 감지시 해당 노드가 Pool 에서 제거됩니다.&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;단일 장애점(single point of failure, SPOF)은 시스템 구성 요소 중에서, 동작하지 않으면 전체 시스템이 중단되는 요소를 말한다&lt;/strong&gt;&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;그리고 서비스 종류별 Pool을 두고 있습니다.&lt;/p&gt;

  &lt;p&gt;만약 예상치 못한 이유로 서비스 전체나 상당부분이 불안정한 경우가 발생한다면 서버들을(Site) 다시 배포합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;recommendation-algorithm&quot;&gt;Recommendation Algorithm&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;업체와-업종-추천을-위해서-사용한-알고리즘에-대해-저희에게-알려주실-수-있나요&quot;&gt;업체와 업종 추천을 위해서 사용한 알고리즘에 대해 저희에게 알려주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;일단 수 많은 업체와 업종 중 특정 대상을 추천하려면 추천 대상간에 랭킹 작업이 필요합니다. 저는 랭킹 작업을 진행하기 위해서 랭킹 점수를 업체 간의 접근성과 유사도, 만족도의 곱으로 정의했고 업체간의 유사도를 구하기 위해서 두 가지의 추천 알고리즘을 사용하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;선택한 업체와 가장 유사한 업체를 추천하기 위해 업체와 속성간의 관계를 기반으로 업체를 추천하는 알고리즘인 키워드 기반의 Content Based Filtering을 사용했구요, 선택한 업체의 사용자들이 가장 선호하는 업체를 추천하기 위해 업체와 사용자의 관계를 기반으로 하는 알고리즘인 Collaborative Filtering을 사용하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;키워드-기반의-content-based-filtering이란-무엇인가요&quot;&gt;키워드 기반의 Content Based Filtering이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;일단 Content Based Filtering이란 업체와 속성간의 관계를 기반으로 가장 유사한 업체를 필터링하는 알고리즘을 의미합니다.&lt;/strong&gt; 저는 업체 정보를 분석해 키워드로 나눈 뒤 업체들의 속성을 산출했으며 산출된 속성들과 업체들간의 관계를 행렬로써 표시해 업체간의 유사도를 구할 수 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Content Based Filtering의 한계점으로는 콘텐츠가 많아 질수록 속성을 추출하기 어려워진다는 문제점이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;collaborative-filtering이란-무엇인가요&quot;&gt;Collaborative Filtering이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Collaborative Filtering이란 사용자와 업체간의 관계를 기반으로 사용자들이 가장 선호하는 업체를 필터링하는 알고리즘 입니다.&lt;/strong&gt; 과거 예약 데이터를 사용하면 특정 업체를 예약한 사용자들을 알 수 있고, 사용자들의 업체 선호도를 알 수 있습니다. 이러한 관계를 행렬로써 표시해 업체간의 유사도를 구할 수 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;협업 필터링의 한계점으로 &lt;strong&gt;콜드 스타트, 계산 효율 저하, 롱 테일 등의 문제&lt;/strong&gt;가 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;업종-추천은-어떻게-하셨나요&quot;&gt;업종 추천은 어떻게 하셨나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;업종 추천을 위해서 시간, 순서, 기간에 따른 사건의 규칙을 분석하는 방법인 순차 분석을 사용하였습니다.&lt;/strong&gt; 순차 분석을 위해 특정 업체를 예약한 사용자들의 데이터를 분석 했구요, 사용자들의 개인별 업체 예약 시점을 기준으로 특정 기간 내의 예약 데이터를 분석함으로써 예약한 업체가 속해있는 업종과 다른 업종이 특정 기간 내에 얼마나 자주 예약되는지를 산출 할 수 있었습니다. 이러한 관계를 통해 업종간의 관계를 산출할 수 있었구요 특정 업종에 속한 업체 선택시 관련된 업종을 추천할 수 있는 알고리즘을 설계할 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;추천-알고리즘의-성능-문제나-cold-start-문제를-해결하기-위해서-hybrid-filtering은-고려하지-않았나요&quot;&gt;추천 알고리즘의 성능 문제나 Cold Start 문제를 해결하기 위해서 Hybrid Filtering은 고려하지 않았나요?&lt;/h3&gt;

&lt;p&gt;물론 Hybrid Filtering의 도입도 검토해 보았습니다. Hybrid Filtering은 Collaborative Filtering과 Content Based Filtering으로 표현되어지기 때문에 Cold Start나 Long Tail 등의 문제를 해결할 수 있습니다. 하지만 제 서비스는 사용자 없기 때문에 알고리즘의 성능은 개인의 주관으로 평가되어질 수 밖에 없고 제가 적절하다고 생각했던 알고리즘이 남들이 보기에는 적절하지 않을 수도 있겠다고 생각이 들었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이러한 이유에서 선택한 업체와 유사하면서 선택한 업체의 사용자들이 선호하는 업체를 추천하는 것 보다는 이를 분리해서 선택한 업체와 유사한 업체, 선택한 업체의 사용자들이 선호하는 업체로 나누는 것이 인턴 평가 때 팀원분들이 업체 추천에 대해서 더 쉽게 공감할 수 있겠다고 생각해서 Hybrid FIltering 대신 Content Based Filtering과 Collaborative FIltering을 구현하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;추천-알고리즘-대신-머신러닝을-사용하지-않은-이유&quot;&gt;추천 알고리즘 대신 머신러닝을 사용하지 않은 이유&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;일단 머신러닝을 사용하지 않은 가장 큰 이유는 시간적인 문제 때문에 사용하지 않았습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;총 6주간의 인턴 기간 동안 추천 서비스 기획과 설계에 2주를 사용하고 남은 4주 동안에 추천 시스템을 구현하기 위해 수 많은 기술들을 배우고 적용했어야만 했습니다. 머신러닝을 한번도 접해보지 않은 상황에서 알고리즘을 세우고, 데이터를 전처리하고 학습시켜 모델을 만들고 이를 테스트하고 실제 프로세싱에 적용하기에는 시간이 부족할 거라고 생각했습니다. 또한 로직으로써 추천 알고리즘을 풀어내도 충분히 재미있고 성능 좋은 결과를 낼 수 있을것 같다는 자신감도 조금 있었구요!! 이러한 이유에서 머신러닝 대신 추천 알고리즘을 사용했습니다.&lt;/p&gt;

&lt;h3 id=&quot;형태소-분석기인-komoran을-사용한-이유&quot;&gt;형태소 분석기인 KOMORAN을 사용한 이유&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;업체와 속성간의 관계 행렬을 구하기 위해 업체 정보를 형태소 분석을 통해 키워드로 만들고 싶어서 형태소 분석기인 KOMORAN을 사용했습니다.&lt;/strong&gt; 또한 KOMORAN은 Maven Repository에 등록되어 있기 때문에 간단히 메이븐 설정 파일을 수정하는 것 만으로도 쉽게 라이브러리를 프로젝트에 가져올 수 있다는 장점이 있어서 KOMORAN을 사용하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;cosine-similarity를-사용한-이유&quot;&gt;Cosine Similarity를 사용한 이유&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추천 알고리즘을 사용한다면 업체를 벡터로 표현할 수 있습니다. 이러한 벡터간의 유사도 즉, 업체간의 유사도를 구하기 위해 Cosine Similarity를 사용했으며, 이는 벡터의 크기가 아닌 방향의 유사도를 판단하는 함수입니다.&lt;/strong&gt; 실제로 벡터간의 크기의 유사도를 판단하는 방법인 Euclidean, Manhattan, Minkowski Distance 방법보다 Cosine Similarity가 제 로직에서는 훨씬 성능이 좋았습니다.&lt;/p&gt;

&lt;h3 id=&quot;fasttext를-사용한-이유&quot;&gt;FastText를 사용한 이유&lt;/h3&gt;

&lt;p&gt;업체와 속성간의 관계 행렬을 구하기 위해 텍스트 유사도가 필요했었고, 텍스트 유사도를 구하기 위해 텍스트를 백터로 임베딩할 필요가 있었습니다. &lt;strong&gt;즉, 텍스트를 백터로 임베딩 하기위해 텍스트의 표현 및 분류를 학습할 수 있도록 하는 오픈 소스 라이브러리인 FastText를 사용했으며, 미리 한국어로 학습된 모델을 사용했습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;알고리즘-vs-모델&quot;&gt;알고리즘 vs 모델&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;알고리즘&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;어떤 문제의 해결을 위하여 입력된 자료를 토대로 하여 원하는 출력을 유도하여 내는 규칙&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;모델&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;주어진 데이터를 가지고 알고리즘을 통해서 학습을 시켜서 모델을 도출&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;알고리즘 : y = wx + b&lt;/li&gt;
    &lt;li&gt;모델 : y = 2x + 2 (w와 b를 머신러닝이 구해준다.)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;postgresql&quot;&gt;PostgreSQL&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;postgresql을-사용한-이유가-있으시나요&quot;&gt;PostgreSQL을 사용한 이유가 있으시나요?&lt;/h3&gt;

&lt;p&gt;사실 수 많은 관계형 DBMS 중 PostgreSQL만을 사용하게 된 이유는 없습니다. MSSQL이나 MySQL, MariaDB등 다양한 RDBMS를 고려해보기도 했는데요, 일단 운영 데이터를 가져와서 사용해야 하기 때문에 RDBMS는 무조건적으로 사용해야 했었고 그렇다면 오픈 소스임에도 불구하고 다른 DB에 비해서 좋은 성능과 다양한 기능을 제공해주는 PostgreSQL을 사용해보면 어떨까? 하는 생각에 PostgreSQL을 사용하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;postgresql의-특징에-대해서-알고-있으신가요&quot;&gt;PostgreSQL의 특징에 대해서 알고 있으신가요?&lt;/h3&gt;

&lt;p&gt;일단, 오픈 소스임에도 불구하고 좋은 성능과 다양한 기능을 제공해주는 것으로 알고 있습니다. Microsoft Azure VM 환경에서 여러 DB간에 단순 쿼리 성능을 비교한 지표를 본적이 있는데요 물론 Oracle DB에 비해서는 PostgreSQL의 쿼리 성능이 떨어지긴 하지만 다른 DB에 비해서는 확실히 성능이 좋다는 것을 볼 수 있었습니다. 기능적인 측면에서도 신뢰도를 최우선으로 하여 다양한 인덱싱 기법과, 트랜잭션 및 ACID, 동시성 성능을 높여주는 MVCC 기능, 다양하고 유연한 REPLICA 방식 지원, 다양한 언어에 제공되는 인터페이스, 잘 만든 문서나 메뉴얼 등을 지원해주는 것으로 알고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떠한-인덱싱-기법을-지원해주는가요&quot;&gt;어떠한 인덱싱 기법을 지원해주는가요?&lt;/h3&gt;

&lt;p&gt;기본적으로 PostgreSQL은 B-Tree 인덱스를 지원해주구요, 이 뿐만 아니라 복합 인덱스, GIN(Generalized Inverted Index), Gist(Generalized Inverted Search Tree) 인덱스 타입을 제공해주는 것으로 알고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;동시성-성능을-높여주는-mvcc-기능은-뭔가요&quot;&gt;동시성 성능을 높여주는 MVCC 기능은 뭔가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MVCC란 Multi-Version Concurrency Control의 줄임말로써, 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나라고 알고 있습니다.&lt;/strong&gt; PostgreSQL에 접근하는 사용자는 접근한 시점의 데이터베이스 Snapshot을 읽고, 데이터에 대한 변경이 완료될 때 이를 새로운 버젼으로 가정해 이전 버젼의 데이터와 비교해서 변경된 내용을 기록하는 방법으로 동시성을 제어합니다. 이를 MVCC라고 하구요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Lock이 존재하지 않기 때문에 일반적인 RDBMS보다 빠르게 작동하지만, 버젼 이슈가 생길 수 있다는 점을 주의해야만 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;hr /&gt;

  &lt;h3 id=&quot;postgresql-1&quot;&gt;&lt;strong&gt;PostgreSQL&lt;/strong&gt;&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;오라클에 준하는 기능을 가지고 있다.&lt;/li&gt;
    &lt;li&gt;MVCC, Point in Time Recovery 등의 특징이 존재한다.&lt;/li&gt;
    &lt;li&gt;INSERT, SELECT, UPDATE 쿼리 성능이 비교적 좋은 편이다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;&lt;img src=&quot;/assets/interview/naver-practical-interview-preparation1-1.png&quot; style=&quot;width:90%&quot; /&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;PostgreSQL Instance Objects Hierarchy Architecture&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;&lt;img src=&quot;/assets/interview/naver-practical-interview-preparation1-2.png&quot; style=&quot;width:90%&quot; /&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Oracle구조와 가장 유사한 DB이다.&lt;/li&gt;
    &lt;li&gt;성능도 비슷하다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;redis&quot;&gt;Redis&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;추천-시스템에서-redis를-사용하신-이유가-무엇인가요&quot;&gt;추천 시스템에서 Redis를 사용하신 이유가 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis를 사용하게 된 대표적인 이유는 인메모리 Key-Value 데이터 저장소로써, 추천 데이터를 캐싱하기 위해서 사용하였습니다.&lt;/strong&gt; 뿐만 아니라 Sorted Set과 같은 다양한 자료구조도 지원해주고, Slave-Replica나 Redis Sentinel과 같은 여러 운영 모델도 지원해주기 때문에 시스템을 더 안정적이고 성능이 좋게 만들고 싶어서 Redis를 사용하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;캐싱caching이란-무엇인가요&quot;&gt;캐싱(Caching)이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;캐싱이란 특정 데이터를 빠르게 접근할 수 있도록 임시적인 저장 위치에 데이터를 저장해두는 방법을 의미합니다.&lt;/strong&gt; 캐싱을 통해서 속도가 빠른 장치와 속도가 느린 장치 사이에서 발생하는 병목 현상을 줄일 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;병목(bottleneck) 현상&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;병목(bottleneck) 현상은 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상을 말합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;레디스의-key---value-구조는-어떻게-잡으셨나요&quot;&gt;레디스의 Key - Value 구조는 어떻게 잡으셨나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis에 데이터를 저장하기 위한 키는 크게 키워드 기반의 업체 추천과, 사용자 기반의 업체 추천, 업종 추천, 업종별 업체 추천으로 나누었구요 이들 모두 계층적으로 구성하였습니다.&lt;/strong&gt; &lt;strong&gt;Value는 추천 업체 아이디와 추천 점수를 Json 형태의 문자열로써 저장하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;추천-데이터-저장을-위해-어떠한-자료구조를-사용하셨나요&quot;&gt;추천 데이터 저장을 위해 어떠한 자료구조를 사용하셨나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추천 데이터를 저장하기 위해 SortedSet 자료구조를 사용하였습니다.&lt;/strong&gt; 특정 업체나 업종의 추천 대상들을 저장하기 위해서 Set이나 List와 같은 자료구조를 사용해야만 했으며, 레디스에 저장시 추천 점수별로 정렬 되면 매번 어플리케이션 레이어에서 부담해야하는 정렬 작업이 줄어들어 훨씬 성능면에서 좋아질 것 같아서 SortedSet 자료구조를 사용했으며 정렬을 위한 score는 추천 점수를 사용하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;redis의-운영-모델에-대해서-설명해주세요&quot;&gt;Redis의 운영 모델에 대해서 설명해주세요.&lt;/h3&gt;

&lt;p&gt;레디스 운영 모델은 크게&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 Redis 인스턴스만을 사용하는 Standalone 모델,&lt;/li&gt;
  &lt;li&gt;Master 인스턴스의 데이터를 비동기적으로 여러개의 Replica 인스턴스로 복제하는 Master - Replica 모델,&lt;/li&gt;
  &lt;li&gt;레디스의 높은 고가용성을 위해 모니터링, 알림, 자동화된 장애대응을 지원하는 Redis Sentinel 모델,&lt;/li&gt;
  &lt;li&gt;다양한 장애 대응 및 파티셔닝을 제공하는 Redis Cluster 모델 등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다양한 운영 모델이 존재합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;데이터-분산-방법&quot;&gt;&lt;strong&gt;데이터 분산 방법&lt;/strong&gt;&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Application&lt;/strong&gt;
      &lt;ul&gt;
        &lt;li&gt;Consistent Hashing
          &lt;ul&gt;
            &lt;li&gt;&lt;strong&gt;일관된 해싱&lt;/strong&gt;(Consistent hashing)은 웹서버의 개수가 변동하는 가운데 요청을 분산하는 방법을 말한다. 해시테이블의 크기가 변할 때, 평균적으로 K/n의 키만 재매핑되면 된다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Sharding (Horizontal Partitioning)
          &lt;ul&gt;
            &lt;li&gt;같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Redis Cluster&lt;/strong&gt;
      &lt;ul&gt;
        &lt;li&gt;Hash 기반으로 Slot을 0 ~ 16384로 구분하여 자신의 Slot에 해당하는 Node로 Redirect 된다.&lt;/li&gt;
        &lt;li&gt;장점
          &lt;ul&gt;
            &lt;li&gt;자체적인 Primary, Secondary Failover&lt;/li&gt;
            &lt;li&gt;Slot 단위의 데이터 관리.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;단점
          &lt;ul&gt;
            &lt;li&gt;메모리 사용량이 더 많음&lt;/li&gt;
            &lt;li&gt;Library 의존성&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;redis-장애-대응을-위해-어떻게-처리-하셨죠&quot;&gt;Redis 장애 대응을 위해 어떻게 처리 하셨죠?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis 장애 대응을 위해 하나의 Master와 두 개의 Replica로 이루어진 Master - Replica 운영 모델을 도입하여 Master가 다운될 시 Replica를 통해 Read를 하는 장애 대응 전략을 구축 했습니다.&lt;/strong&gt; 이러한 전략으로는 장애 대응이 완벽하다고 말 할 수는 없으며, Redis Sentinel 이라던지, Health Checker를 도입해서 노드 재시작 및 노드 자동 승격 기능 등을 사용해보고 싶습니다.&lt;/p&gt;

&lt;h3 id=&quot;redis의-구조는-알고-계시나요&quot;&gt;Redis의 구조는 알고 계시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis는 ANSI C를 사용해서 작성되었으며 Disk를 사용해서 persistence를 지원한다.&lt;/strong&gt; redis에서는 데이터를 저장하는 방법으로 snapshot(RDB) 방식과 AOF(Append on file) 방식을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;snappshot(RDB) 방식은 특정 순간에 메모리에 있는 내용 즉, snapshot을 disk에 옮겨 담는 방식이다. (restart 시간이 빠르지만 특정 snapshot 이후 변경된 데이터는 유실된다.)&lt;/li&gt;
  &lt;li&gt;AOF 방식은 redis의 모든 write/update 연산 자체를 모두 log 파일에 기록해서 서버 재시작시 기록된 write/update를 재실행하는 방법이다. (데이터 유실이 발생하지 않지만 restart시 느리다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Redis는 사용자 명령어를 Single Thread로 처리하기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Long-Time&lt;/code&gt; 명령 수행시 다른 명령어들은 처리할 수 없는 상태가 되기 때문에 꼭 주의해야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;redis-java-client인-lettuce는-무엇인가요&quot;&gt;Redis Java Client인 Lettuce는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Lettuce는 Netty 기반의 고성능 비동기 Redis 클라이언트로써 다른 Redis 클라이언트인 Jedis보다 훨신 빠릅니다. 또한 레디스의 다양한 운영 모델과 커넥션을 지원하구요 무엇보다도 잘 만들어진 공식 문서가 매력적입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;database-partioning&quot;&gt;Database Partioning&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;데이터베이스를 여러 부분으로 분할하는 것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;데이터베이스 파티셔닝(DB Partioning)&lt;/code&gt;이라고 한다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;데이터베이스 파티셔닝은 중요한 튜닝기법으로 데이터가 너무 커져서, 조회하는 시간이 길어질 때 또는 관리 용이성, 성능, 가용성 등의 향상을 이유로 행해진다. 데이터베이스가 분할된 각 부분을 &lt;strong&gt;파티션&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

  &lt;h4 id=&quot;database-sharding-수평-분할-horizontal-partioning&quot;&gt;Database Sharding (수평 분할, Horizontal Partioning)&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;테이블을 수평으로 쪼개서 각 행을 다른 DB에 분산시키는 것이다.&lt;/strong&gt; 분할된 각 부분을 &lt;strong&gt;샤드(Shard)&lt;/strong&gt;라고 한다. 즉, 각 샤드의 스키마 구조는 동일하다.&lt;/p&gt;

  &lt;h4 id=&quot;vertical-partioning수직-분할&quot;&gt;Vertical Partioning(수직 분할)&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;테이블을 수직으로 쪼개서 테이블의 일부 열을 다른 DB로 빼내는 형태로 분할한다.&lt;/strong&gt; 정규화는 본질적으로 수직 분할에 관련된 과정이다. 특정 테이블에서 자주 참조되는 열을 수직 분할시켜 해당 데이터를 캐싱할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;이슈&quot;&gt;이슈&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;spring-data-redis-contribution-과정에-대해서-알려주실-수-있나요&quot;&gt;Spring Data Redis Contribution 과정에 대해서 알려주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;redis는 버젼 5.0부터 slave라는 용어가 replica로 변경되었고 Redis 클라이언트인 Lettuce-core는 버젼 5.2.0부터 코드 레벨의 Slave를 Replica로 변경하였습니다. 하지만 최근 Spring Data Redis Doc을 보면 Lettuce-core 버젼 5.2.0 이상을 사용함에도 불구하고 Deprecated된 SLAVE_PREFERRED를 통해서 특정 기능의 사용을 안내 합니다.&lt;/p&gt;

&lt;p&gt;저는 이 부분이 잘못되었다고 생각해 직접 Spring Data Redis 프로젝트에 이슈를 발급하였고 Deprecated 된 부분을 모두 고친 뒤 PR을 날렸습니다. 현재 PR이 머지가 되었으며 해당 이슈가 해결되었습니다.&lt;/p&gt;

&lt;p&gt;많은 사용자가 존재하는 Spring Project에 조그마한 부분이지만 기여할 수 있었다는 점에서 매우 뿌듯하고 행복합니다.&lt;/p&gt;

&lt;h3 id=&quot;outofmemoryexception-이슈에-대해서-공유해주실-수-있나요&quot;&gt;OutOfMemoryException 이슈에 대해서 공유해주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;추천 알고리즘을 위해 업체와 사용자 관계를 벡터 값으로 표현해 Integer 객체로 저장 했는데요, Batch Processing 간에 모든 업체와 모든 사용자간의 관계를 벡터 값으로 표현 했을 경우 수십, 수백억 개의 Interger 객체가 생겼었습니다. &lt;strong&gt;이러한 무분별한 Integer 객체 생성으로 인해 객체를 저장하는 메모리인 Heap의 공간이 부족했었고 결국 JVM의 메모리가 부족하다는 OutOfMemoryError가 발생하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;저는 이러한 이슈를 해결하기 위해 업체의 벡터 값을 저장하기 위한 자료구조를 Integer List 에서 Int 배열 즉, Wrapper 타입에서 Primitive 타입으로 리팩토링 하였고, 이를 통해 Heap 메모리에 저장되는 데이터의 사이즈를 줄여 OutOfMemoryError를 해결할 수 있었을 뿐만 아니라 Wrapper 타입으로 저장 시 발생하는 객체 생성, 참조 등의 부하를 줄여 Batch Processing 성능을 개선할 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;primitive-와-wrapper-타입은-각각-무엇이고-언제-써야하는지-알려주세요&quot;&gt;Primitive 와 Wrapper 타입은 각각 무엇이고, 언제 써야하는지 알려주세요.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Primitive 타입은 Java에 키워드로 등록된 8개의 비객체형 원시 타입을 의미하구요, Wrapper 타입은 primitive type을 Wrapping해 객체로 다루기 위해서 사용하는 클래스를 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;단순하고 반복적인 계산을 위해 Wrapper 타입의 객체가 계속 생성되는 경우 성능상 Primitive 타입을 사용하는 것이 더 좋고, DB에서 데이터를 가져오는 경우나, primitive 타입의 default 값으로부터 혼란이 발생하기 쉬운 경우 Wrapper 타입을 사용하는 것이 더 좋습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;jvm&quot;&gt;JVM&lt;/h2&gt;

  &lt;p&gt;자바 가상 머신으로 &lt;strong&gt;자바 바이트 코드를 실행할 수 있는 주체&lt;/strong&gt;이다.&lt;/p&gt;

  &lt;p&gt;운영체제 위에서 동작하는 프로세스로 &lt;u&gt;자바 코드(.java)를 컴파일해서 얻는 바이트 코드(.class)를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할&lt;/u&gt;을 한다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;JVM의 구성을 살펴보면 크게 4가지(Class Loader, Execution Engine, Garbage Collector, Runtime Data Area)로 나뉜다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;!&lt;img src=&quot;/assets/interview/naver-practical-interview-preparation1-4.png&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

  &lt;h3 id=&quot;1-class-loader&quot;&gt;1. Class Loader&lt;/h3&gt;

  &lt;p&gt;컴파일러를 통해서 생성된 바이트코드(.class)를 엮어서 JVM이 운영체제로부터 할당받은 메모리 영역인 &lt;strong&gt;Runtime Data Area&lt;/strong&gt;로 적재하는 역할을 Class Loader가 한다.&lt;/p&gt;

  &lt;h3 id=&quot;2-execution-engine&quot;&gt;2. Execution Engine&lt;/h3&gt;

  &lt;p&gt;Class Loader에 의해 &lt;strong&gt;메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해 명령어 단위로 실행하는 역할&lt;/strong&gt;을 한다. 명령어를 하나 하나 실행하는 인터프리터(Interpreter)방식이 있고 JIT(Just-In-Time) 컴파일러를 이용하는 방식이 있다.&lt;/p&gt;

  &lt;p&gt;JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높이는 방식이다.&lt;/p&gt;

  &lt;h3 id=&quot;3-garbage-collector&quot;&gt;3. Garbage Collector&lt;/h3&gt;

  &lt;p&gt;Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 &lt;strong&gt;참조되지 않는 객체들을 탐색 후 제거하는 역할&lt;/strong&gt;을 한다.&lt;/p&gt;

  &lt;h3 id=&quot;4-runtime-data-area&quot;&gt;4. Runtime Data Area&lt;/h3&gt;

  &lt;p&gt;JVM은 프로그램 실행간에 사용되어지는 다양한 Runtime Data Area를 제공한다. 이러한 Data Area 중 몇몇은 JVM이 시작할 때 생성되어지고 JVM이 종료되어질 때 소멸된다. 하지만 다른 몇몇의 Data Area는 스레드마다 할당되어진다. 스레드마다 할당되어지는 Data Area는 스레드 생성시 생성되어지고 스레드 종료시 소멸되어진다.&lt;/p&gt;

  &lt;h4 id=&quot;41-the-pc-register&quot;&gt;4.1 The pc Register&lt;/h4&gt;

  &lt;p&gt;JVM은 한번에 많은 스레드의 실행을 지원할 수 있습니다. &lt;strong&gt;각각의 JVM 스레드는 자신의 pc(program counter) register를 갖고 있습니다.&lt;/strong&gt; 언제든지(At any point), JVM 스레드는 단일 메서드 즉(namely), 해당 스레드에 대한 현재 메서드의 코드를 실행할 수 있습니다. 해당 메소드가 native code가 아닌 경우 pc 레지스터에는 현재 실행중인 JVM 명령어의 주소가 포함됩니다. 만약 현재 스레드에 의해서 실행되고 있는 메서드가 native라면, JVM의 pc 레지스터의 값은 정의되지 않을것 입니다. JVM의 pc 레지스터는 특정 플랫폼에서의 native pointer 또는 return Address를 잡을만큼 꽤 큽니다.&lt;/p&gt;

  &lt;h4 id=&quot;42-java-virtual-machine-stacks&quot;&gt;4.2 Java Virtual Machine Stacks&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;각각의 JVM 스레드들은 Java Virtual Machine Stack을 가지고 있고 스레드와 동시에 생성됩니다. Java Virtual Machine Stack은 프레임을 저장합니다.&lt;/strong&gt; JVM Stack은 C와 같은 기존 언어의 스택과 유사합니다. &lt;u&gt;JVM 스택은 지역 변수와 부분적인 결과를 보유하고, 메소드 호출과 반환에서 역할을 수행합니다.&lt;/u&gt; JVM 스택은 프레임을 푸시하고 팝하는 것을 제외하고 직접 조작하지 못하므로 프레임에 heap이 할당될 수 있습니다. JVM 스택의 메모리는 연속적일(contiguous) 필요가 없습니다.&lt;/p&gt;

  &lt;p&gt;스레드에서의 연산이 JVM 스택이 허용하는 것 보다 더 큰 Stack이 필요한 경우 JVM은 StackOverFlowError을 발생합니다.&lt;/p&gt;

  &lt;p&gt;JVM스택이 동적으로 확장되어지고 확장을 위해서 이용가능한 메모리가 불충분함에도 확장을 시도하거나, 새로운 스레드를 위해 JVM 스택의 초기화를 하기위해 메모리가 불충분할 경우 JVM은 OutOfMemoryError를 던집니다.&lt;/p&gt;

  &lt;h4 id=&quot;43-heap&quot;&gt;4.3 Heap&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;JVM은 모든 JVM 스레드 사이에서 공유되어지는 heap 영역을 갖습니다. heap은 모든 클래스의 인스턴스와 배열에 대한 메모리가 할당되는 run-time data area 입니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;heap은 JVM이 시작되어질 때 생성됩니다.&lt;/strong&gt; &lt;strong&gt;객체들의 heap 저장소는 &lt;u&gt;자동 저장소 관리 시스템(Garbage Collector)&lt;/u&gt;에 의해 회수됩니다.&lt;/strong&gt; 객체들은 절대 명시적으로 할당이 해제되지 않습니다. JVM은 특정 유형의 자동 저장소 관리 시스템을 가정하지 않으며 저장소 관리 기술은 구현자의 시스템 요구사항에 따라서 선택되어질 수 있습니다. 힙은 고정된 사이즈가 될 수 있으며 또는 연산에 의해서 확장되어질 수 있습니다. 만약 더 큰 heap이 필요하지 않다면 축소되어질 수도 있습니다. 힙 메모리는 연속적(contiguous)일 필요가 없습니다.&lt;/p&gt;

  &lt;p&gt;JVM은 초기 heap 사이즈를 조절할 수 있도록 프로그래머 또는 사용자에게 제공해주고, 뿐만 아니라 동적으로 힙을 확장 또는 축소할 수 있도록 최대 및 최소 힙 사이즈를 제어할 수 있습니다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;만약 연산이 자동 저장소 관리 시스템으로부터 이용가능한 힙 보다 더 많은 힙을 필요로 한다면, JVM은 OutOfMemoryError를 던집니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;h4 id=&quot;44-method-area&quot;&gt;4.4 Method Area&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;JVM은 모든 JVM 스레드 사이에서 공유되어지는 method area를 가집니다. method area는 기존 언어의 컴파일된 코드를 위한 저장 영역과 유사하거나 운영 체제 프로세스의 텍스트 세그먼트와 유사합니다.&lt;/strong&gt; &lt;strong&gt;method area는 run-time 상수 풀, 필드, 메소드 데이터, 메소드와 생성자를 위한 코드와 같은 클래스별 구조를 저장합니다.&lt;/strong&gt; 이는 인스턴스 초기화와 인터페이스 및 클래스 초기화에서 사용되어지는 특별한 메소드들도 포함합니다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;method area는 JVM이 시작할 때 생성되어지며, 논리적으로 heap의 일부분&lt;/strong&gt;이지만 간단한 구현에서는 Garbage collector 또는 압축을 선택하지 않을 수 있습니다. 이러한 스펙은 컴파일된 코드를 관리하기 위해서 사용되어지는 정책 또는 method area에 대한 위치를 요구하지 않습니다. method area는 고정된 크기일 수 있고 연산에서 요구된다면 확장되어질 수 있습니다. 그리고 불필요하다면 축소될 수도 있습니다. method area를 위한 메모리는 연속적인 공간을 필요하지 않습니다.&lt;/p&gt;

  &lt;h4 id=&quot;45-run-time-constant-pool&quot;&gt;4.5 Run-Time Constant Pool&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;run-time constant pool은 클래스 파일에있는 constant_pool table에 대한 클래스별 또는 인터페이스별 runtime 표현입니다&lt;/strong&gt;. &lt;strong&gt;run-time constant pool은 컴파일 타임에 알려진 숫자 리터럴부터 런타임에 해결되어야하는 메서드 및 필드 참조에 이르기까지  여러 종류의 상수들을 포함합니다.&lt;/strong&gt; run-time constant pool은 일반적인 기호 테이블보다 더 넓은 범위의 데이터를 포함하지만 기존 프로그래밍 언어의 기호 테이블과 유사한 기능을 제공합니다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;각각의 run-time constant pool은 JVM method area로부터 할당되어 집니다. 클래스 또는 인터페이스를 위한 run-time constant pool은 클래스와 인터페이스가 JVM에 의해서 생성되어질 때 생성됩니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;클래스와 인터페이스가 생성될 때 JVM method area에서 이용가능한 메모리보다 더 많은 run-time constant pool 생성을 요구한다면 JVM은 OutOfMemoryError를 발생할 겁니다.&lt;/p&gt;

  &lt;h4 id=&quot;46-native-method-stacks&quot;&gt;4.6 Native Method Stacks&lt;/h4&gt;

  &lt;p&gt;JVM은 native methods(자바 프로그래밍 언어 이외의 언어로 작성된 메서드)를 지원하기 위해 구어적으로(colloquially) C 스택이라고 하는 기존 스택을 사용할 수 있습니다. Native method stacks은 C와 같은 언어에서 JVM 명령어의 집합을 위한 인터프리터의 구현으로부터 사용되어질 수 있습니다. native methods를 로드할 수 없고, 기존 스택에 의존하지 않는 JVM 구현은 native method 스택을 제공할 필요가 없습니다. 만약 제공되어진다면 native method stacks는 일반적으로 스레드가 생성될 때 스레드마다 할당되어집니다.&lt;/p&gt;

  &lt;h3 id=&quot;5-frames&quot;&gt;5. Frames&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;프레임은 데이터와 부분적인 결과를 저장하기 위해 사용되어 집니다. 뿐만 아니라 동적인 linking을 수행하고 메소드를 위해 값을 리턴하고 예외를 dispatch 하기위해서 사용되어집니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;새로운 프레임은 메서드가 호출되어질 때 생성되어지고 메서드 호출이 완료되어질 때 소멸됩니다.&lt;/strong&gt; 프레임들은 프레임을 생성하는 스레드의 JVM stack으로부터 할당되어집니다. &lt;strong&gt;각각의 프레임들은 자신의 지역변수들에 대한 배열과, 피연산자 stack, 현재 메소드의 클래스의 run-time constnat pool의 참조를 가지고 있습니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Frame은 디버깅 정보와 같이 추가적인 구현 스펙 정보와 함께 확장되어집니다.&lt;/p&gt;

  &lt;p&gt;지역 변수 배열 및 피연산자 스택의 크기는 컴파일 타임에 결정이 되어지고, 프레임과 관련있는 메서드에 대한 코드가 제공되어집니다. 프레임 데이터 구조의 사이즈는 오직 JVM 구현에 의존하며 이러한 구조의 메모리는 메서드 호출과 동시에 할당되어집니다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;메서드를 실행하기 위한 프레임은 제어를 위한 스레드가 활성화 되는 시점에서 활성화 됩니다. 이러한 프레임을 현재 프레임이라고 하고 이러한 메소드는 현재 메소드라고 합니다. 현재 메서드가 정의되어진 클래스를 현재 클레스라고 합니다. 지역 변수와 피연산자 스택의 연산은 일반적으로 현재 프레임을 참조합니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;메서드가 다른 메서드를 호출하거나 해당 메서드가 완료한다면 해당 프레임은 현재 상태가 아닙니다. &lt;strong&gt;메서드가 호출될 때 새로운 프레임이 생성되고 현재 프레임이 되며 제어는 세로운 메서드로 이동합니다. 메서드가 리턴되어지면 현재 프레임은 메서드 호출의 결과를 이전 프레임으로 다시 전달합니다. 현재 프레임은 버려지고 이전의 프레임이 현재 프레임이 될것 입니다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;스레드에 의해서 생성되어지는 프레임은 해당 스레드에 로컬이고 어떠한 다른 스레드에 의해서 참조되어질 수 없습니다.&lt;/p&gt;

  &lt;h3 id=&quot;6-garbage-collection&quot;&gt;6. Garbage Collection&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;Runtime Data Area의 Heap 부분은 5개의 영역(eden, survivor1, survivor2, old, permanent)으로 나뉜다.&lt;/strong&gt; heap의 영역을 5개로 나눈 이유는 효율적으로 GC가 일어나게 하기 위함이다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;GC는 Minor GC와 Major GC로 나뉜다.&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Minor GC: New 영역에서 일어나는 GC&lt;/strong&gt;
      &lt;ol&gt;
        &lt;li&gt;최초에 객체가 생성되면 Eden 영역에 생성된다.&lt;/li&gt;
        &lt;li&gt;Eden 영역에 객체가 가득차게 되면 첫 번째 GC가 일어난다.&lt;/li&gt;
        &lt;li&gt;Survivor1 영역에 Eden 영역의 메모리를 그대로 복사한다. 그리고 Survivor1 영역을 제외한 다른 영역의 객체를 제거한다.&lt;/li&gt;
        &lt;li&gt;Eden 영역도 가득차고 Survivor1 영역도 가득차게 된다면, Eden 영역에 생성된 객체와 Survivor1 영역에 생성된 객체 중에 참조되고 있는 객체가 있는지 검사한다.&lt;/li&gt;
        &lt;li&gt;참조 되고있지 않은 객체는 내버려 두고 참조되고 있는 객체만 survivor2 영역에 복사한다.&lt;/li&gt;
        &lt;li&gt;survivor2 영역을 제외한 다른 영역의 객체들을 제거한다.&lt;/li&gt;
        &lt;li&gt;위의 과정중에 일정 횟수이상 참조되고 있는 객체들을 survivor2에서 Old영역으로 이동시킨다.&lt;/li&gt;
        &lt;li&gt;해당 과정의 지속적인 반복&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Major GC(Full GC): Old 영역에서 일어나는 GC&lt;/strong&gt;
      &lt;ol&gt;
        &lt;li&gt;Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.&lt;/li&gt;
        &lt;li&gt;참조되지 않은 객체들을 모아 한 번에 제거한다.
          &lt;ul&gt;
            &lt;li&gt;Minor GC 보다 시간이 훨씬 많이 걸리고 실행중에 GC를 제외한 모든 쓰레드가 중지된다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Major GC(Full GC)가 일어나면,
Old 영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다. 그러면서 Heap 메모리 영역에 중간중간 구멍(파편화)이 생기는데 이 부분을 위해 재구성을 하게 된다(디스크 조각모음처럼 조각난 메모리를 정리함)
&lt;strong&gt;따라서 메모리를 옮기고 있는데 다른 쓰레드가 메모리를 사용해버리면 안되기 때문에 모든 쓰레드가 정지하게 되는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;성능-및-가독성-개선을-위해-쿼리-분리-및-인덱싱-작업을-어떻게-진행하셨나요&quot;&gt;성능 및 가독성 개선을 위해 쿼리 분리 및 인덱싱 작업을 어떻게 진행하셨나요??&lt;/h3&gt;

&lt;p&gt;업종 추천을 위해 사용자가 특정 업체를 예약한 시점을 기준으로 특정 기간 동안의 예약 데이터를 가져와야 하는 쿼리가 필요했습니다. 이를 위해 처음 작성한 쿼리는 조인한 테이블이 많아서 성능도 좋지 않고 가독성도 매우 떨어졌습니다. 이를 해결하기 위해 &lt;strong&gt;쿼리의 개수가 무분별하게 많아지지 않는 선에서 쿼리를 분리했고, 쿼리의 개수가 늘어나 발생하는 지연을 줄이고자 인덱싱 작업을 진행 하였습니다.&lt;/strong&gt; 이를 통해 쿼리의 성능 및 가독성이 증가될 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;db-인덱스란-무엇인가요&quot;&gt;DB 인덱스란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;DB 인덱스는 데이터베이스 테이블의 동작 속도를 높여주는 자료 구조를 의미합니다.&lt;/strong&gt; 마치 책의 앞 부분에 존재하는 목차와 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;인덱싱은-어떠한-경우에-사용하면-좋을까요&quot;&gt;인덱싱은 어떠한 경우에 사용하면 좋을까요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;인덱싱은 테이블에 저장된 데이터의 양이 많고 SELECT가 UPDATE보다 잦은 경우, 인덱스를 사용하고자 하는 컬럼의 값이 다양한 경우에 데이터베이스에 인덱스를 추가한다면 성능 개선의 효과를 볼 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UPDATE나 INSERT가 자주 일어나는 테이블에 수 많은 인덱스를 설정하게 된다면 매번 데이터가 바뀔 때마다 인덱스를 다시 재구성해주어야하는 오버헤드가 발생하기 때문에 성능상의 이슈가 발생할 수 있습니다. 즉, 인덱스는 SELECT 할 때 빛을 발합니다.&lt;/p&gt;

&lt;p&gt;여러 컬럼의 값이 존재하는 경우 보통 여러 컬럼을 활용해서 데이터를 검색하곤 합니다. 이러한 과정에서 매번 PRIMARY KEY로 FULL SEARCH 할 수 없기 때문에 자주 검색되는 컬럼에 인덱스를 걸어주면 성능 향상의 효과를 기대할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-어떠한-컬럼에-인덱스를-설정하는게-좋을까요&quot;&gt;그렇다면 어떠한 컬럼에 인덱스를 설정하는게 좋을까요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;인덱스를 설정하면 좋을 컬럼은&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WHERE 절과 같은 조건 절에 자주 활용되는 컬럼&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;당연히 자주 활용되는 컬럼이 인덱스로 설정되면 성능 향상을 기대할 수 있겠지?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;카디널리티가 높은(컬럼의 중복되는 값이 많이 없는) 컬럼&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;카디널리티가 낮다면 어차피 full search 할테고, 이점이 많이 사라지는게 아닐까? 되도록이면 인덱스를 통해서 많은 row 들을 필터링한다면 그게 성능이 좋은게 아닐까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;복합-인덱스는-무엇인가요&quot;&gt;복합 인덱스는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;복합 인덱스란 인덱스에 컬럼이 두개 이상 걸려 있는 경우를 의미하구요, 보통 조건문에 걸리는 컬럼이 많은 경우에 사용됩니다.&lt;/strong&gt; 복합 인덱스에서 컬럼을 지정할 때 보통 카디널리티가 높은 순에서 낮은 순으로 구성하는 것이 성능이 더 좋습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떠한-자료구조를-사용하여서-인덱싱-작업을-진행-했나요&quot;&gt;어떠한 자료구조를 사용하여서 인덱싱 작업을 진행 했나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;저는 PostgreSQL에서 인덱싱 작업시 default로 지원해주는 B-Tree 자료구조를 사용해서 인덱스를 설정하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;cardinality&quot;&gt;Cardinality&lt;/h3&gt;

  &lt;p&gt;특정 컬럼에 존재하는 값의 중복도를 나타내는 상대적인 표현이다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;중복도가 ‘낮으면’ Cardinality가 ‘높다’고 표현한다.&lt;/strong&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;중복도가 ‘높으면’ Cardinality가 ‘낮다’고 표현한다.&lt;/strong&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ex) 주민등록번호는 중복되는 값이 없으므로 카디널리티가 높고, 이름은 종복되는 값이 많으므로 주민등록번호에 비해 상대적으로 카디닐러티가 낮다고 할 수 있다.&lt;/code&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;api-서버-구현을-위해-어떠한-기술을-사용하셨나요&quot;&gt;API 서버 구현을 위해 어떠한 기술을 사용하셨나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;API 서버 구현을 위해 Spring Boot Web을 사용했구요,&lt;/strong&gt; Front로부터 업체 추천 요청이 들어왔을 경우 Redis에 캐시된 추천 업체 데이터를 읽어와서 이를 사용해서 PostgreSQL로부터 업체 정보를 읽어와 API 를 통해서 추천 데이터를 제공합니다.&lt;/p&gt;

&lt;h3 id=&quot;api-를-설계-및-구현-하면서-어려웠던-점이-있으시나요&quot;&gt;API 를 설계 및 구현 하면서 어려웠던 점이 있으시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;API 구현보다는 설계가 더 어려웠던 것 같습니다. 설계 중에서 가장 어려웠지만 재미있었던 점은 “어떻게 하면 좀 더 확장성 및 유지보수성이 좋은 API를 만들 수 있을까?” 에 대해서 고민했던 점입니다.&lt;/strong&gt; 현재는 제 API서버의 클라이언트는 크게 한 대이지만, 추후에 수 많은 클라이언트가 제 API를 가져다 사용했을 경우 쉽게 확장할 수 있고 쉽게 유지보수가 가능하게 끔 만들어 보고 싶었던  생각에서부터 생겼던 고민이었던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;그래서-api는-잘-설계-되었나요&quot;&gt;그래서 API는 잘 설계 되었나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;네! 제 API를 사용할 여러 클라이언트들의 입장에서 생각하고 고민한 결과 API 설계는 잘 되었던 것 같습니다.&lt;/strong&gt; 제 API는 크게 업체 정보 API, 상품 정보 API, 업종 추천 API, 업체 추천 API로 각 API들은 되도록 Restful하게 만들었습니다.&lt;/p&gt;

&lt;h3 id=&quot;restful-api가-무엇인지-저희에게-설명해주실-수-있나요&quot;&gt;Restful API가 무엇인지 저희에게 설명해주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Restful API는 REST 아키텍쳐 스타일을 따르는 API를 의미합니다. REST는 분산 하이퍼미디어 시스템(예, 웹)을 위한 소프트웨어 아키텍처 스타일을 의미하구요 이를 위해 6가지의 제약조건이 존재합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Uniform Interface:&lt;/strong&gt; 구성요소(클라이언트, 서버 등) 사이의 인터페이스는 균일(uniform)해야 한다.
    &lt;ul&gt;
      &lt;li&gt;시스템 아키텍처가 단순화되고, 구현과 서비스가 분리되므로 독립적인 진화가 가능하다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제약조건&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;identification of resources:&lt;/strong&gt; 리소스가 URI로 식별&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;manipulation of resources through representations:&lt;/strong&gt; representation 전송을 통해서 resource를 조작해야 한다.&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;self-descriptiove messages:&lt;/strong&gt; 메시지는 스스로 설명해야한다.
            &lt;ul&gt;
              &lt;li&gt;ex) Content-Type, API&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;hypermedia as the engine of application state (HATEOAS):&lt;/strong&gt; 애플리케이션의 상태는 항상 hyperlink를 통해서 전이가 되어야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Layered System:&lt;/strong&gt; 아키텍처는 계층(hierarchical layers)적으로 구성이 가능해야하며, 각 레이어에 속한 구성요소는 인접하지 않은 레이어의 구성요소를 볼 수 없어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cacheable:&lt;/strong&gt; 클라이언트는 응답을 캐싱할 수 있어야 한다.
    &lt;ul&gt;
      &lt;li&gt;효율, 규모 확장성, 성능 개선&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client-Server:&lt;/strong&gt; 클라이언트-서버 스타일은 아키텍처를 단순화시키고 작은 단위로 분리(decouple)함으로써 클라이언트-서버의 각 파트가 독립적으로 개선될 수 있도록 해준다.
    &lt;ul&gt;
      &lt;li&gt;사용자 인터페이스에 대한 관심을 데이터 저장에 대한 관심으로부터 분리 (web-server - api server)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stateless:&lt;/strong&gt; 클라이언트와 서버의 통신에는 상태가 없어야 한다. 모든 요청은 필요한 모든 정보를 담고 있어야 한다.
    &lt;ul&gt;
      &lt;li&gt;상태를 저장할 필요가 없으므로 규모확장성(Scalability)가 개선된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Code-On-Demand (Optional):&lt;/strong&gt; 서버가 네트워크를 통해 클라이언트에 프로그램을 전달하면 그 프로그램이 클라이언트에서 실행될 수 있어야 한다.
    &lt;ul&gt;
      &lt;li&gt;이 제약조건은 팔수는 아니며 Javascript나 Java applet을 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;batch&quot;&gt;Batch&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;추천-시스템에서-batch-processing을-왜-사용하셨나요&quot;&gt;추천 시스템에서 Batch Processing을 왜 사용하셨나요?&lt;/h3&gt;

&lt;p&gt;Web은 실시간 처리를 중요시하기 때문에 사용자로부터 요청이 들어온 순간에 전체 수 십, 수 백만개의 업체 중 추천 대상을 산출해서 응답을 보내는 작업은 시간이 오래걸려서 적절하지 못하다고 생각했습니다. 이를 위해서 &lt;strong&gt;사용자가 요청을 보내기 전에 미리 수 많은 예약 데이터를 분석해서 추천 대상을 캐싱해놓고 싶어 Batch Processing 즉, 일괄 처리를 도입하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;batch-processing을-위해서-spring-batch를-사용하게-된-이유가-있나요&quot;&gt;Batch Processing을 위해서 Spring Batch를 사용하게 된 이유가 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Batch Processing을 위해서 Spring Batch를 사용하게 된 대표적인 이유는 Spring Batch의 기본적인 프로세스만 이해한다면 비즈니스 로직에 집중할 수 있다는 점에서 매력을 느껴 Spring Batch를 사용하였습니다.&lt;/strong&gt; 이 외에도 트랜잭션 관리, 장애 대응 전략 등 다양한 기능을 제공해 줘서 Spring Batch를 사용하였습니다. 또한 사실 Spring Framework에서 적용하고 있는 철학이나, 전략, 핵심 기술들이 익숙해서 Spring Batch를 사용했던 이유도 있긴 합니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-batch의-구조에-대해서-저희에게-간단히-설명-해주실-수-있나요&quot;&gt;Spring Batch의 구조에 대해서 저희에게 간단히 설명 해주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Batch에는 하나의 배치 작업 단위인 Job이 존재하구요, Job은 독립적이고 순차적인 단계를 의미하는 Step의 집합으로 구성되어집니다. Step은 Chunk 지향으로 데이터를 처리할 수 있는 Reader, Processor, Writer로 구성되어질 수 있고, 간단하게 하나의 execute 메서드를 실행하는 Tasklet으로도 구성되어질 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;chunk-기반의-프로세싱은-무엇인지에-대해서-알려주실-수-잇나요&quot;&gt;chunk 기반의 프로세싱은 무엇인지에 대해서 알려주실 수 잇나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Batch에서 구현하는 Chunk 지향 프로세싱은 Spring Batch 버젼 2.0부터 지원해주는 기능으로써 하나의 트랜잭션 내에서 ItemReader에 의해 한 번에 하나의 아이템을 읽어서 Chunk를 만들고 ItemProcessor에 의해 청크를 프로세싱한 후 aggreagate 시킵니다. 아이템을 읽은 횟수가 설정한 commit interval과 동일할 때 전체 청크는 ItemWriter에 의해서 write되어지고 트랜잭션은 커밋되어지는 프로세싱을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;chunk-oriented-processing과-tasklet은-각각-언제-쓰이는게-적절하나요&quot;&gt;chunk-oriented Processing과 Tasklet은 각각 언제 쓰이는게 적절하나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;chunk 지향 프로세싱은 청크 단위로 한번에 하나씩 데이터를 읽어서 처리하고 전송하는 과정이 필요한 경우에 사용하는 것이 적절할 것 같구요, Tasklet은 간단한 스크립트나 단순한 SQL 문을 호출하는 등 Job 수행에는 꼭 필요한 과정이지만 굳이 청크 기반으로 데이터를 처리할 필요가 없는 경우에 사용하는게 적절할 것 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;batch에서-어떠한-기준으로-job과-step을-나누셨죠&quot;&gt;Batch에서 어떠한 기준으로 Job과 Step을 나누셨죠?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추천 대상을 산출하기 위해 사용하는 추천 알고리즘 별로 Job을 나누었으며 랭킹을 매기기 위해 데이터를 가공할 필요가 있는 경우 랭킹 Step 이전에 데이터 프로세싱 Step들을 구성하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-batch-메타-테이블-구조에-대해서-알려주실-수-있나요&quot;&gt;Spring Batch 메타 테이블 구조에 대해서 알려주실 수 있나요?&lt;/h3&gt;

&lt;h4 id=&quot;job&quot;&gt;JOB&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_JOB_INSTANCE&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;JOB이 실행될 때 생성되는 JOB_INSTANCE에 관한 정보를 저장하고 있습니다.&lt;/strong&gt;
엄연히 말하자면 JOB_INSTANCE는 JOB이 실행될 때마다 생성되지 않고 &lt;strong&gt;JOB_PARAMETER 값에 따라 새로 생성&lt;/strong&gt;됩니다.&lt;/li&gt;
      &lt;li&gt;JOB_PARAMETER에 의해서 동일한 JOB의 여러 JOB_INSTANCE간에 구분이 이루어집니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_JOB_EXECUTION&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;JOB(JOB_INSTANCE)을 실행하기위한 단일 시도의 기술적인 개념들을 저장합니다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;EXECUTION은 실패 또는 성공으로 끝날 수 있지만, EXECUTION이 성공적으로 완료되지 않는한 해당 EXECUTION에 해당하는 JOB_INSTANCE는 완료된 것으로 간주하지 않습니다.&lt;/li&gt;
      &lt;li&gt;JOB_INSATNCE의 단일 실행을 나타내는 JOB_EXECUTE에 관한 정보를 담고 있습니다.&lt;/li&gt;
      &lt;li&gt;JOB_INSTANCE와 JOB_EXECUTION은 부모(1)와 자식(N) 관계입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_JOB_EXECUTION_PARAMS&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;JOB_PARAMETER에 대한 모든 정보를 기록하고 있습니다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_JOB_EXECUTION_CONTEXT&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;EXECUTION_CONTEXT와 관련된 모든 정보를 기록합니다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;1개의 JOB_EXECTION에 각 JOB_EXECUTION_CONTEXT가 있으며 특정 작업 실행에 필요한 모든 작업 레벨 데이터를 포함합니다.&lt;/strong&gt; 일반적으로 JOB_INSTANCE가 중지된 위치에서 다시 시작할 수 있도록, 실패(Fail)이후 지점에 State를 나타냅니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_JOB_EXECUTE_SEQ, BATCH_JOB_SEQ&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;JOB_EXECUTE와 JOB의 순서 관리 테이블입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;step&quot;&gt;Step&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_STEP_EXECUTION&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;STEP을 실행하기위한 단일 시도에 관련된 정보를 저장합니다. 각 STEP이 실행될 때마다 STEP_EXECUTION이 생성되고 저장됩니다&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;이전 STEP이 실패해서 다음 STEP의 실행 또한 실패한다면, 어떠한 STEP_EXECUTION도 persist(영속화) 되어지지 않습니다. &lt;strong&gt;STEP_EXECUTION은 실제로 해당 STEP이 시작될 때만 생성됩니다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;각각의 STEP_EXECUTION은 해당 &lt;u&gt;STEP의 참조와 관련된 커밋과 롤백 개수, 시작과 종료 시간등 트랜잭션과 관련된 데이터를 포함&lt;/u&gt;합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_STEP_EXECUTION_CONTEXT&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;STEP의 EXECUTION_CONTEXT와 관련된 모든 정보를 저장합니다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;STEP_EXECUTION 당 1개의 STEP_EXECUTION_CONTEXT가 있으며 개발자가 batch 실행에서 유지해야하는 모든 데이터(재시작을 위한 정적인 정보 또는 통계 정보)를 포함합니다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BATCH_STEP_EXECUTION_SEQ&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;STEP_EXECUTION의 시퀀스관리 테이블입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jobrepository는-무엇인가요&quot;&gt;JobRepository는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;JobRepository란 Batch의 Stereotype 인  JobExecution, StepExectuion 등을 위한 영속성 메커니즘입니다.&lt;/strong&gt; JobRepository는 JobLauncher, Job, Step 구현을 위한 CRUD 작업을 제공합니다. Job이 시작되어질 때, repository로 부터 JobExecution을 가져오고, 실행 과정에서 StepExecution과 JobExecution 구현을 repository로 전달하여 유지합니다.&lt;/p&gt;

&lt;h3 id=&quot;fault-tolerant-시스템을-위해-batch에-어떠한-장애대응-전략을-도입하셨나요&quot;&gt;Fault Tolerant 시스템을 위해 Batch에 어떠한 장애대응 전략을 도입하셨나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Batch Processing 간에 NPE나, JSONException 등이 발생했을 경우, 해당 chunk 처리를 최대 10회 skip 하는 전략인 Skip 정책을 도입했습니다. 그리고 DB lock이나, 다른 일시적인 이유에 의해서 TransientDataAccessException이나 RedisBusyException 등이 발생했을 경우 300ms의 시간을 두고 최대 3회 재시도하는 정책인 Retry 정책과 Back-off 정책을 도입하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;batch-process-scheduling을-위해서-무엇을-사용하셨나요-jenkins는&quot;&gt;Batch Process Scheduling을 위해서 무엇을 사용하셨나요? (Jenkins는?)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Batch Process 스케줄링을 위해서 BatchJobLaunchScheduler 클래스를 구현해 매일 아침 7시에 Batch Process가 동작할 수 있도록 Spring Scheduler를 사용해서 스케줄링을 구현하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-scheduler를-구현했을-경우-단점이-뭘까요&quot;&gt;&lt;strong&gt;Spring Scheduler를 구현했을 경우 단점이 뭘까요?&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;만약 배치 작업이 너무 거대해서 클러스터로 구성하여 스프링 스케줄러로 스케줄링 하였을 때, 하나의 배치 노드에서 전체 클러스터의 스케줄링 작업을 수행한다는 것이 어색하다.&lt;/strong&gt; 만약 해당 스프링 스케줄러 기능이 포함된 배치 노드가 다운되었다면 배치 실행을 안할 것인가..? 즉, 장애대응에 완벽한 구조를 가지고 있지 않다. 그나마 좀 더 완벽한 장애대응을 가지는 CI 툴의 사용을 고려해 보자.&lt;/p&gt;

&lt;h3 id=&quot;ci-툴을-scheduler로-도입했을-시-장점&quot;&gt;CI 툴을 Scheduler로 도입했을 시 장점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CI툴은 대부분 Slack이나, Email, SMS 등 다양한 Integration을 제공하고 실행 이력, 로그 관리, Dashboard등 UI가 굉장히 잘 되어 있습니다. 뿐만 아니라 REST API, Scheduling, 수동 실행 등 다양한 실행 방법을 제공하기 때문에 CI 도구를 Scheduler로 도입했을 경우 많은 장점들이 존재합니다. 다양한 플러그인 및 계정별 권한 관리도 지원해주고요&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;spring-scheduler&quot;&gt;Spring Scheduler&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;
      &lt;ul&gt;
        &lt;li&gt;스프링에서 자체적으로 지원하는 기능으로써 애플리케이션 내부에서 쉽게 구현할 수 있어 비용이 적게든다.&lt;/li&gt;
        &lt;li&gt;자바 어플리케이션을 띄우고 주기적으로 실행할 수 있으므로 스케줄된 메소드를 정시에 실행 가능하다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;
      &lt;ul&gt;
        &lt;li&gt;스케줄러 interval이 매우 짧을 경우 작업 수행시간이 interval 시간보다 길어질 상황이 생길 수 있다.
          &lt;ul&gt;
            &lt;li&gt;멀티스레딩으로 설정을 직접 커스터마이ㅈ징 가능&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;interval 시간보다 긴 작업이 존재한다면 다른 작업들도 제 시간에 실행되지 않는 문제가 발생할 수 있다.
          &lt;ul&gt;
            &lt;li&gt;비동기 애노테이션(@Async)로 아직 작업이 끝나지 않았더라도, 새로운 스레드를 할당해 작업을 수행할 수 있다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;멀티 서버일 경우 스케줄러가 중복 실행되는 문제
          &lt;ul&gt;
            &lt;li&gt;ShedLock 잠금으로 해결 가능
              &lt;ul&gt;
                &lt;li&gt;ShedLock은 스케줄링된 task가 최대 동시에 한번만 실행가능하도록 만들어진 라이브러리입니다.&lt;/li&gt;
                &lt;li&gt;만약 테스크가 하나의 노드에서 실행되는 경우, 다른 노드로부터 같은 테스크의 실행을 막기위해 잠금을 획득합니다. &lt;strong&gt;즉, 하나의 작업이 이미 한 노드에서 실행중인 경우 다른 노드에서의 실행은 대기하지 않고 단순히 건너 뜁니다.&lt;/strong&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;front-end-업데이트-예정&quot;&gt;Front-End (업데이트 예정)&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;리액트를-사용한-이유는-무엇인가요&quot;&gt;리액트를 사용한 이유는 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;리액트를 사용해서 UI를 확장성 및 재사용성이 높은 컴포넌트의 집합으로 개발하기 위해 사용하였습니다.&lt;/strong&gt; 또한 리액트에서 사용할 수 있는 스타일 라이브러리나 상태 관리 라이브러리를 사용하고 싶어서 리액트를 사용하기도 하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;프론트를-개발하면서-어려운-점은-없으셨나요&quot;&gt;프론트를 개발하면서 어려운 점은 없으셨나요?&lt;/h3&gt;

&lt;p&gt;백앤드 개발에 집중하다 보니 프로젝트 막바지에 프론트앤드 개발에 투자할 시간이 상대적으로 많이 없었는데요, 이러한 상황에서 리액트도 처음 사용하다보니 리액트에서 제공해주는 기능 하나 하나를 완벽히 이해하고 가져다 쓰기에는 어려운 점이 많았습니다.일단 프론트 앤드는 이상 없이 요구사항 전부를 구현 했으나, 리액트의 장점과 특징들을 제대로 활용하지 못하고 그냥 가져다 사용한 것만 같아서 생산성과 유지 보수성이 높은 코드를 작성하는게 가장 어려웠습니다.&lt;/p&gt;

&lt;h3 id=&quot;리액트의-대표적인-특징은-무엇인가요&quot;&gt;리액트의 대표적인 특징은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;리액트의 대표적인 특징으로는 UI를 상태를 가지는 간단한 컴포넌트의 집합으로 표현할 수 있고, Virtual DOM을 사용하여 변화가 필요한 곳만 렌더링 할 수 있다는 특징을 가지고 있습니다.&lt;/strong&gt; 또한 리액트는 엄청나게 큰 생태계를 가지고 있어 다양한 기능들이 새로 추가되고 유지보수 되고 있으며 이를 통해 개발자들이 좀 더 쉽게 UI를 개발할 수 있게 해줍니다.&lt;/p&gt;

</description>
        <pubDate>Wed, 24 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2021/02/24/NAVER-Practical-Interview-Preparation-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2021/02/24/NAVER-Practical-Interview-Preparation-1.html</guid>
        
        <category>Booking-Recommendation-System</category>
        
        <category>Batch</category>
        
        <category>PostgreSQL</category>
        
        <category>Spring</category>
        
        <category>Redis</category>
        
        <category>React</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 9일차] Pinpoint &amp; Webper Projects</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;pinpoint&quot;&gt;Pinpoint&lt;/h1&gt;

&lt;h3 id=&quot;핀포인트에-어떤-기여를-하셨죠&quot;&gt;핀포인트에 어떤 기여를 하셨죠?&lt;/h3&gt;

&lt;p&gt;저는 &lt;strong&gt;Pinpoint Batch 모듈에 Webhook 기능을 개발하면서 Metric 별로 수집되는 서로 다른 값의 형식을 추상화할 수 있는 DTO 구조를 설계했고 관련 Alarm 도메인 구조를 재설계 하였습니다. 또한 Webhook Json Data Spec을 정의하고 Pinpoint webhook Receiver 예제 프로젝트를 개발하였습니다&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;현재에도-진행중이신가요&quot;&gt;현재에도 진행중이신가요??&lt;/h3&gt;

&lt;p&gt;네 그렇습니다. 원래 계획대로라면 이미 끝났어야만 하는데 사실 &lt;strong&gt;Batch가 Pinpoint Web 모듈 내에서 독립된 모듈로 분리되면서 머지가 늦은 것 같습니다.&lt;/strong&gt; 웹 모듈 내의 배치에서는 웹훅 기능이 정상동작하는 것을 테스트 했으며, 현재 독립된 batch 모듈로 webhook 기능을 옮기는 작업을 진행하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;얼마-정도-후에-머지가-될-예정인가요&quot;&gt;얼마 정도 후에 머지가 될 예정인가요??&lt;/h3&gt;

&lt;p&gt;팀원 분들이 같이 힘을 합치면 2~3일 안에도 끝낼 수 있습니다. 하지만 두 분다 직장도 계시고 네이버 경력 공채에 참여중이시기 때문에 시간 맞추기도 어려웠고, 저도 현재 예약 플랫폼 채용 과정에 참여중이라서 &lt;strong&gt;이번 년도 안에 마스터에 머지하는게 저희 목표&lt;/strong&gt;입니다. 핀포인트 팀과도 이미 이야기 나누었구요!!&lt;/p&gt;

&lt;h3 id=&quot;핀포인트를-개발하시면서-어려움이-있으셨나요&quot;&gt;핀포인트를 개발하시면서 어려움이 있으셨나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;여러가지 어려움 중 한가지는 Checker에서 검색하는 Metrics 들의 타입이 너무 다르다는 것이었습니다.&lt;/strong&gt; Checker의 구현체에 따라서 Metric 값의 타입은 Integer, Integer 타입의 Array, 특정 객체 타입의 Array 등 다양한 타입이 존재했습니다. 기존 SMS와 Email을 통해서 알람을 보낼 때는 수집된 값의 형식이 달라도 전송하기전에 Message Template을 통해서 특정 텍스트 형식을 만들어 보내면 됐었지만, Webhook 기능은 Pinpoint와 다른 어플리케이션 간에 확장성 제공이 목적이었기 때문에 Metric 별로 특정 텍스트 형식을 만들어 보내기에는 사용자의 입장에서 자유도가 떨어지고 필요시 다시 문자열 처리를 해야만하는 부담을 주는 상황이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;문제를 해결하기 위해 Metric 별로 수집된 값의 서로 다른 타입을 모두 추상화할 수 있는 DTO 구조를 설계 및 구현했고, 수집된 Metric 값의 형식에 기반하여 도메인 구조를 재설계 및 구현함으로써 문제를 해결할 수 있었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;!-- ### 프로젝트 환경 구성에서 가장 어려웠던 점

**가장 어려웠던 점은 핀포인트 개발환경을 구성하는 것이 가장 어려웠습니다.**

처음에 저는 제가 개발할 모듈만 로컬에서 띄우고 나머지 모듈인 hbase, collector 등은 도커에서 컨테이너로 띄우는 방식으로 이번 핀포인트 웹훅 프로젝트를 진행하려고 했습니다. 하지만 로컬에서 띄운 모듈은 hbase 컨테이너와 통신하지 못했습니다. docker-compose도 바꿔보고, 모듈을 다 컨테이너로 올려서 돌려도 보고 (이건 특이하게 되더라구요), 포트 맵핑도 다시 해보고 여러 방법을 써보았습니다. 하지만 핀포인트와 도커 관련한 지식이 부족해서 멘토님께 이 현상에 대해서 말씀 드렸고, 멘토님 또한 아주 중요한 문제라면서 이슈에 올리시구 개발하셨습니다.

거의 1주일이 넘는 시간을 이 이슈를 해결하기 위해서 약간 이슈에 대한 집착 때문에 달려들었던 것 같습니다.

### 해결 하셨나요?

해결이 된다면 말씀을 해주신다고 하셨는데 아직 관련 이슈가 closed 되지 않았고, 다른 멘티분이 관련해서 올리신 PR이 머지되지 않은것을 봐서는 현재 해결이 안된 것 같습니다.

하지만 대략의 원인을 멘토님께 직접 들었을 때 로컬의 web 모듈은 컨테이너의 zookeeper를 바라보는데 이 zookeeper는 도커 hbase의 위치 정보가 없어서 connection이 안됬던 것이고, 컨테이너의 web 모듈은 hbase의 embedded된 zookeeper로 정상 접속하기 때문에 컨테이너의 web 모듈은 돌아가고 로컬의 web 모듈은 돌아가지 않는 것이었습니다. --&gt;

&lt;h3 id=&quot;핀포인트를-개발하시면-가장-좋았던-점은-무엇인가요&quot;&gt;핀포인트를 개발하시면 가장 좋았던 점은 무엇인가요??&lt;/h3&gt;

&lt;p&gt;좋았던 점은 사실 너무 많았습니다 거의 대부분이라고 해도 될정도로요!! 모니터링 도메인에서 객체지향이 어떻게 적용되고 있는지도 배울 수 있었고, 같은 멘티들이 다들 경력직 개발자여서 코드리뷰를 통해 “이분들은 코드를 이렇게 짜는구나”, “그러면 이런 장점과 단점이 존재하구나”, “내가 코드를 작성하는 방식을 이렇게 한번 바꿔보면 어떨까?” 에 대해서도 많이 느끼고 배울 수 있었던 기회였던 것 같구요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가장 좋았던 점은 제 코드에 대해서 질문할 수 있는 능력을 키운것이 가장 좋았던 것 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예전에는 제가 코드를 작성함에 있어서 코드에 대해서 질문을 던진 적이 별로 없었습니다. 확장성이나 유지보수성이 어떻게 되든 버그가 없고 잘 돌아가기만 하면 만족했었습니다. 하지만 이번 기회를 통해서 “유지보수성이 좋은 코드란 무엇이고?”, “확장성이 좋은 코드란 무엇인가?” 에 대해서 깊게 생각해 볼 수 있었고 작성된 코드에 대해서 “왜 이건 이렇게 해야만하고?”, “다른 방법을 택하면 왜 안되지?”, “이 방법에 장점은 뭐고 단점은 뭘까?”, “이 사람은 어떤 의도로 이런 코드를 작성했을까?” 등의 질문들을 이제는 자연스럽게 제 자신에게 던질 수 있는 능력을 키운것이 가장 좋았습니다.&lt;/p&gt;

&lt;h3 id=&quot;batch-란-무엇인가요&quot;&gt;Batch 란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Batch란 데이터를 실시간으로 처리하는것이 아닌 일괄처리하는 것을 의미합니다.&lt;/strong&gt; (ex. 정산, 알람 등의 어플리케이션을 구현하기 위해서 사용될 수 있습니다.)&lt;/p&gt;

&lt;h3 id=&quot;pinpoint-batch-구조에-대해서-설명해주실-수-있나요&quot;&gt;Pinpoint Batch 구조에 대해서 설명해주실 수 있나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;JobLauncher에 의해서 정해진 시간마다 AlarmJob이 실행되는데 AlarmJob은 하나의 AlarmStep을 가지고 있고, Alarm Step은 AlarmReader, AlarmProcessor, AlarmWriter로 구성되어 있습니다.&lt;/strong&gt; AlarmReader는 HBase에서 어플리케이션의 Metrics를 가져오고, AlarmProcessor는 이 Metric들이 Threshold가 넘는지 확인하고, AlarmWriter는 Threshold가 넘는 Metric값과 관련 어플리케이션 정보를 User에게 email, sms, webhook 등을 이용해 전송하는 구조를 가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;hbase에-대해서-알고-계시나요&quot;&gt;HBase에 대해서 알고 계시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HBase는 컬럼 기반의 NoSQL 분산형 데이터 베이스&lt;/strong&gt;라고 입니다. &lt;u&gt;스키마, 조인, 인덱스가 없고 대량 데이터에 대해 강력한 연산과 일관성을 제공&lt;/u&gt;하는 것으로 알고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;분산형-데이터-베이스란-무엇인가요&quot;&gt;분산형 데이터 베이스란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;분산형 데이터 베이스란 데이터를 분산해서 저장하고 관리해 높은 신뢰성과 성능을 구현하는데 효과적인 데이터 베이스를 분산형 데이터베이스&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;스키마-변경에-따른-하위-호환-기능-구현은-어떻게-하셨나요&quot;&gt;스키마 변경에 따른 하위 호환 기능 구현은 어떻게 하셨나요?&lt;/h3&gt;

&lt;p&gt;webhook 기능을 개발하며 DB 테이블에 컬럼이 하나 추가될 필요가 있었습니다. 컬럼이 추가되지 않으면 webhook 기능을 사용하지 못하기 때문에 기능을 사용하기 위해서는 사용자가 직접 DB에 들어가 컬럼을 추가하는 쿼리문을 실행해야만 했었습니다.&lt;/p&gt;

&lt;p&gt;하지만 웹훅 기능을 사용하지 않지만 다른 기능 때문에 최근 release를 다운로드 받은 기존 사용자에게 “DB에 들어가서 column을 추가해 그렇지 않으면 알람 기능 자체를 사용 못할거야!” 라고 말하는 것은 적절하지 않다고 생각했기 때문에 웹훅을 사용하지 않을 기존 사용자를 위해서 하위 호환 기능을 구현할 필요가 있었습니다.&lt;/p&gt;

&lt;p&gt;하위 호환을 위해 webhook.enable이라는 property를 통해 웹훅 기능을 사용하는 유저와 사용하지 않는 유저를 구분했습니다. 즉, webhook.enable이 true라고 설정되어 있다면 컬럼이 추가된 쿼리문이 날라가고 webhook이 동작하며, false라고 설정되어 있다면 컬럼이 추가되지 않은 쿼리문이 날라가고 webhook을 비활성화 하면서 하위 호환을 유지할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이를 통해 평소에 전혀 경험해보지 못햇던 데이터베이스 하위 호환을 경험할 수 있어서 즐거운 경험이었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;webper&quot;&gt;webper&lt;/h1&gt;

&lt;h3 id=&quot;spring-security란-무엇인가요&quot;&gt;Spring Security란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Security란 인증과, 권한부여, 일반적인 공격에 대한 보호의 기능을 제공하는 프레임워크입니다.&lt;/strong&gt; Spring Security를 사용하면 어플리케이션의 보안 관련 기능을 자체적으로 구현 할 필요 없이 쉽고 안전하게 구현할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-spring-security를-사용하게-되었나요&quot;&gt;왜 Spring Security를 사용하게 되었나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;공식문서에서 인증과, 권한 부여, 일반적인 공격에 대한 보호의 기능을 제공하는 프레임워크라고 나와있었고 Spring Security를 사용하면 보안 관련 기능을 자체적으로 구현할 필요 없이 쉽고 안전하게 구현할 수 있다고 나와 있길레 사용했습니다. 하지만 사용해보니 전혀 쉽지 않았고 저는 단지 토큰 기반의 인증 기능을 구현하고 싶었을 뿐이지, Servlet이 맵핑되기 전에 Filter기반의 인증과정이 처리되어야 할 필요가 없었지만 토이프로젝트이기도해서 한번 도전해보자, 많이 배워보자 라는 마음으로 시작하였습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;무엇이-가장-어려웠나요&quot;&gt;무엇이 가장 어려웠나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;처음에 Spring Security 구조를 잡는 것이 가장 어려웠습니다.&lt;/strong&gt; Filter, Security Filter 개념도 매우 어려웠고 Servlet, Servlet Container, IoC Container의 개념도 잘 정립이 되어 있지 않은 상태였기 관련 문서도 잘 읽히지 않았지만 계속 하나하나 깊이있게 파다 보니까 구조를 알 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;filter와-security-filter의-차이를-말씀해-주실-수-있나요&quot;&gt;Filter와 Security Filter의 차이를 말씀해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Filter와 Security Filter는 서블릿 컨테이너에 의해 Servlet에 요청이 맵핑되기 전에 실행되는 필터입니다. 둘다 똑같은 필터인데 그냥 Filter는 서블릿 컨테이너에 등록되서 사용되는 필터이고 Security Filter는 DelegatingFilterProxy가 서블릿 컨테이너에 Filter로 등록되어서 ApplicationContext가 관리하는 Filter이자 Bean들인 Security Filter Chain으로 필터 작업을 위임하는 형태입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;즉, 쉽게 말해서 Filter와 Security Filter는 모두 서블릿에 요청이 맵핑되기 전에 실행되는 필터인데 이를 서블릿 컨테이너에 직접 등록하느냐, ApplicationContext에 Bean으로 등록해서 사용하느냐의 차이입니다.&lt;/p&gt;

&lt;h3 id=&quot;filter와-interceptor의-차이를-말씀해-주실-수-있나요&quot;&gt;Filter와 Interceptor의 차이를 말씀해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Filter는 Spring Context 외부에 존재하여 Servlet에 요청이 맵핑되기 전에 다양한 작업들을 하는 것을 의미하구요, Interceptor는 Spring Context 내부에 존재하여 DispatcherServlet이 컨트롤러를 호출하기 전, 후에 요청과 응답에 대해 처리 하는 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;종진님이-구현하신-spring-security의-인증방식-아키텍처를-알-수-있을까요&quot;&gt;종진님이 구현하신 Spring Security의 인증방식 아키텍처를 알 수 있을까요?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;처음에 Servlet Container를 통해서 요청이 들어오고 Filter Chain을 수행합니다.&lt;/li&gt;
  &lt;li&gt;Filter Chain 중에서 DelegatingFilterProxy 필터를 만나면 이는 FilterChainProxy에게 요청을 위임하고 이는 Security Filter Chain을 실행시킵니다.&lt;/li&gt;
  &lt;li&gt;다양한 Security FilterChain이 존재하지만 인증을 수행하는 필터인 AuthenticationFilter를 거치게 되고 이 객체를 통해 전체적인 인증 과정이 수행됩니다.&lt;/li&gt;
  &lt;li&gt;정상적으로 인증 과정이 수행이 되었다면 AuthenticationFilter는 SecurityContext에 인증 객체를 저장하게 됩니다.&lt;/li&gt;
  &lt;li&gt;AuthenticationFilter의 임무가 끝났음으로 다음 Security Filter Chain이 시작됩니다.&lt;/li&gt;
  &lt;li&gt;Security Filter Chain이 다 끝나고 Filter Chain도 다 끝나면 이제 DispatcherServlet으로 요청이 맵핑되어서 관련 로직들이 실행됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;저는 여기서 AuthenticationFilter로서 JWTAuthenticationFilter를 만들었으며 Security Filter Chain에 등록하였습니다. 여기서 JWT 토큰을 분석하여 DB에 있는 데이터와 동일한지에 대해서 살펴 보았고 동일 하다면 SecurityContext에 관련 인증 객체를 저장하였습니다.&lt;/p&gt;

&lt;p&gt;SecurityContext는 default로 ThreadLocalSecurityContextHolderStrategy를 사용하여 인증 객체를 저장하기 때문에 서블릿당 하나의 인증 객체가 저장됨을 알 수 있었습니다. 추후에 Controller에서 이러한 인증 객체를 가져와서 직접 관련 비즈니스 로직들을 사용자에 맞게 태웠습니다.&lt;/p&gt;

&lt;h3 id=&quot;orm-이란-무엇인가요&quot;&gt;ORM 이란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ORM이란 Object-Relational Mapping의 줄임말로써 클래스와 SQL 데이터베이스 스키마의 메타데이터를 사용하여 DB와 통신시 객체와 SQL 테이블간에 자동으로 맵핑해주는 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체 모델과 관계형 모델간의 패러다임 불일치가 존재하는데 객체간의 관계를 바탕으로 SQL을 자동 생성하여 불일치를 해결하는 것이기도 하다.&lt;/p&gt;

&lt;h3 id=&quot;orm을-왜-사용하셨나요&quot;&gt;ORM을 왜 사용하셨나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;반복되는 쿼리문을 없앤 더 직관적이고 객체지향적인 코드를 작성하고 싶어서 사용했습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;orm이-모든것을-해결해-주나요&quot;&gt;ORM이 모든것을 해결해 주나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ORM을 사용하는 것은 매우 편리하지만, 이러한 편리함 때문에 내부 구조를 잘 모르고 사용하면 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있습니다.&lt;/strong&gt; 또한 일부 자주 사용되는 대형 SQL 문은 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL을 사용할 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;orm을-사용하면-완벽하게-쿼리문이-없어지나요&quot;&gt;ORM을 사용하면 완벽하게 쿼리문이 없어지나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Data JPA에서 지원해 주지 않는 연산이거나, 성능이 너무 안좋은 쿼리문이 발생할 시 엔티티들을 재설계 하거나 직접 쿼리문을 작성&lt;/strong&gt;하는 경우도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;orm-jpa-spring-data-jpa의-차이점에-대해서-알려주세요&quot;&gt;ORM, JPA, Spring Data JPA의 차이점에 대해서 알려주세요&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ORM은 클래스와 SQL 데이터베이스 스키마의 메타데이터를 사용하여 어플리케이션이 DB와 통신시 객체와 SQL 테이블간에 자동으로 맵핑&lt;/strong&gt;해주는 것을 의미하구요&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JPA는 자바단에서 ORM을 위한 명세&lt;/strong&gt;를 의미하구요&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Data JPA는 Spring에서 JPA를 편리하게 사용하기 위해 이를 한번 레파지토리 인터페이스 기반으로 추상화 시킨 명세&lt;/strong&gt;를 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hibernate는-무엇인가요&quot;&gt;Hibernate는 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Hibernate는 자바단의 ORM 표준 명세인 JPA의 구현체 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;엔티티-설정간에-어떠한-제약을-넣을-수-있나요&quot;&gt;엔티티 설정간에 어떠한 제약을 넣을 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Primary Key 맵핑, 엔티티 간의 관계 설정, nullable, length등의 제약&lt;/strong&gt;을 넣을 수 있는 걸로 알고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;jpa에서-객체의-상태는-어떤게-있나요&quot;&gt;JPA에서 객체의 상태는 어떤게 있나요?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Transient&lt;/strong&gt; : JPA가 모르는 상태&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Persistent&lt;/strong&gt; : JPA가 관리중인 상태
    &lt;ul&gt;
      &lt;li&gt;1차 캐시 : Persistent Context에 인스턴스 저장&lt;/li&gt;
      &lt;li&gt;Dirty Checking : Persistent Context에 올라간 객체의 변경사항을 계속 감지&lt;/li&gt;
      &lt;li&gt;Write Behind : 객체의 상태변화를 DB에 최대한 늦게 필요한 시점에 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Detached&lt;/strong&gt; : JPA가 더이상 관리하지 않는 상태&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Removed&lt;/strong&gt; : JPA가 관리하긴 하지만 삭제하기로 한 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;entity-관계를-어떻게-가져올-것인가&quot;&gt;Entity 관계를 어떻게 가져올 것인가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Eager&lt;/strong&gt; : 지금 관련있는 엔티티를 전부다 가져온다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lazy&lt;/strong&gt; : 나중에 관련있는 엔티티를 가져온다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 17 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/17/NAVER-Interview-Preparation-9.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/17/NAVER-Interview-Preparation-9.html</guid>
        
        <category>Pinpoint</category>
        
        <category>Webper</category>
        
        <category>Projects</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 8일차] 네트워크</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;네트워크&quot;&gt;네트워크&lt;/h1&gt;

&lt;h3 id=&quot;쿠키와-세션이-등장하게-된-이유를-아시나요&quot;&gt;쿠키와 세션이 등장하게 된 이유를 아시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HTTP는 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징인 connectionless와 통신이 끝나면 상태를 유지하지 않는 특징인 stateless를 해결하기 위해서 쿠키와 세션이 등장하게 되었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿠키는-무엇인가요&quot;&gt;쿠키는 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;쿠키란 클라이언트의 로컬에 저장되는 키-값이 들어있는 작은 데이터 파일을 의미합니다.&lt;/strong&gt; 쿠키에는 유효 시간을 지정할 수 있으며, 쿠키의 유효 시간이 남을 경우 브라우저가 종료되도 스토리지에 남아있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;쿠키 동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트가 페이지를 요청&lt;/li&gt;
  &lt;li&gt;서버에서 쿠키를 생성&lt;/li&gt;
  &lt;li&gt;HTTP 헤더에 쿠키를 포함 시켜 응답 (Set-Cookie)&lt;/li&gt;
  &lt;li&gt;브라우저에서 쿠키를 저장&lt;/li&gt;
  &lt;li&gt;쿠키가 존재하면 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보내서 요청 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;팝업, 자동 로그인, 장바구니 등의 기능을 구현할 때 쿠키를 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;세션이란-무엇인가요&quot;&gt;세션이란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;세션은 인증과정에서 보통 쿠키를 기반으로 하고 있지만, &lt;strong&gt;클라이언트의 상태 정보를 서버 메모리에 저장하는 기술을 의미합니다.&lt;/strong&gt; &lt;u&gt;서버 메모리에서 관리하기 때문에 사용자 수가 많을 경우 성능 저하의 요인&lt;/u&gt;이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세션 동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트가 서버에 접속 시 세션 ID를 발급&lt;/li&gt;
  &lt;li&gt;클라이언트는 세션 ID를 쿠키를 사용해 저장 (쿠키 이름 : JSESSIONID)&lt;/li&gt;
  &lt;li&gt;클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해서 세션 ID값을 서버에 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;세션과-쿠키의-차이는-무엇인가요&quot;&gt;세션과 쿠키의 차이는 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;세션과 쿠키의 가장 큰 차이는 사용자의 상태 정보가 어디에 저장되어 있느냐의 차이 입니다.&lt;/strong&gt; 쿠키는 클라이언트 로컬에 저장되고 세션은 서버 메모리에서 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;세션-쿠키-방식의-장단점은-무엇인가요&quot;&gt;세션 쿠키 방식의 장단점은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;세션 ID는 유의미한 값을 갖지 않기 때문에 HTTP 헤더나 바디에 직접 계정정보를 담아 전송하는 것 보다 보안에 강하다.&lt;/li&gt;
  &lt;li&gt;세션 ID는 고유의 ID값이기 때문에 서버 메모리에서 바로 검색할 수 있어 성능 향상을 기대할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가로챈 쿠키 즉, 세션 ID를 가지고 해커가 동일한 요청을 보낼 경우 진짜 사용자 인지 해커인지 구분할 수가 없다. (세션 유효시간을 짧게 설정, HTTPS 프로토콜 사용)&lt;/li&gt;
  &lt;li&gt;세션 저장소는 서버의 메모리를 사용하기 때문에 동시 사용자가 많을 수록 서버의 부하가 심하게 걸린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;토큰-기반-인증-방식은-무엇인가요&quot;&gt;토큰 기반 인증 방식은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;인증에 필요한 정보들을 암호화시킨 토큰을 통해서 인증을 하는 방식&lt;/strong&gt;을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;토큰 인증 동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트가 로그인 한다.&lt;/li&gt;
  &lt;li&gt;서버는 사용자를 확인하고 Access Token을 발급해 사용자에게 응답해준다.&lt;/li&gt;
  &lt;li&gt;사용자는 Access Token을 받아 쿠키와 같은 곳에 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.&lt;/li&gt;
  &lt;li&gt;서버는 해당 토큰을 검증하고 적절한 토큰일 경우 사용자에 알맞는 데이터를 보낸다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;토큰-기반-인증-방식의-장단점은-무엇인가요&quot;&gt;토큰 기반 인증 방식의 장단점은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;세션/쿠키와 달리 토큰은 별도의 저장소 관리가 필요 없고 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다.&lt;/li&gt;
  &lt;li&gt;Facebook이나 Google에서 지원해주는 다양한 서비스도 토큰 기반으로 진행되기 때문에 관련 기능을 확장하기 용이합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;토큰의 경우도 세션 ID와 마찬가지로 탈취되었을 경우 진짜 사용자인지 해커인지 구분할 수 없습니다. (HTTPS 프토콜을 사용, 토큰 유효기간을 짧게 한다.(Refresh Token 사용))&lt;/li&gt;
  &lt;li&gt;토큰의 길이는 세션 ID보다 훨씬 길기 떄문에 많은 요청이 발생할 수록 오버헤드도 많이 발생합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;jwt는-무엇인가요&quot;&gt;JWT는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;JWT란 Json Web Token의 줄임말로써 Json 포맷을 통해 사용자에 대한 속성을 저장하는 Web Token이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/interview/naver-interview-preparation8-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JWT의 구조는 &lt;strong&gt;Header, Payload, Signature&lt;/strong&gt;의 3부분으로 이루어 지며 각각의 역할을 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header: Signature를 해싱하기 위한 알고리즘이나 토큰의 타입을 지정하는 부분&lt;/li&gt;
  &lt;li&gt;Payload: 토큰에서 사용할 정보의 조각들인 Claim으로 구성되어 있다.
    &lt;ul&gt;
      &lt;li&gt;Payload에 담는 정보의 ‘한 조각’을 Claim이라고 부르고, 이는 key/value의 한 쌍으로 이루어져 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Signature: 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jwt를-사용하신-이유가-있나요&quot;&gt;JWT를 사용하신 이유가 있나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;토큰 기반 인증을 위해 토큰 생성이 가장 간단하면서도 만료 기간과 같은 다양한 기능 명세가 존재했기 때문에 사용하였습니다.&lt;/strong&gt; 또한 자바 단에 JWT Token을 생성하고 검증할 수 있는 라이브러리가 잘 형성 되어있었기 때문에 사용하기도 하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;jwt의-단점은-무엇인가요&quot;&gt;JWT의 단점은 무엇인가요??&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;JWT 토큰은 상태 정보를 저장하지 않아 한번 발행된 토큰이 임의로 삭제될 수 없기 때문에 적절한 토큰 만료 기간을 넣어줘야 했습니다.&lt;/li&gt;
  &lt;li&gt;JWT 토큰은 전체적으로 길이가 길기 때문에 많은 요청과 응답이 발생할 경우 성능에 영향을 줄 수 있습니다.&lt;/li&gt;
  &lt;li&gt;JWT의 Payload 자체는 암호화 된 것이 아니라 인코딩 된 것이기 때문에 암호화에 신경 쓰거나, 중요 데이터를 Payload에 넣지 않아야 합니다.&lt;/li&gt;
  &lt;li&gt;Token 기반의 인증과 마찬가지로 Token을 탈취 당했을 경우 올바른 사용자 식별을 할 수 없습니다. 이를 위해 HTTPS나 적절한 만료 기간을 설정했어야만 했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;oauth&quot;&gt;OAuth&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;OAuth란 특정 애플리케이션이 다른 애플리케이션의 정보에 접근할 수 있는 권한을 관리하는 프로토콜 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;osi-7-레이어는-무엇인가&quot;&gt;OSI 7 레이어는 무엇인가??&lt;/h3&gt;

&lt;p&gt;OSI 7 레이어란 네트워크를 계층적인 구조로 표현한 것을 가리키며 구조는 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;물리 계층(Physical Layer)&lt;/strong&gt; : 하나의 비트를 노드에서 다음 노드로 전송해주는 서비스를 담당한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;링크 계층(Link Layer)&lt;/strong&gt; : 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 서비스를 담당한다. (MAC)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;네트워크 계층(Network Layer)&lt;/strong&gt; : 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 라우팅과 포워딩 서비스를 담당한다. (IP)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 계층(Transport Layer)&lt;/strong&gt; : End to End 사용자들이 신뢰성있는 데이터를 주고받을 수 있게 도와준다. (TCP, UDP)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;세션 계층(Session Layer)&lt;/strong&gt; : 양 끝단의 응용 프로세스가 통신(동시 송수신, 반이중, 전이중)을 관리하기 위한 방법을 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표현 계층(Presentation Layer)&lt;/strong&gt; : 코드 간의 번역을 담당하여 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;응용 계층(Application Layer)&lt;/strong&gt; : 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. (HTTP, DNS, SSH)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;왜-osi-7-레이어로-나누었을까&quot;&gt;왜 OSI 7 레이어로 나누었을까??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;네트워크를 7계층으로 나눈 이유는 네트워크에서 이상이 발생했을 경우 다른 레이어의 장비 및 소프트웨어를 건들지 않고도 이상이 생긴 특정 레어어만 고칠 수 있는 유지보수 측면에서의 장점과, 새로운 응용 계층 프로토콜을 개발할 경우 물리계층 부터 개발하지 않고 표현계층까지 재사용함으로써 확장성 측면에서의 장점을 가지기 때문에 네트워크를 계층적 구조인 OSI 7 레이어로 나누었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;http는-무엇인가&quot;&gt;HTTP는 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HTTP는 어플리케이션 계층 프로토콜의 한 종류로써 TCP/IP 기반의 신뢰적인 프로토콜입니다. 주로 브라우저와 서버간의 통신을 하기 위해 자주 사용합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;헤더 필드로는 Content-Legth, Content-Type, Connection, User-Agent, Accept, Status Code 등이 존재합니다.&lt;/p&gt;

&lt;p&gt;http status code는 HTTP Response의 필드 중에 하나인데 순서는 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1xx: 서버는 요청을 받았으며 작업을 계속한다.&lt;/li&gt;
  &lt;li&gt;2xx: 클라이언트가 요청한 동작을 수신하고 이해했으며 성공적으로 처리했음을 가리킨다.&lt;/li&gt;
  &lt;li&gt;3xx: 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다는 것을 의미하구요&lt;/li&gt;
  &lt;li&gt;4xx: 클라이언트의 요청에 오류가 있다는 것을 말합니다.&lt;/li&gt;
  &lt;li&gt;5xx: 클라이언트 요청은 이상이 없지만 이를 처리하는 서버에 문제가 있다는 것을 말합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dns-서비스는-무엇인가&quot;&gt;DNS 서비스는 무엇인가??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;DNS란 Host의 Domain Name을 Host의 IP로 변환해주는 서비스를 말합니다.&lt;/strong&gt; DNS 서버들은 계층구조로 구현된 분산 데이터베이스로 주요 구성 요소로써 Root, Top Level Domain(TLD), Authoritative, Local DNS Server가 존재합니다.&lt;/p&gt;

&lt;p&gt;DNS 서비스 과정 (캐싱 x)&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Host가 gaia.cs.umass.edu의 IP주소를 Local DNS서버에게 요청을 보낸다.&lt;/li&gt;
  &lt;li&gt;Local DNS서버는 루트 DNS 서버에게 Domain Name을 보내고 루트 DNS 서버는 edu를 인식한 후 TLD 서버의 주소를 넘겨준다&lt;/li&gt;
  &lt;li&gt;Local DNS서버는 TLD서버에게 Domain Name을 보내고 TLD 서버는 unmass.edu를 인식한 후 Authoritative 서버의 주소를 넘겨준다.&lt;/li&gt;
  &lt;li&gt;Local DNS서버는 Authoritative 서버에게 Domain Name을 보내고 gaia.cs.umass.edu에 해당하는 Ip주소를 얻어온다.&lt;/li&gt;
  &lt;li&gt;변환된 Ip 주소를 Host에게 넘겨주고 Host는 이 IP를 사용해서 어플리케이션 간에 통신 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tcp와-udp의-차이는-무엇인가&quot;&gt;TCP와 UDP의 차이는 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;UDP는 비신뢰적이고 비연결형 서비스를 제공하는 프로토콜이구요 TCP는 신뢰적이고 연결형 서비스를 제공하는 프로토콜 입니다.&lt;/strong&gt; UDP는 주로 DNS나, IPTV등에서 사용하고 TCP는 HTTP 등에서 사용됩니다.&lt;/p&gt;

&lt;h3 id=&quot;tcp의-3-way-handshake에-대해서-알고-잇나요&quot;&gt;TCP의 3 Way-HandShake에 대해서 알고 잇나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TCP의 3 Way Handshake란 TCP로 통신을 하는 장치간에 서로 연결이 잘 되어있는지 확인하는 과정, 방법이다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;synchronize의 줄임말인 syn 세그먼트를 클라이언트가 서버로 보낸다.&lt;/li&gt;
  &lt;li&gt;서버는 클라이언트에게 syn에 대한 ack를 보낸다&lt;/li&gt;
  &lt;li&gt;클라이언트는 syn에 대한 ack의 ack를 보낸다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 16 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/16/NAVER-Interview-Preparation-8.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/16/NAVER-Interview-Preparation-8.html</guid>
        
        <category>Introduction</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 7일차] 자기소개 &amp; 동아리 회장 및 해커톤 활동</title>
        <description>&lt;h1 id=&quot;자기소개&quot;&gt;자기소개&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;안녕하세요 “깊은 생각과 고민을 통해 공유하는 것을 좋아하는” 서버 개발자 배종진입니다. 저는 객체지향과 자바를 가장 좋아하고 잘 다룰 수 있으며 관련 프로젝트 경험으로는 Pinpoint batch 모듈에 webhook 기능을 개발한 경험과 Spring Boot 기반의 api 서버를 개발해본 경험이 있습니다. 이 외에도 다양한 프로젝트 및 스터디를 통해서 코드의 품질에 대해서도 항상 고민하고 있으며 더 나은 코드를 위해 토론하는 과정 자체를 좋아합니다. 전남대학교 소프트웨어 개발 동아리 회장과 교내 최초 온라인 해커톤 운영을 통해 전남대학교 개발 생태계에 이바지한 경험이 있으며 주어진 환경에서 최선의 변화를 항상 시도하고 즐겨하는 편입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;저의 이러한 역량을 바탕으로 네이버 예약&amp;amp;주문 플랫폼 팀에 입사하여 최고의 글로벌 예약&amp;amp;주문 서비스 플랫폼을 만들고 싶습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;좋은-품질의-코드&quot;&gt;좋은 품질의 코드&lt;/h1&gt;

&lt;h3 id=&quot;좋은-품질의-코드에-대해서-말씀-하셨는데-종진님이-생각하시는-좋은-품질의-코드란-무엇일까요&quot;&gt;좋은 품질의 코드에 대해서 말씀 하셨는데 종진님이 생각하시는 좋은 품질의 코드란 무엇일까요??&lt;/h3&gt;

&lt;p&gt;코드란 특정 문제를 해결하기 위해서 작성하는 것이라고 생각합니다. 이러한 문제들은 대부분 요구사항 등을 통해서 발생하기 마련이기 때문에 &lt;strong&gt;현재의 요구사항을 만족하면서 불확실한 미래의 요구사항까지 유연하게 대처할 수 있는 코드를 좋은 품질의 코드&lt;/strong&gt;라고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-종진님이-좋아하시는-객체-지향에서-좋은-품질의-코드란-무엇일까요&quot;&gt;그렇다면 종진님이 좋아하시는 객체 지향에서 좋은 품질의 코드란 무엇일까요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;객체 지향에서 좋은 품질의 코드란, 관련 도메인 지식들을 깊게 이해하고 이를 객체들의 협력으로 잘 녹여낸 코드&lt;/strong&gt;를 의미합니다. 즉, 깊은 도메인 지식을 기반으로 코드를 작성 했을 때 도메인 구조가 완전히 바뀌지 않는 이상 추후 변경에 유연하게 대처할 수 있다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;품질이-좋지-않는-코드를-어떻게-좋은-품질의-코드로-바꿀-수-있을까요&quot;&gt;품질이 좋지 않는 코드를 어떻게 좋은 품질의 코드로 바꿀 수 있을까요?&lt;/h3&gt;

&lt;p&gt;여러 관점에서 다양한 방법이 있을 것 같습니다. 내부 로직에서 병목이 발생한다면 모니터링을 통해 특정 로직을 추적해서 &lt;strong&gt;리팩토링&lt;/strong&gt;을 할 수도 있겠구요 만약 설계 자체에서 모듈간의 결합도가 높아 코드 수정만으로는 도저히 안되겠는 경우에는 &lt;strong&gt;재설계&lt;/strong&gt;를 하는 등 다양한 방법으로 품질을 올릴 수 있을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-방금-refactoring에-대해서-말씀해-주셨는데-refactoring-이란-무엇인가요&quot;&gt;그렇다면 방금 Refactoring에 대해서 말씀해 주셨는데 Refactoring 이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;외부동작을 바꾸지 않으면서 내부 구조를 개선하는 방법&lt;/strong&gt;이라고 생각합니다. 이에 앞서서 &lt;strong&gt;어디까지가 외부 동작인지 bound를 먼저 설정&lt;/strong&gt;할 필요가 있고 &lt;strong&gt;관련 테스트를 작성을 해서 리팩토링 후에도 동일한 동작을 한다는 것을 검증&lt;/strong&gt;할 필요가 있을 것 같습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;소프트웨어-개발-동아리-회장&quot;&gt;소프트웨어 개발 동아리 회장&lt;/h1&gt;

&lt;h3 id=&quot;종진님이-소프트웨어-개발-동아리-회장을-하시면서-얻은-부분이-있나요&quot;&gt;종진님이 소프트웨어 개발 동아리 회장을 하시면서 얻은 부분이 있나요??&lt;/h3&gt;

&lt;p&gt;동아리 회장을 하면서 책임감이나 리더쉽 등의 부분에서도 많이 배우고 느꼈지만 가장 가치있게 얻었던 점은 &lt;strong&gt;지식 공유의 힘&lt;/strong&gt;에 대해서 많이 배울 수 있어서 좋았다고 생각합니다. 저희 동아리는 일주일에 한번 주간발표를 진행합니다. 이 발표는 각 팀별로 프로젝트 진행 과정에서 문제를 해결한 경험이나, 기술을 학습하고 적용하면서 일어난 이슈 및 경험들에 대해서 발표하는 시간입니다.&lt;/p&gt;

&lt;p&gt;이 행사에서 &lt;strong&gt;저는 다른 사람 발표를 통해 시야를 넓힐 수 있었고 직접 발표를 준비하면서 제 지식의 깊이도 늘릴 수 있었습니다.&lt;/strong&gt; 이러한 지식의 선순환 구조에서 지식 공유의 힘을 느꼈고 현재에도 지식의 선순환 구조를 구축하기위해 열심히 노력하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;종진님이-소프트웨어-개발-동아리-회장을-하시면서-가장-힘들었던-부분이-무엇이었나요&quot;&gt;종진님이 소프트웨어 개발 동아리 회장을 하시면서 가장 힘들었던 부분이 무엇이었나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;가장 힘들었던 부분은 많은 규칙과 규정 속에서 발생했던 예외케이스 때문에 힘들었던 것 같습니다.&lt;/strong&gt; 나름 저희가 많은 부분을 고려해서 규칙과 규정을 세웠지만 항상 예외적인 케이스들이 생겼고 이 중심에 회원들이 있었기 때문에 “이걸 어떻게 처리해야하지?”, “동아리 뿐만 아니라 회원들에게 도움이 될 수 있는 방향은 무엇일까?” 에 대해서 매번 고민하고 결정하는 과정이 리더로써 가장 힘들었던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떻게-그러한-문제를-해결하셨나요&quot;&gt;어떻게 그러한 문제를 해결하셨나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;관련 당사자와 수 많은 대화를 통해서 동아리의 본질을 보려고 노력했더니 해결할 수 있었습니다.&lt;/strong&gt; 저희 동아리의 본질은 조직의 성장과 개인의 성장 모두를 목표로 하는 동아리 입니다.&lt;/p&gt;

&lt;p&gt;즉, 조직의 성장을 위해서 개인의 성장을 방해하면 안됬었고, 개인의 성장을 위해서 조직의 성장을 방해하면 안됬었습니다. 이러한 본질을 보는 시각을 통해서 동아리 뿐만 아니라 개인의 성장까지 함께 이룰 수 있는 대안들을 매번 찾았고 이에 대한 결과로써 (제 입으로 말하긴 창피하지만) 저희 동아리는 전남대학교 최고의 IT 개발동아리가 되었고, 회원들은 네이버, 카카오, 배민, 쿠팡 등 IT 서비스 업계에 많이 진출할 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;오프라인으로-동아리를-운영하시면서-어려운-점은-없었나요&quot;&gt;오프라인으로 동아리를 운영하시면서 어려운 점은 없었나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;가장 어려웠던 점은 한 순간에 오프라인 행사를 온라인으로 전체 전환하는 것이 가장 어려웠던 것 같습니다.&lt;/strong&gt; 동아리 원들에게 Slack, Google Meets, Git등 온라인 협업 도구등을 더 자세히 교육 시켜야만했고 비대면으로 행사로 인해 약해진 동아리원들간의 유대감과 친목 형성을 위해 새롭고 재미있는 행사들을 매번 운영해야하는 부담감이 조금 있었던 것 같습니다. (동아리 원들이 직접 만든 게임으로 행사를 진행하기도 했었구요!)&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;해커톤-운영-경험&quot;&gt;해커톤 운영 경험&lt;/h1&gt;

&lt;p&gt;주제: 비대면 환경에서 빅데이터/클라우드 자원을 활용한 서비스 아이디어&lt;/p&gt;

&lt;h3 id=&quot;온라인-해커톤을-왜-운영-하시게-되었나요&quot;&gt;온라인 해커톤을 왜 운영 하시게 되었나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;교내 온라인 해커톤을 운영하게 된 이유는 지방에 위치한 저희 학교 학생들에게 다양한 경험 제공하고 전남대학교 개발 생태계를 활성화 시키기 위해서 해커톤을 처음으로 시작하였습니다.&lt;/strong&gt; 지방에 거주하는 학생들은 상대적으로 수도권에 비해서 해커톤과 같은 대회에 대한 정보가 많이 부족합니다. 혹여 정보를 얻어 대회에 참여하더라도 거의 모든 경우 수도권까지 올라가야하거나 온라인으로 참여해야 했었습니다. &lt;strong&gt;이러한 학생들에게 해커톤이 무엇인지에 대해서 알려주고 교내에서 직접 대회까지 열어 이를 기반으로 학생들 사이에서 IT 지식들이 잘 공유되어지는 개발 생태계를 만드는 것이 저희의 목적이었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;해커톤을-운영하시면서-뭘-얻을-수-있었나요&quot;&gt;해커톤을 운영하시면서 뭘 얻을 수 있었나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;코로나와 같이 주어진 환경에 굴복하지 않고 항상 도전하고 변화할 수 있다는 자신감과 즐거음울 얻게 해준 것이 가장 인상적이었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;이걸-하면서-팀원들과의-불화는-없었던가&quot;&gt;이걸 하면서 팀원들과의 불화는 없었던가?&lt;/h3&gt;

&lt;p&gt;불화라고 할 정도의 팀 내부 갈등은 없었구요 제가 &lt;strong&gt;의사결정 방식을 다수결 보다는 명확한 이유와 근거를 통해서 항상 결정했기 떄문에 매번 회의 시간이 길어져서 팀 내에서 불만이 좀 많았던점 이게 가장 큰 불화&lt;/strong&gt;였던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;기술을-도입한-경험은-없나요&quot;&gt;기술을 도입한 경험은 없나요??&lt;/h3&gt;

&lt;p&gt;해커톤도 일종의 프로젝트라고 할 수 있는데 저희가 어떻게 하면 해커톤 프로젝트를 생산성 있게 관리할 수 있을까? 에 대해서 깊게 고민하고 논의 한 결과 &lt;strong&gt;칸반 기반의 소프트웨어로 프로젝트를 진행상황을 관리하고 공유하면 생산성 향상 측면에서 많은 장점을 얻을 수 있겠다 싶어 Trello를 해커톤 팀에 도입&lt;/strong&gt;하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;오프라인-환경에서-운영하시느라-불편한-점은-없었나요&quot;&gt;오프라인 환경에서 운영하시느라 불편한 점은 없었나요?&lt;/h3&gt;

&lt;p&gt;당연히 불편한점은 많았습니다. 매번 저희는 오프라인으로 회의를 진행했는데 회의실을 구하는 것도 너무 어려웠구요. &lt;strong&gt;해커톤 관련 행사들을 모두 온라인으로 진행 해야 되었기 때문에 예외 상황들이 많이 발생해서 이를 미리 예측하고 시나리오를 작성하고 거의 모든 행사에 이러한 작업들을 수차례 반복하는 것이 좀 불편&lt;/strong&gt;했던 것 같습니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/15/NAVER-Interview-Preparation-7.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/15/NAVER-Interview-Preparation-7.html</guid>
        
        <category>Introduction</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 6일차] Github Pages Blog</title>
        <description>&lt;h1 id=&quot;github-pages-blog&quot;&gt;Github Pages Blog&lt;/h1&gt;

&lt;h3 id=&quot;github-pages란-무엇인가&quot;&gt;Github Pages란 무엇인가??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;GitHub Pages란 Github 저장소의 내용을 웹페이지로 만들어 주는 정적 웹 사이트 호스팅 서비스&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;tistory-velog-등-다양한-글쓰기-플랫폼이-존재하는데-왜-github-pages를-사용했는가&quot;&gt;Tistory, Velog 등 다양한 글쓰기 플랫폼이 존재하는데 왜 Github Pages를 사용했는가?&lt;/h3&gt;

&lt;p&gt;말씀하신대로 글쓰기 플랫폼은 아주 다양하고 편리한 기능들을 지원해 줍니다. 이러한 기능들을 사용해서 나만의 멋진 블로그를 만들 수 있지만 &lt;strong&gt;모든 기능이 플랫폼에 종속&lt;/strong&gt;되어 있기 때문에 자유자재로 나만의 특징을 가진 블로그를 만들기에는 한계가 존재한다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어렵지만 난 개발자니까 할 수 있을꺼다 라고 생각해서 좀 더 로우 레벨인 Github pages로 나만의 블로그를 만들었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;아주-좋은-접근인-것-같다-그렇다면-어떤-정적-사이트-생성기를-활용하여-github-pages-서비스를-이용했는가&quot;&gt;아주 좋은 접근인 것 같다. 그렇다면 어떤 정적 사이트 생성기를 활용하여 Github Pages 서비스를 이용했는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll이라고 하는 Ruby 언어 기반의 정적 사이트 생성기&lt;/strong&gt;를 사용했습니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-jekyll을-사용-했는가&quot;&gt;왜 Jekyll을 사용 했는가??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;일단 Github Pages가 Jekyll을 기본 엔진&lt;/strong&gt;으로 하기 때문에 사용한 것도 있지만, 마음에 드는 템플릿이 대부분 Jekyll을 사용하기 때문에 Jekyll을 사용해서 Github Pages 서비스를 이용하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;jekyll을-사용하는데-어려움이-없었는가&quot;&gt;Jekyll을 사용하는데 어려움이 없었는가??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;첫 블로깅 환경을 구성하는데 어려움&lt;/strong&gt;이 있었습니다. 정적 사이트 생성기라서 단순할 줄 알았지만 생각보다 복잡했고 어떤 모듈이 어떠한 역할을 하는지에 대해 파악하는데 어려웠습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떻게-어려움을-극복하게-되었는가&quot;&gt;어떻게 어려움을 극복하게 되었는가??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;템플릿을 만든 사람이 사용자 친화적으로 코드 작성 및 모듈화를 해줘서 구조를 파악하는데 많은 도움&lt;/strong&gt;이 되었습니다. 그래도 모르는 부분은 &lt;strong&gt;직접 모듈 하나 하나를 뜯어보거나 공식 문서&lt;/strong&gt;를 통해서 이슈를 해결했던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;구체적으로-어려움이-무엇이었는가&quot;&gt;구체적으로 어려움이 무엇이었는가??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;제가 원하는 디자인의 블로그&lt;/strong&gt;를 만들면서 이슈가 발생했습니다. &lt;strong&gt;블로그의 메인 컬러라는 property가 존재했고, 이는 블로그의 메인 컬러 뿐만 아니라 텍스트의 색깔에도 종속&lt;/strong&gt;되어 있었습니다. 이를 해결하기 위해 저는 &lt;strong&gt;properties파일에서 메인 컬러 Property를 배경 Color와 텍스트 색깔 property를 나누었고 관련 코드를 바꿈&lt;/strong&gt;으로써 제가 원하는 디자인을 가진 블로그를 만들 수 있었습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/14/NAVER-Interview-Preparation-6.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/14/NAVER-Interview-Preparation-6.html</guid>
        
        <category>GitHub-Pages</category>
        
        <category>Blog</category>
        
        <category>Jekyll</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 5일차] 스마트 도어락 (Mobius)</title>
        <description>&lt;h1 id=&quot;스마트-도어락-smart-doorlock&quot;&gt;스마트 도어락 (Smart Doorlock)&lt;/h1&gt;

&lt;h3 id=&quot;스마트-도어락-프로젝트를-진행하셨는데-스마트-도어락이-무엇인가요&quot;&gt;스마트 도어락 프로젝트를 진행하셨는데 스마트 도어락이 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스마트 도어락이란 IoT 오픈소스 서버 플랫폼인 Mobius를 활용한 사용자의 완벽한 외출을 도와주는 IoT 플랫폼입니다.&lt;/strong&gt; 자택 현관문 내부에 존재하는 기존의 도어락 본체는 제거하고 그 자리에 터치식 디스플레이를 설치하여 &lt;strong&gt;사용자에게 외출시에 필요한 날씨 및 미세먼지 등의 다양한 정보를 제공하고 가스 밸브 및 전등과 같은 가전들을 등록해 상태확인 및 제어할 수 있는 기능을 가진 IoT 플랫폼&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;모비우스-플랫폼을-사용하셨다고-했는데-모비우스-플랫폼은-무엇인가요&quot;&gt;모비우스 플랫폼을 사용하셨다고 했는데 모비우스 플랫폼은 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;모비우스란 oneM2M 표준을 기반으로한 오픈소스 IoT 서버 플랫폼입니다.&lt;/strong&gt; Mobius는 다양한 도메인 IoT 애플리케이션에 대한 미들웨어로써 oneM2M표준에 해당하는 공통 서비스 기능인 CSE와 AE 등록, 데이터 관리, 구독/알림 서비스, 보안 등을 제공합니다.&lt;/p&gt;

&lt;h3 id=&quot;onem2m이란-무엇인가요-표준을-말씀하시는-건가요&quot;&gt;oneM2M이란 무엇인가요? 표준을 말씀하시는 건가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;oneM2M이란 말 그대로 one + M2M의 합성어로 Machine간의 통신을 하나의 인프라 환경에 통합하기 위한 플랫폼 개발 표준화 단체 및 표준입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;!-- **산업별로 파편화된 서비스 플랫폼 개발 구조에서 벗어나 응용서비스 인프라 환경을 통합하는 사물인터넷 공동서비스 플랫폼 개발을 위한 표준화 단체 및 표준입니다.** --&gt;

&lt;h3 id=&quot;방금-말씀하신-in은-무엇인가요&quot;&gt;방금 말씀하신 IN은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IN 이란 Infrastructure Node를 의미하는 것으로 인프라 도메인에 위치한 IN-CSE를 포함하는 서버 기기&lt;/strong&gt;를 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;방금-말씀하신-cse는-무엇인가요&quot;&gt;방금 말씀하신 CSE는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CSE란 Common Service Entity의 줄임말로 oneM2M 서비스 플랫폼에서 공통적으로 제공되어야하는 서비스 기능을 제공하는 미들웨어&lt;/strong&gt;를 말합니다.&lt;/p&gt;

&lt;h3 id=&quot;미들웨어란-무엇인가요&quot;&gt;미들웨어란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;미들웨어란 OS와 응용 소프트웨어 중간에서 조정과 중개의 역할을 수행하는 소프트웨어&lt;/strong&gt;를 말하구요 미들웨어를 사용하면 응용 소프트웨어가 운영체제로부터 제공받는 서비스 이외에 추가적인 서비스를 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex) 메시지 처리 소프트웨어, 데이터베이스 시스템&lt;/p&gt;

&lt;h3 id=&quot;방금-말씀하신-adn이란-무엇인가요&quot;&gt;방금 말씀하신 ADN이란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ADN이란 Application Dedicated Node의 줄임말로 필드 도메인에 위치한 ADN-AE를 포함하고 CSE를 포함하지 않는 논리적 기기&lt;/strong&gt;를 말합니다.&lt;/p&gt;

&lt;h3 id=&quot;방금-말씀하신-ae란-무엇인가요&quot;&gt;방금 말씀하신 AE란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;AE란 Application Entitiy의 줄임말로 M2M(Machine to Machine)서비스를 제공하기 위한 논리적인 엔티티&lt;/strong&gt;를 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;cube와-tas는-무엇인가요&quot;&gt;&amp;amp;Cube와 TAS는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&amp;amp;Cube는 IoT 디바이스에 탑재되는 S/W 플랫폼으로 IN-CSE와 연동할 수 있도록 지원하는 소프트웨어&lt;/strong&gt;입니다. &lt;strong&gt;TAS란 실제 사물을 디바이스에 연결하기 위한 S/W로써 사물과 &amp;amp;Cube간의 연결통로를 만드는 역할&lt;/strong&gt;을 한다.&lt;/p&gt;

&lt;p&gt;즉, 사물과 &amp;amp;Cube를 Tas로써 연결하고 사물과 IN-CSE 즉, Mobius를 &amp;amp;Cube로써 연결할 수 있게 해줍니다.&lt;/p&gt;

&lt;h3 id=&quot;nodejs를-in-ae로-사용한-이유가-있나요&quot;&gt;Node.js를 IN-AE로 사용한 이유가 있나요??&lt;/h3&gt;

&lt;p&gt;꼭 Node.js를 사용해야만하는 특별한 이유는 없었구요, &lt;strong&gt;마감까지 프로젝트를 빠르게 빌드업&lt;/strong&gt; 시키기 위해서 사용했던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;nodejs의-특징에-대해서-알고-있나요&quot;&gt;Node.js의 특징에 대해서 알고 있나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Node.js란 자바스크립트를 사용하고 Non-blocking I/O와 단일-스레드 이벤트 루프를 통한 높은 처리 성능&lt;/strong&gt;을 가지고 있습니다. 또한 &lt;strong&gt;내장 HTTP 서버 라이브러리를 포함&lt;/strong&gt;하고 있어 웹 서버에서 아파치 등의 별도의 소프트웨어 없이 동작하는 것이 가능하기 때문에 빠르게 프로토타입을 제작 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;non-blocking-io란-무엇인가요&quot;&gt;Non-blocking I/O란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;여러 I/O 가 실행될 때 하나의 I/O가 다른 I/O에 의해서 block되지 않고 병렬로써 실행&lt;/strong&gt;되는 것을 의미합니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/13/NAVER-Interview-Preparation-5.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/13/NAVER-Interview-Preparation-5.html</guid>
        
        <category>Smart-Doorlock</category>
        
        <category>Mobius</category>
        
        <category>Node.js</category>
        
        <category>oneM2M</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 4일차] 자료구조 &amp; Spring MVC</title>
        <description>&lt;h1 id=&quot;자료구조-data-structure&quot;&gt;자료구조 (Data Structure)&lt;/h1&gt;

&lt;h3 id=&quot;array-란-무엇인가요&quot;&gt;Array 란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Array는 가장 기본적인 자료 구조이며, 논리적 저장 순서와 물리적 저장 순서가 일치 합니다.&lt;/strong&gt; 원소의 인덱스 값을 알고 있으면 검색에 O(1)이 걸리지만 삽입이나 삭제등이 필요한 경우 원소들을 shift해줘야 하기 때문에 O(n)의 시간이 걸립니다.&lt;/p&gt;

&lt;h3 id=&quot;linked-list&quot;&gt;Linked List&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;모든 노드들을 링크로 연결한 리스트를 말합니다.&lt;/strong&gt; 이 경우 삭제와 삽입은 O(1)만에 해결할 수 있지만, 원하는 위치에 원소를 삽입하거나 삭제하는 경우 이를 Search하는 시간이 필요하므로 O(n)의 시간이 걸립니다.&lt;/p&gt;

&lt;h3 id=&quot;선형-자료구조와-비선형-자료구조의-차이는-무엇인가요&quot;&gt;선형 자료구조와 비선형 자료구조의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;선형 자료구조는 데이터 요소들이 저장되어 있는 모습을 표현했을 때 직선이고, 비선형 자료구조는 데이터 요소들이 저장되어 있는 모습을 표현했을 때 직선이 아닌 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;선형 자료구조의 대표적인 예는 Array, Queue 등이 있고, 비선형 자료구조의 대표적인 예는 Tree, Graph등이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;

&lt;p&gt;선형 자료구조의 일종으로 &lt;strong&gt;Last In First Out(LIFO)&lt;/strong&gt;의 특징을 가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;queue&quot;&gt;Queue&lt;/h3&gt;

&lt;p&gt;선형 자료구조의 일종으로 &lt;strong&gt;First In First Out(FIFO)&lt;/strong&gt;의 특징을 가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;tree&quot;&gt;Tree&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;트리는 비선형 자료구조로서 node들과 이를 연결하는 edge들로 구성되어 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;트리는 하나의 루트 노드를 갖는다.&lt;/li&gt;
  &lt;li&gt;트리에는 싸이클이 존재할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binary-tree&quot;&gt;Binary Tree&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;이진 트리란 각 노드가 최대 두개의 자식을 갖는 트리를 말합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;완전 이진 트리: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있고 마지막 레벨의 노드가 왼쪽에서 오른쪽으로 채워지는 이진 트리&lt;/li&gt;
  &lt;li&gt;진 이진 트리 : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 이진 트리&lt;/li&gt;
  &lt;li&gt;포화 이진 트리 : 모든 레벨에 노드과 꽉 찬 이진 트리를 가르킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binary-search-tree&quot;&gt;Binary Search Tree&lt;/h3&gt;

&lt;p&gt;중복된 데이터를 갖는 노드가 없다는 가정하에 말씀드리겠습니다. &lt;strong&gt;부모 노드가 왼쪽 자식보다 크고 오른쪽 자식보다는 작은 규칙을 만족하는 이진 트리를 Binary Search Tree&lt;/strong&gt; 라고 합니다. Binary Search Tree에서 탐색, 삽입, 삭제 연산의 시간 복잡도는 O(h) 즉, 높이에 비례합니다. 하지만 완전 이진 트리인 경우에 O(log n)으로 표현할 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;heap&quot;&gt;Heap&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;힙(heap)은 최대 또는 최소를 빠르게 찾아내기 위해 만들어진 완전이진트리를 기본으로 한 자료구조로서 부모노드와 자식 노드간에 대소관계가 성립한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;힙의 시간복잡도는 최대 및 최소를 검색 시간복잡도는 O(1)입니다. 하지만 heapify의 시간 복잡도는 O(log N)이기 때문에 고민해 봄직 하다.&lt;/p&gt;

&lt;h3 id=&quot;heap과-bst의-차이는-무엇인가요&quot;&gt;Heap과 BST의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;힙은 최대 및 최소를 찾는데 (O(1)) 좋지만, BST는 모든 원소들을 찾는데 (O(log n)) 유용합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;red-black-tree&quot;&gt;Red Black Tree&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Red Black Tree란 자가 균형 이진 탐색 트리의 한 종류로써 이진 탐색 트리의 단점인 편향성을 색깔을 통해서 보완하기 위한 자료구조이다.&lt;/strong&gt; 검색, 삽입, 삭제의 시간 복잡도는 O(log n)이다.&lt;/p&gt;

&lt;h3 id=&quot;hash-table&quot;&gt;Hash Table&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Hash Table이란, 임의의 길이를 가진 키를 고정된 길이의 Hash Code로 변환시켜서 저장하는 자료구조를 의미&lt;/strong&gt;하구요 연산시 시간복잡도는 O(1)입니다.&lt;/p&gt;

&lt;h3 id=&quot;hash-function&quot;&gt;Hash Function&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;해시란 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑 하는 함수를 해시 함수&lt;/strong&gt;라고 하며 이로부터 얻어진 값을 해시 값, 해시 코드, 짧게 말해서 해시라고도 합니다. 항상 Collision 즉, 서로 다른 두 개의 키가 같은 인덱스로 hashing되는 경우를 조심하는 알고리즘을 구현해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;graph란-무엇인가요&quot;&gt;Graph란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Node들과 이를 연결하는 Edge들을 모아 놓은 자료구조이다.&lt;/strong&gt; 방향 및 비방향 그래프 모두 존재하며, 사이클 및 self-loop 가 존재해도 상관 없다.&lt;/p&gt;

&lt;p&gt;그래프의 구현 방법에는 인접 행렬과, 인접 리스트 등이 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;그래프-탐색에는-어떠한-방법이-존재하나요&quot;&gt;그래프 탐색에는 어떠한 방법이 존재하나요?&lt;/h3&gt;

&lt;p&gt;그래프는 따로 규칙이 존재하지 않기 때문에 &lt;strong&gt;모든 정점을 탐색&lt;/strong&gt;해야만 하구요, &lt;strong&gt;특정 정점을 기준으로 넓게 탐색하기 전에 깊게 탐색하는 방법인 DFS&lt;/strong&gt;와 &lt;strong&gt;깊게 탐색하기 전에 넓게 탐색하는 방법인 BFS&lt;/strong&gt;가 존재합니다.&lt;/p&gt;

&lt;p&gt;DFS와 BFS를 인접리스트로 구현할 경우에 시간복잡도는 O(V+E) 이구요, 인접 행렬로써 구현할 경우에 시간복잡도는 O(V^2)입니다.&lt;/p&gt;

&lt;h3 id=&quot;minimum-spanning-tree란-무엇인가요&quot;&gt;Minimum Spanning Tree란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spanning Tree란 그래프 G의 모든 V가 Cycle 없이 연결된 형태를 말하구요, 여러 Spanning Tree 중 Edge의 가중치의 합이 가장 작은 것을 Minimum Spanning Tree&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;minimum-spanning-tree를-구하는-방법에는-무엇이-있나요&quot;&gt;Minimum Spanning Tree를 구하는 방법에는 무엇이 있나요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MST를 구하는 방법 중 탐욕적인 방법으로 Edge 값이 가장 작은 것부터 탐색하는 Kruskal Algorithm과 Prim Algorithm이 존재합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kruskal의 시간 복잡도는 O(ElogE)이고, Prim Algorithm의 시간 복잡도는 O(ElogV)이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;spring-mvc&quot;&gt;Spring MVC&lt;/h1&gt;

&lt;h3 id=&quot;mvc-패턴이란-무엇인가요&quot;&gt;MVC 패턴이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MVC 패턴이란 웹 어플리케이션에서 자주 사용하는 디자인 패턴으로 시스템을 크게 Model, View, Controller로 나누어 모듈간에 결합도를 낮추고 응집도를 높이기 위해 사용하는 패턴&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Controller란 요청을 받아서 모델, 뷰와의 상호작용을 통해 적절한 응답을 제공해주는 중계자&lt;/strong&gt;의 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모델은 시스템에서 사용하는 도메인 모델&lt;/strong&gt; 등을 의미합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;뷰는 사용자에게 제공하는 화면&lt;/strong&gt; 등을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-mvc의-구조에-대해서-설명해-주실-수-있나요&quot;&gt;Spring MVC의 구조에 대해서 설명해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring MVC의 시작은 DispatcherServlet이라고 할 수 있습니다. DispatcherServlet은 사용자의 HTTP 요청을 처리하기 위하여 등록된 핸들러로 디스패치하여 매핑 및 예외 처리 기능을 제공&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet으로 요청이 들어왔을 때 웹 서버의 대략적인 과정은 다음과 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DispatcherServlet으로 HTTP Request가 들어온다.&lt;/li&gt;
  &lt;li&gt;DispatcherServlet은 HandlerMapping을 통해서 요청 URL 등의 정보와 맵핑되는 적절한 Controller를 검색한다.&lt;/li&gt;
  &lt;li&gt;DispatcherServlet은 HandlerAdapter를 통해 HandlerMapping에서 결정된 핸들러 정보를 통해서 컨트롤러를 호출한다.&lt;/li&gt;
  &lt;li&gt;Controller는 요청을 받아 적절한 비즈니스 로직을 태운다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직이 끝난 후 사용자에게 응답 할 View의 이름을 DispatcherServlet을 통해서 View Resolver로 전달한다.&lt;/li&gt;
  &lt;li&gt;View Resolver는 View name에 해당하는 view를 검색한다. (prefix, suffix, resource path)&lt;/li&gt;
  &lt;li&gt;응답 받을 View가 존재한다면 DispatcherServlet으로 View를 가져오고 사용자에게 응답한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;servlet이란-무엇인가요&quot;&gt;Servlet이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HTTP 서블릿이란 자바단에서 클라이언트의 요청을 처리하고 응답을 제공하는 객체라고 할 수 있습니다.&lt;/strong&gt; 서블릿 하나당 스레드 하나가 할당 된다.&lt;/p&gt;

&lt;h3 id=&quot;spring-mvc를-위한-필수-설정&quot;&gt;Spring MVC를 위한 필수 설정&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Web Deployment Descriptor(web.xml)이란 클라이언트가 어떤 URL을 요청했을 때 어떤 Servlet 파일을 실행시킬 것인지를 매핑해놓은 파일이다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Servlet 설정&lt;/li&gt;
  &lt;li&gt;ContextConfigLocation 설정 : Context Loader가 load할 수 있는 설정 파일의 위치 명시&lt;/li&gt;
  &lt;li&gt;Filter 설정&lt;/li&gt;
  &lt;li&gt;SpringSecurityFilterChain&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Spring MVC Configuration Files&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;dispatcher-servlet.xml&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Controller 관련&lt;/li&gt;
      &lt;li&gt;mvc:annotation-driven 설정&lt;/li&gt;
      &lt;li&gt;Component-scan 관련&lt;/li&gt;
      &lt;li&gt;정적인 data 위치 mapping&lt;/li&gt;
      &lt;li&gt;ViewResolver 관련 (prefix, suffix, …)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;applicationContext.xml&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;DataSource 주입&lt;/li&gt;
      &lt;li&gt;Properties 등록&lt;/li&gt;
      &lt;li&gt;tx:annotation-driven 설정 (어노테이션 기반 트랜잭션 동작 설정)&lt;/li&gt;
      &lt;li&gt;Session Factory 등록 및 TransactionManager 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-boot-mvc와-spring-mvc의-차이&quot;&gt;Spring Boot MVC와 Spring MVC의 차이&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Boot기반 MVC는 기존에 Spring MVC에서 필수적으로 설정해야 하는 톰캣설정 및 web.xml에 관련된 설정을 스프링 부트의 내부모듈에 의해서 구동시 자동설정&lt;/strong&gt; 해준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@SpringBootApplication 어노테이션은 @ComponentScan, @EnableAutoConfiguration, @Configuration 에노테이션&lt;/strong&gt; 등으로 이루어져 있는데 이게 핵심이다.&lt;/p&gt;

&lt;p&gt;HttpMessageConverter, ViewResolver, Resource, jar 등, 톰캣 설정 및 web.xml에 관련된 설정을 스프링 부트의 내부모듈에 의해서 구동시 자동설정 해준다.&lt;/p&gt;

&lt;h3 id=&quot;spring-boot-설정-관련-이슈는-있었는가&quot;&gt;Spring Boot 설정 관련 이슈는 있었는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Boot MVC의 자동 설정에 가장 중요한 클래스는 WebMvcAutoConfiguration&lt;/strong&gt;인데 위에  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)와 같은 애노테이션이 있었습니다.&lt;/p&gt;

&lt;p&gt;즉, WebMvcConfigurationSupport Bean이 존재하면 WebMvcAutoConfiguration bean이 생성되지 않아 web mvc 자동 설정이 되지 않는다는 이야기 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;우리는 Spring Boot MVC에 설정을 추가하기 위해서는 WebMvcConfigurer를 상속받아서 빈으로 만들어야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 설정이 추가되는 코드는 &lt;strong&gt;DelegatingWebMvcConfiguration&lt;/strong&gt; 클래스의 로직에서 WebMvcConfigurer Bean들을 주입받고 이를 Spring MVC 설정에 추가합니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-mvc에서-spring-boot-starter가-해주는-것들은-무엇인가요&quot;&gt;Spring MVC에서 Spring Boot Starter가 해주는 것들은 무엇인가요??&lt;/h3&gt;

&lt;p&gt;프로젝트의 pom.xml을 보면 일단 가져오는 &lt;strong&gt;프로젝트 의존성 부터 차이&lt;/strong&gt;가 존재한다. &lt;strong&gt;spring mvc는 spring 프로젝트의 spring-webmvc라는 의존성&lt;/strong&gt;을 가져오고, &lt;strong&gt;spring boot mvc는 spring boot 프로젝트의 spring-boot-starter-web&lt;/strong&gt;을 가져온다.&lt;/p&gt;

&lt;p&gt;spring boot starter web은 기본적인 spring mvc를 사용하기 위한 많은 설정을 자동화 해주고 애노테이션 기반으로 프로젝트의 설정을 할 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;spring boot web mvc가 해주는 설정들은 다음과 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내장된 웹 애플리케이션 서버(Tomcat, Jetty, Undertow)&lt;/li&gt;
  &lt;li&gt;의존성을 손쉽게 관리할 수 있는 Project Object Model&lt;/li&gt;
  &lt;li&gt;설정의 표준화와 자동화
    &lt;ul&gt;
      &lt;li&gt;Spring Framework의 수 많은 XML 기반의 설정을 Spring Boot의 자동 설정으로 제거하거나 properties 형식과 JavaConfig 형식으로 대체&lt;/li&gt;
      &lt;li&gt;각종 Filter, ViewResolver, DispatcherServlet설정, ComponentScan, Annoation기반 설정 등을 자동으로 설정해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-mvc와-was의-관계&quot;&gt;Spring MVC와 WAS의 관계&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트는 tomcat에게 요청을 보내고 tomcat은 URL 및 기타 정보에 따라(web.xml) 처리를 위해 요청을 보낼 서블릿&lt;/strong&gt;을 결정합니다. spring web mvc에서 이 서블릿은 대부분 DispatcherServlet을 의미하고 이를 통해 Controller단으로 들어와 비즈니스 로직을 태운 뒤 적절한 모델을 만들어 뷰에 랜더링한 후 톰캣에게 다시 전송되고 톰캣은 클라이언트에게 다시 전송합니다.&lt;/p&gt;

&lt;h3 id=&quot;executable-jar-file&quot;&gt;Executable Jar File&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Boot maven plugin을 사용하면 Spring Boot loader가 Tomcat이 내재된 실행가능한 Jar파일을 생성&lt;/strong&gt;해준다. 우리는 이를 통해 jar 파일만 실행시키면 되는 것이니 스프링을 구성할 때 매우 편리하다.&lt;/p&gt;

&lt;h3 id=&quot;spring-mvc에서-exception-이-발생하면-어떻게-되는가&quot;&gt;Spring MVC에서 Exception 이 발생하면 어떻게 되는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;request mapping 또는 request handler로 부터 예외가 발생하면 DispatcherServlet은 HandlerExceptionResolver구현체가 예외를 처리해 적절한 응답을 클라이언트에게 보낸다.&lt;/strong&gt; 나는 Jackson 사용간에 Deserialize에서 에러 발생을 경험해 보았기 때문에 &lt;strong&gt;DefaultHandlerExceptionResolver&lt;/strong&gt;가 400번 상태 코드를 맵핑해서 사용자에게 응답해주었다.&lt;/p&gt;

&lt;h3 id=&quot;spring-message-converter는-어떻게-동작하는가&quot;&gt;Spring Message Converter는 어떻게 동작하는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Boot는 HttpMessageConvertersAutoConfiguration을 이용해서 Converter 서비스도 자동 구성해줌으로 이를 이용하면 된다. Json Parsing을 위해 MappingJackson2HttpMessageConverter가 사용된다.&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 12 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/12/NAVER-Interview-Preparation-4.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/12/NAVER-Interview-Preparation-4.html</guid>
        
        <category>Data-Structure</category>
        
        <category>Spring-MVC</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 3일차] 자바 &amp; 객체 지향 프로그래밍</title>
        <description>&lt;h1 id=&quot;java&quot;&gt;Java&lt;/h1&gt;

&lt;h3 id=&quot;java-8을-많이-공부하셨다고-했는데-java-8의-특징이-뭔가요&quot;&gt;Java 8을 많이 공부하셨다고 했는데 Java 8의 특징이 뭔가요?&lt;/h3&gt;

&lt;p&gt;Java 8은 Java에 &lt;strong&gt;함수형 프로그래밍이 처음으로 도입된 버젼&lt;/strong&gt;이며 새롭게 도입된 기능으로는 &lt;strong&gt;Stream API, Lamda 표현식, Method Reference, Default Method, Optional Class&lt;/strong&gt; 등이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;stream-api란-무엇인가요&quot;&gt;Stream API란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Stream API란 자바에서의 일련의 데이터 요소인 배열이나 컬렉션 등의 데이터를 처리하기 위한 API 입니다.&lt;/strong&gt; Stream API의 특징은 멀티 스레드를 활용해서 병렬로 연산을 수행할 수 있고, 내부 반복으로 연산을 수행하기 때문에 코드가 매우 간단해진다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;lamda-expression은-무엇인가요&quot;&gt;Lamda Expression은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Lamda Expression이란 Functional Interface를 구현하는 객체를 만들지 않고도 메서드로 전달할 수 있는 익명 함수를 단순화한 것입니다.&lt;/strong&gt; 즉, 특정 메소드의 사용을 위해서 일회용 객체를 만들지 않아도 됨으로 성능면에서 좋다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;functional-interface란-무엇인가요&quot;&gt;Functional Interface란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Functional Interface란 정확히 하나의 추상 메서드가 정의된 인터페이스&lt;/strong&gt;를 의미합니다. 예로는 Predicate, Comparator, Runnable 인터페이스등이 존재합니다.&lt;/p&gt;

&lt;h3 id=&quot;method-reference는-무엇인가요&quot;&gt;Method Reference는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;람다 표현식 직접 작성하는 대신해 기존의 메서드 정의를 이용하는 방법&lt;/strong&gt;입니다. 기존의 메서드의 정의와 동일한 람다 표현식을 매번 작성하는 불편함에서 나온 기법이며, 가독성을 높일 수 있다고 생각합니다. 하지만, 저는 아직은 잘 익숙하지 않아서 IDE에 도움을 많이 받고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;optional-클래스는-무엇인가요&quot;&gt;Optional 클래스는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;Optional 클래스란 Java 8에서 새롭게 등장한 클래스이구요 &lt;strong&gt;util 패키지&lt;/strong&gt; 속해 있습니다. &lt;strong&gt;Optional 클래스는 자바 프로그래머들이 가장 자주 접하는 예외인 NPE를 관리 하기 위해 기존 객체를 감싼 Wrapper Class 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;default-method-란-무엇인가요&quot;&gt;Default Method 란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;메서드 구현을 포함하는 인터페이스를 정의하기 위해 사용되어집니다.&lt;/strong&gt; 이 인터페이스를 구현하는 클래스는 인터페이스에 디폴트 메소드도 상속받게 되기 때문에 서브클래스는 최소한의 메소드만 구현해도 됩니다. &lt;strong&gt;즉, 인터페이스는 서브클래스가 구현해야 하는 최소한의 인터페이스를 유지할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;추상-클래스와-인터페이스의-차이는-무엇인가요&quot;&gt;추상 클래스와 인터페이스의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;추상 클래스와 인터페이스의 가장 큰 차이는 사용법에서 존재한다고 생각합니다. &lt;strong&gt;추상 클래스는 멤버와, 메소드 명세, 구현 등 모든 부분이 상속이 되기 때문에 대부분의 경우 코드의 재사용을 위해서 사용되는 경우가 많고, 인터페이스는 메소드 Java 8 이전에는 명세만 상속되었기 때문에 메소드 명세의 상속을 위해서 사용&lt;/strong&gt;된다고 생각합니다. 또한 단일 상속을 지원하는 자바의 특성상 클래스를 상속하는 추상화 계층이 많아질 수록 결합도가 증가하기 때문에 도메인에 맞추어서 잘 사용해야 한다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;오버라이딩과-오버로딩의-차이는-무엇인가요&quot;&gt;오버라이딩과 오버로딩의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;오버라이딩이란 서브클래스가 상속받은 메소드를 클래스에 맞게 재구현 하는 것을 의미&lt;/strong&gt;하구요 &lt;strong&gt;오버로딩이란 동일한 메서드 이름이지만 매개 변수 타입이나 개수가 다른 즉, 다른 명세를 가진 함수를 같은 클래스 내에 만드는 것을 의미&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;h3 id=&quot;업캐스팅과-다운캐스팅의-차이는-무엇인가요&quot;&gt;업캐스팅과 다운캐스팅의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;일단 Java에서는 슈퍼 클래스의 변수에 서브 클래스의 객체가 들어가는 것을 업캐스팅&lt;/strong&gt;이라구 하구요, &lt;strong&gt;업캐스팅 된 변수의 타입을 서브 클래스로 변경하는 것을 다운 캐스팅&lt;/strong&gt;이라고 합니다. &lt;u&gt;서브 클래스 객체는 슈퍼 클래스의 메소드 명세를 상속 받기 때문에 슈퍼 클래스의 변수에 들어가 슈퍼 클래스 인 것처럼 사용될 수 있는 것은 당연하구요, 업 캐스팅 된 변수의 타입이 다시 서브 클래스로 돌아와 본인의 클래스 객체인 것처럼 사용할 수 있는 것도 당연합니다.&lt;/u&gt;&lt;/p&gt;

&lt;h3 id=&quot;제네릭은-이란-무엇인가&quot;&gt;제네릭은 이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다.&lt;/strong&gt; 이를 통해서 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다. 기존에는 Object객체를 사용 했지만 이제는 &amp;lt;T&amp;gt;를 사용함으로써 컴파일 시에 타입을 지정할 수 있게 되었고 다운 캐스팅이 필요없게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;어디에서-제네릭을-보았나요&quot;&gt;어디에서 제네릭을 보았나요??&lt;/h3&gt;

&lt;p&gt;여러 프로젝트를 진행하면서 제네릭을 보았는데, 특히 Pinpoint 프로젝트를 진행하면서 제네릭을 보았던 경험이 기억에 남습니다. Checker 도메인이 검색하는 Metric 타입을 제네릭 와일드 카드로 지정해 놓고 이를 상속해 서브 타입의 Checker에서 제네릭 타입을 설정해 구현한 경험이 생각 납니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이를 통해 얻었던 장점은 특정 Metric을 검색하는 Checker 클래스를 여러개 만들 필요가 없었고, 컴파일 시에 타입 에러를 받을 수 있어서 확실한 장점이 있었지만, 처음 코드를 보는 사람들한테는 조금 어렵게 보여 가독성 측면에서는 좋지 않았던 것 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;자바-컬렉션에-대해서-설명해-주실-수-있나요&quot;&gt;자바 컬렉션에 대해서 설명해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;자바에서 컬렉션이란 데이터의 집합, 그룹을 의미하며 이를 저장하고 연산할 수 있는 집합을 의미합니다.&lt;/strong&gt; &lt;strong&gt;Collection 프레임워크는 크게 두개로 나눌 수 있는데요 순서나 집합적인 저장 공간의 명세를 나타내는 Collection 인터페이스와 키와 값으로 데이터를 핸들링하는 명세를 정의하는 Map 인터페이스로 나눌 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Set, List, Queue 인터페이스가 Collection 인터페이스를 상속해서 각 특성에 맞게 명세를 구체화하고 HashMap, TreeMap 등이 Map 인터페이스를 구현해서 컬렉션 프레임 워크를 형성합니다.&lt;/p&gt;

&lt;h3 id=&quot;set-list-queue의-차이를-설명해-주실-수-있나요&quot;&gt;Set, List, Queue의 차이를 설명해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;List 인터페이스는 객체의 순서가 있고, 원소가 중복될 수 있는 명세&lt;/strong&gt;를 가지고 있으며 구현체는 ArrayList(동기화 보장 x)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Queue 인터페이스는 객체를 입력한 순서대로 저장하며, 원소가 중복될 수 있는 명세&lt;/strong&gt;를 가지고 있으며 구현체로는 LinkedList 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set 인터페이스는 객체의 순서가 없으며, 동일한 원소를 중복 저장 할 수 없는 명세&lt;/strong&gt;를 가지고 있으며 구현체로는 HashSet, TreeSet 등이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;linkedlist와-arraylist의-차이는-무엇인가요&quot;&gt;LinkedList와 ArrayList의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ArrayList는 내부적으로 특정 데이터 타입의 배열에서 데이터를 관리하고, LinkedList는 노드에 데이터를 저장하고 앞 뒤 노드의 주소값을 연결지어 데이터를 관리&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;삽입 및 삭제시 LinkedList는 O(1)의 시간이 걸리고, ArrayList는 O(n)의 시간이 걸립니다. 하지만 인덱스를 통해서 검색시 ArrayList는 O(1)의 시간이 걸리고 링크르 리스트는 O(n)의 시간이 걸립니다.&lt;/u&gt;&lt;/p&gt;

&lt;h3 id=&quot;hashmap은-무엇인가요&quot;&gt;HashMap은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HashMap은 Hashing을 사용해서 Map 데이터를 관리 및 연산하는 데이터 구조를 의미합니다.&lt;/strong&gt; key 값을 hash 함수를 이용해서 hash code로 바꾸고 이를 저장해서 hashcode를 기반으로 검색하는 자료구조 입니다.&lt;/p&gt;

&lt;h3 id=&quot;hashmap과-hashtable의-차이를-아시나요&quot;&gt;HashMap과 HashTable의 차이를 아시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HashTable은 동기화 기능을 제공해 주기 때문에 멀티 스레드 환경에서 스레드 세이프하고, HashMap은 동기화 기능을 제공해 주지 않기 때문에 멀티 스레드 환경에서 스레드 세이프 하지 않습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;arraylist와-vector의-차이는&quot;&gt;ArrayList와 Vector의 차이는?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ArrayList와 Vector의 차이는 동기화 제공해주는 자료구조의 차이라고 생각합니다. Vector는 멀티스레드 환경에서 스레드 세이프하고, ArrayList는 스레드세이프 하지 않습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;treemap과-treeset의-차이는&quot;&gt;TreeMap과 TreeSet의 차이는?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TreeSet과 TreeMap은 둘다 Red Black Tree를 기반으로 이루어져 있습니다. 가장 큰 차이라고 하면 Set과 Map의 차이&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;red black tree는 balanced binary search tree의 한 종류 로써 BST에서 발생하는 불균형 문제를 색깔을 통해서 자체적으로 해결하는 자료구조 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;garbage-collection이란-무엇인가요&quot;&gt;Garbage Collection이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;가비지 콜렉션이랑 자동 메모리 관리를 구현한 것입니다. 더 이상 사용하지 않는 객체들이 차지하는 Heap 메모리를 관리한다고 알고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;객체-지향-프로그래밍oop&quot;&gt;객체 지향 프로그래밍(OOP)&lt;/h1&gt;

&lt;h3 id=&quot;객체-지향-프로그래밍이란-무엇인가요&quot;&gt;객체 지향 프로그래밍이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;객체 지향 프로그래밍이란 데이터와 프로세스를 동일한 모듈인 객체에 위치하도록 만들어 객체 간의 협력을 통해서 프로그래밍하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;절차-지향-프로그래밍이란-무엇인가요&quot;&gt;절차 지향 프로그래밍이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;절차 지향 프로그래밍이란 데이터와 프로세스를 별도의 모듈에 위치시키고 위에서부터 순차적으로 실행하는 프로그래밍 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;객체-지향의-3대-특징인-캡슐화-상속-다형성에-대해서-설명해주세요&quot;&gt;객체 지향의 3대 특징인 캡슐화, 상속, 다형성에 대해서 설명해주세요&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;캡슐화란 데이터와 프로세스를 하나의 객체에 위치하도록 만드는 것을 말한다.&lt;/strong&gt; 이를 통해 객체는 자율적으로 다른 객체들과 협력할 수 있는 객체가 되며 자연스레 시스템의 결합도는 떨어지고 응집도는 올라가게 된다. 이의 결과로서 시스템 전체는 유지보수하기 쉬워지고 추후 변경에 유연하게 대처할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상속이란 부모 객체의 특징을 그대로 물려받는 것을 의미하고, 자바에서는 인터페이스 상속과 클래스 상속으로 나뉜다.&lt;/strong&gt; 이를 통해 모듈의 재사용성이 높아지고, 다형성을 구현할 수 있다. 하지만 무분별한 상속의 남용은 시스템의 결합도를 올려 추후 변경에 유연하게 대응하지 못하기 때문에 자제해야한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;객체지향에서 다형성이란 같은 요청으로부터 응답이 객체의 타입에 따라 다르게 나타나는 것을 의미합니다.&lt;/strong&gt; 이를 통해 객체지향은 더 유연한 설계를 가질 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;object와-class의-차이는-무엇인가요&quot;&gt;Object와 Class의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Class는 시스템의 정적인 구성요소를 나타내는 것이구요, Object는 클래스의 인스턴스로써 시스템의 동적인 구성 요소&lt;/strong&gt;를 나타냅니다.&lt;/p&gt;

&lt;h3 id=&quot;추상화란-무엇인가요&quot;&gt;추상화란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추상화란 특정 개념이나 개체를 보았을 때 특정 관점에서 관심있거나 중요한 부분만 추려내는 작업을 의미합니다.&lt;/strong&gt; 즉, OOP에서 중요한 정보만 객체의 인터페이스로써 표시하고 구현 세부 정보를 숨길 수 있는 OOP의 매우 중요한 기능입니다.&lt;/p&gt;

&lt;h3 id=&quot;디자인-패턴이란-무엇인가요&quot;&gt;디자인 패턴이란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;소프트웨어를 설계할 때 특정 문맥에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 수 있는 설계 패턴&lt;/strong&gt;을 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;singleton-pattern에-대해서-설명해주세요&quot;&gt;Singleton Pattern에 대해서 설명해주세요.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Singleton 패턴이란 시스템에서 인스턴스가 오직 1개만 생성되어야 하는 경우에 사용되는 패턴입니다. 하지만 동시성 문제를 꼭 고려&lt;/strong&gt;해야만 합니다.&lt;/p&gt;

&lt;p&gt;자바와 스프링의 싱글톤 차이점은, 싱글톤 객체의 생명주기가 다르다는 것입니다. &lt;strong&gt;자바에서 싱글톤 객체의 범위는 클래스 로더가 기준이지만, 스프링에서는 어플리케이션 컨텍스트가 기준이 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스프링에서 빈을 등록할 때 범위(scope)를 지정할 수 잇는데 디폴트가 Singleton이고, prototype, request, session 등이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;prototype: 컨테이너에 빈을 요청할 때마다 매번 새로운 객체를 만드는 범위를 의미합니다.&lt;/li&gt;
  &lt;li&gt;request: HTTP 요청 하나당 하나의 객체를 만드는 범위를 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;proxy-pattern에-대해서-설명해주세요&quot;&gt;Proxy Pattern에 대해서 설명해주세요.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프록시 패턴이란 특정 객체를 대신해서 프록시 객체가 해당 역할을 수행해주는 것을 의미합니다.(다형성)&lt;/strong&gt; 특정 인터페이스를 상속받는 A 클래스와 Proxy 클래스가 존재하고 Proxy 클래스 내부적으로 A 객체를 사용한다면 인터페이스의 특정 메소드 명세를 사용 했을 때 프록시처럼 동작하게 만들 수 있겠군!&lt;/p&gt;

&lt;h3 id=&quot;association-vs-composition-vs-aggregation의-차이는-무엇인가요&quot;&gt;Association vs Composition vs Aggregation의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;Associaton의 부분 집합으로 Aggregation과 Composition이 존재한다.&lt;/p&gt;

&lt;p&gt;Composition은 A클래스에서 B를 Composition 한다고 했을 때 A가 죽으면 B도 죽는다.&lt;/p&gt;

&lt;p&gt;Aggregation은 A클래스에서 B를 Aggregation 한다고 했을 때 A가 죽어도 B는 죽지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;decorator-pattern에-대해서-설명해주세요&quot;&gt;Decorator Pattern에 대해서 설명해주세요&lt;/h3&gt;

&lt;p&gt;데코레이터 패턴은 프록시 패턴과 구현 방법은 비슷하지만 프록시 패턴은 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달하는 반면 &lt;strong&gt;데코레이터 페턴은 클라이언트가 받는 반환값에 장식을 덧입힌다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;특정 인터페이스를 상속받는 A 클라스와 Decorator 클래스가 존재하고 Decorator 클래스 내부에서 A 클래스 객체를 사용한다면 인터페이스의 특정 메소드 명세를 사용 했을 때 A 클라스 객체의 반환값에 추가적으로 장식을 덧 붙일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;adapter-pattern에-대해서-설명해주세요&quot;&gt;Adapter Pattern에 대해서 설명해주세요.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;어댑터 패턴은 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴입니다.&lt;/strong&gt; 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해줍니다.&lt;/p&gt;

&lt;h3 id=&quot;template-method-pattern에-대해서-설명해주세요&quot;&gt;Template Method Pattern에 대해서 설명해주세요.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;템플릿 메서드 패턴(Template Method Pattern)이란 알고리즘의 구조를 바꾸지 않고 서브클래스에서 알고리즘의 특정 단계를 재정의하는 것을 의미한다. 즉, 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ex) Pinpoint의 Checker Domain에서 자주 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;strategy-pattern에-대해서-설명해주세요&quot;&gt;Strategy Pattern에 대해서 설명해주세요.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Strategy Pattern이란 전략 객체를 통해서 알고리즘의 구조를 바꿀 수 있는 디자인 패턴을 의미합니다.&lt;/strong&gt; Strategy 인터페이스를 구성하고 이를 구현하는 StrategyA, StrategyB의 구현체를 다르게 함으로써 전략 패턴을 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;객체-지향-설계-5원칙은-무엇인가요&quot;&gt;객체 지향 설계 5원칙은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;객체 지향 설계 5원칙은 SOLID원칙이라고 불리기도 하는데요, &lt;strong&gt;시스템의 결합도는 낮추고 응집도를 높이는 고전 원칙을 객체 지향 관점에서 5가지 원칙으로 재정립&lt;/strong&gt; 한 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;단일 책임 원칙(Single Resposibility, SRP)&lt;/strong&gt;: 한 클래스는 하나의 책임만 가지며 그 책임을 완전히 캡슐화해야 한다는 원칙입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;개방 폐쇄 원칙(Open Closed Principle, OCP)&lt;/strong&gt;: 소프트웨어 요소(메서드, 클래스, 모듈)는 확장에 대해 열려 있어야 하고, 수정(변경)에 대해서는 닫혀 있어야 한다는 원칙입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;리스코프 치환 원칙(Liskov Substitution Principle, LSP)&lt;/strong&gt;: 서브 클래스의 인스턴스는 슈퍼 클래스의 인스턴스로 치환할 수 있어야 한다는 원칙입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터페이스 분리 원칙(Interface Separation Principle, ISP)&lt;/strong&gt;: 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;의존 역전 원칙(Dependency Inversion Principle, DIP)&lt;/strong&gt;: 특정 소프트웨어 요소를 개발하면서 자신보다 변하기 쉬운 것에 의존하지 말라는 원칙입니다. 즉, 추상적인 것에 의존하라는 원칙입니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/11/NAVER-Interview-Preparation-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/11/NAVER-Interview-Preparation-3.html</guid>
        
        <category>Java</category>
        
        <category>OOP</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 2일차] Spring Framework &amp;&amp; Database</title>
        <description>&lt;h1 id=&quot;spring-framework&quot;&gt;Spring Framework&lt;/h1&gt;

&lt;h3 id=&quot;spring을-많이-공부하셨다고-했는데-spring-framework가-무엇인지-저희에게-설명해-주실-수-있나요&quot;&gt;Spring을 많이 공부하셨다고 했는데, Spring Framework가 무엇인지 저희에게 설명해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;스프링 프레임워크란 자바를 위한 오픈소스 애플리케이션 프레임워크로서 &lt;strong&gt;자바 기반 엔터프라이즈 애플리케이션 개발을 위해 다양한 서비스를 제공해주는 프레임워크&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-framework의-특징은-무엇인가요&quot;&gt;Spring Framework의 특징은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;Spring Framework에는 여러 가지 특징이 존재하지만 대표적인 특징을 뽑자면 &lt;strong&gt;IoC, AOP, PSA&lt;/strong&gt;라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC란 Inversion of Control의 줄임말으로 개발자가 작성한 프로그램의 제어권이 개발자가 아닌 프레임워크에 넘어가 스프링에서 사용자의 코드를 호출하는 것을 말합니다.&lt;/strong&gt; 이는 사실 Spring Framework만의 특징은 아니고, 많은 프로그램들이 IoC를 적용하고 있습니다. &lt;strong&gt;IoC는 DI와 DL에 의해 구현되는데 DI는 클래스 및 계층간에 필요한 의존관계를 빈 설정 정보를 바탕으로 IoC Container가 자동으로 연결해주는 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP란 Aspect Oriented Programming의 줄임말로 여러 모듈에서 공통적으로 사용하는 기능을 추출하여 핵심 로직에 영향을 끼치지 않게 공통 기능을 끼워 넣는 개발 형태를 의미합니다.&lt;/strong&gt; AOP의 사용 예로는 로깅, 트랜잭션, 보안 등이 있습니다. (사실 이는 자바의 상속이나 합성을 이용해서 구현할 수 있지만, 프로그래머가 작성하는 클래스간의 결합도가 높아진다는 측면에서 좋지는 않다고 생각합니다.) (컴파일 타임, 로드 타임, 런타임 등에서 AOP를 적용 가능하다고 알고 있습니다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PSA란 Portable Service Abstraction의 줄임말로 추상화 계층을 사용해서 특정 기술을 내부에 숨기고 개발자에게 편의성을 제공하며 제공되는 기술을 다른 기술 스택으로 간편하게 바꿀 수 있는 확장성을 갖고 있는 것이 PSA입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-ioc-conatiner에-대해서는-알고-있나요&quot;&gt;그렇다면 IoC Conatiner에 대해서는 알고 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IoC 컨테이너란 Bean 즉, IoC Container에서 관리하는 객체의 생성과 관계설정, 사용, 제거 등의 전체 라이프 사이클을 관리해주는 작업을 하는 컨테이너를 IoC 컨테이너라고 부릅니다.&lt;/strong&gt; IoC Container의 대표적인 명세는 BeanFactory인데 요즘은 이를 상속하는 ApplicationContext를 사용하는 추세입니다. ApplicationContext는 Bean Factory의 기능 뿐만 아니라, 메세지 다국화, 이벤트 발행 기능, 리소스 로딩 기능 등의 여러 기능을 명세하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-ioc-container의-bean-등록-방법에는-무엇이-있는가&quot;&gt;Spring IoC Container의 Bean 등록 방법에는 무엇이 있는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;xml 설정파일을 이용해서 Bean 등록, @Annotatation을 통해 Bean 등록하는 방법 등이 존재합니다.&lt;/strong&gt; 하지만 Annotation 기반의 Bean 등록시에는 Component Scan을 꼭 필요로 하는데요, Component Scan을 직접 등록해 줄 수도 있겠지만 Spring Boot는 Component Scan까지 자동으로 구성해줘, 너무 잘 사용하고 있습니다!!!&lt;/p&gt;

&lt;h3 id=&quot;spring-boot-이야기를-하셨는데-spring-boot와-spring-framework의-차이점은-무엇인가요&quot;&gt;Spring Boot 이야기를 하셨는데, Spring Boot와 Spring Framework의 차이점은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스프링 부트와 스프링 프레임워크의 가장 큰 차이는 Auto Configuration의 차이인 것 같습니다.&lt;/strong&gt; 한 예로써 Spring MVC 프로젝트를 Spring Framework 기반으로 구성을 한다면, 컴포넌트 스캔, bean 설정, Dispatcher Servlet 설정, View Resolver, JDBC 설정, 웹 jar 설정 등의 다양한 설정을 해야하지만 이를 Spring Boot 기반으로 구성함으로써 초기 개발 환경 세팅에 걸리는 리소스를 많이 아낄 수 있다고 생각합니다.&lt;/p&gt;

&lt;p&gt;스프링 부트 프로젝트를 생성할 시 스프링 부트에서는 내장 서블릿 컨테이너인 톰캣(tomcat)이 자동적으로 설정됩니다.&lt;/p&gt;

&lt;h3 id=&quot;web-server-vs-web-application-server의-차이를-아시나요&quot;&gt;Web Server vs Web Application Server의 차이를 아시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Web Server는 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠인 HTML, image file, css 등을 제공하는 서버&lt;/strong&gt;를 말합니다. Web Server의 예로는 Apach Server, Nginx 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Web Application Server는 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server&lt;/strong&gt;를 말합니다. HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어입니다. WAS는 Web Container 혹은 Servlet Container라고도 불리며 대표적인 예로는 Tomcat, Jetty 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Web Server와 WAS를 분리하는 이유는 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 분리합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-bean을-주입받는-방법에는-무엇이-있나요&quot;&gt;Spring Bean을 주입받는 방법에는 무엇이 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;@Autowired 애노테이션으로 필드에 주입받을 수도 있구요, 생성자를 통해서 주입 받을 수 있고, setter를 통해서 주입 받을 수 있습니다.&lt;/strong&gt; Bean이 주입 될 때 같은 이름 및 같은 타입의 빈이 존재한다면 @Primary 애노테이션으로 우선순위 설정할 수 있고, @Qulifier 애노테이션으로 Bean 이름을 통해서 주입 받을 수 있고, 해당 타입의 빈을 모두 List를 통해서 주입 받을 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;database-system&quot;&gt;Database System&lt;/h1&gt;

&lt;h3 id=&quot;데이터베이스를-사용하는-이유는-무엇인가요&quot;&gt;데이터베이스를 사용하는 이유는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;데이터베이스가 등장하기 전에 데이터는 파일 시스템을 이용하여 관리되었습니다. &lt;strong&gt;이로 인해 데이터의 종속성 문제와 무결성 문제가 발생하였으며 이를 해결하기 위한 데이터베이스 시스템이 등장하게 되었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터베이스의-특징은-무엇인가요&quot;&gt;데이터베이스의 특징은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;데이터베이스의 특징은 크게 5가지로 나눌 수 있고 이는 &lt;strong&gt;데이터의 독립성, 무결성, 보안성, 일관성, 중복 최소화&lt;/strong&gt;를 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;primary-key-foreign-key-entity-relation-모델에-대해서-설명해주세요&quot;&gt;Primary Key, Foreign Key, Entity Relation 모델에 대해서 설명해주세요&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Primary Key는 테이블에서 각 Row를 유일하게 구분하는 Column을 의미&lt;/strong&gt;하구요, &lt;strong&gt;Foreign Key는 하나의 테이블에 있는 Column중 다른 테이블의 행(row)을 식별할 수 있는 키&lt;/strong&gt;를 말한다. &lt;strong&gt;Entity Relation은 데이터베이스 설계에서 엔티티간의 관계를 표시해주기 위한 모델&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;쿼리-문제&quot;&gt;쿼리 문제&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/interview/naver-interview-preparation2-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테이블 생성 - 테이블 명은 ‘student’로 할 것&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CREATE TABLE student (name VARCHAR(10) NOT NULL, num INT NOT NULL, pnum VARCHAR(20) NOT NULL, address VARCHAR(10) NOT NULL, email VARCHAR(10) NOT NULL, sec VARCHAR(2) NOT NULL, PRIMARY KEY(num));&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;테이블 수정 - 대학교(university)를 추가하고 null 값을 허용하게 하라&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ALTER TABLE student ADD university VARCHAR(10) NULL;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 삽입 - 임의의 데이터 2개를 추가하라&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;INSERT INTO student (name, num, pnum, address, email, sex) VALUES (“홍길동”, 11, 010-1111-1111, “서울시”, “kim@com”, “여”);&lt;/li&gt;
  &lt;li&gt;INSERT INTO student (name, num, pnum, address, email, sex) VALUES (“홍길동”, 11, 010-1111-1111, “서울시”, “kim@com”, “여”);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 수정 - 홍길동의 핸드폰 번호를 010-5555-5555로 변경하라&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UPDATE student SET pnum=”010-5555-5555” WHERE name=”홍길동”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 검색&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;전체 자료 조회 : SELECT * FROM student;&lt;/li&gt;
  &lt;li&gt;학번이 3번보다 이상인 사람들의 이름과 학번을 조회 : SELECT name, num FROM student WHERE num &amp;gt;= 3 ORDER BY num DESC;&lt;/li&gt;
  &lt;li&gt;김자로 시작하는 학생의 이름을 조회 : SELECT name FROM student WHERE name LIKE ‘김%’;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;ORDER BY xx DESC (내림차순)&lt;/li&gt;
    &lt;li&gt;ORDER BY xx ASC (오름차순)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;데이터 삭제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 자료(행) : DELETE FROM students;&lt;/li&gt;
  &lt;li&gt;특정 자료(행) : DELETE FROM students WHERE name=”홍길동”;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;join이란-무엇인가&quot;&gt;Join이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Join 이란 2개 이상의 테이블에서 조건에 맞는 데이터를 추출하기 위하여 사용하는 쿼리문&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;조인에는-어떠한-종류들이-있는가&quot;&gt;조인에는 어떠한 종류들이 있는가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Inner Join: 2개 이상의 테이블에서 교집합만을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A INNER JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Left Join: 2개 이상의 테이블에서 from에 해당하는 부분을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A LEFT JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Right Join : 2개 이상의 테이블에서 from과 join하는 테이블에 해당하는 부분을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A RIGHT JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Outer Join : 아웃터 조인 또는 풀 조인이라고 불림, 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A OUTER JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인덱스index란-무엇인가요&quot;&gt;인덱스(Index)란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;데이터베이스의 데이터를 빠르게 검색 및 정렬하기 위해서 인덱스를 두는 방법&lt;/strong&gt;입니다. (일반적인 책 뒤에 있는 색인을 보는 방법과 비슷합니다.)&lt;/p&gt;

&lt;h3 id=&quot;dbms에서-사용하고-잇는-index-자료구조는-무엇인가요&quot;&gt;DBMS에서 사용하고 잇는 Index 자료구조는 무엇인가요??&lt;/h3&gt;

&lt;p&gt;대표적으로 B+ Tree 인덱스 알고리즘과, Hash 인덱스 알고리즘이 존재하는 것으로 알고 있습니다. &lt;strong&gt;B+ Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이고, Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;hash란-무엇인가요&quot;&gt;Hash란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;해시란 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값입니다.&lt;/strong&gt; 이렇게 매핑 하는 함수를 해시 함수라고 하며 이로부터 얻어진 값을 해시 값, 해시 코드, 짧게 말해서 해시라고도 합니다.&lt;/p&gt;

&lt;p&gt;해시의 단점은 정렬할 수 없고, 순서에 따라 값을 가져올 수도 없기 때문에 &lt;u&gt;상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash와 어울리지 않는다는 것이 단점&lt;/u&gt;입니다. 또한 Hash Function의 의존도가 높고, 공간 효율성이 떨어진다는 점이 단점입니다. 하지만 평균 데이터 처리의 시간복잡도는 O(1)(상수 시간)에 가깝기 때문에 사용하기 빠릅니다.&lt;/p&gt;

&lt;h3 id=&quot;트랜잭션transaction이란-무엇인가요&quot;&gt;트랜잭션(Transaction)이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;트랜잭션transaction의-성질은-무엇인가요&quot;&gt;트랜잭션(Transaction)의 성질은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;트랜잭션의 성질은 ACID라고 불리는 &lt;strong&gt;원자성(Atomicity), 일관성(Consistency), 독립성(Isolation), 지속성(Durability)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원자성은 트랜잭션의 연산이 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다라는 것을 의미합니다.&lt;/li&gt;
  &lt;li&gt;일관성은 트랜잭션이 그 실행을 성공적으로 완료된 다음의 상태에서도 데이터베이스느 언제나 일관성 있는 데이터를 보장해야 한다는 것을 의미합니다.&lt;/li&gt;
  &lt;li&gt;독립성은 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다는 것을 의미합니다.&lt;/li&gt;
  &lt;li&gt;지속성은 성공적으로 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다는 것을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정규화는-무엇인가요&quot;&gt;정규화는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;정규화란 데이터베이스에서 중복을 최소화하고 갱신 이상을 없애기 위해 하나의 테이블을 둘 이상으로 분리하는 작업&lt;/strong&gt;이다. 갱신 이상에는 삽입 이상, 삭제 이상, 수정 이상 등을 포함한다.&lt;/p&gt;

&lt;h3 id=&quot;정규형에는-무엇이-있는가&quot;&gt;정규형에는 무엇이 있는가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1차 정규형: 각 로우마다 컬럼의 값이 1개씩만 있어야 하는 형태를 의미합니다. 이를 컬럼이 원자값(Atomic Value)를 갖는다고 합니다.
    &lt;ul&gt;
      &lt;li&gt;각 로우의 컬럼이 값이 1개 이상일 경우 1차 정규형을 만족하지 못한다고 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2차 정규형: &lt;strong&gt;주키가 합성키&lt;/strong&gt;며 부분종속(기본키 중에 특정 컬럼에만 종속된 컬럼)이 없어야 한다는 것입니다. 테이블의 모든 컬럼이 완전 함수적 종속을 만족하는 것입니다.
    &lt;ul&gt;
      &lt;li&gt;주키가 합성키이며, 기본키 중에서 특정 컬럼에만 종속된 컬럼이 있을 경우 2차 정규형을 만족하지 못한다고 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3차 정규형: 어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다. 즉, X-&amp;gt;Y, Y-&amp;gt;Z의 경우에 의해서 추론될 수 있는 X-&amp;gt;Z의 종속관계가 없는 경우를 의미한다.
    &lt;ul&gt;
      &lt;li&gt;일반 컬럼이 다른 일반 컬럼에 종속되는 경우 제 3정규형을 만족하지 못한다고 볼 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BCNF 정규형: 3차 정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형입니다.
    &lt;ul&gt;
      &lt;li&gt;ex) 일반 컬럼이 후보키를 결정하는 경우에 3차 정규형을 만족하면서 BCNF는 만족하지 않는 경우이다. =&amp;gt; 테이블 분리가 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nosql이란-무엇인가요&quot;&gt;NoSQL이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는데 특화되어있으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NoSQL은 SQL보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공합니다.&lt;/li&gt;
  &lt;li&gt;단순 검색 및 추가 작업을 위한 매우 최적화된 key-value 저장 공간을 사용합니다.&lt;/li&gt;
  &lt;li&gt;빅데이터 시대에 따라 많은 양의 데이터를 효율적으로 처리하기 위해 등장하였습니다.&lt;/li&gt;
  &lt;li&gt;분산형 구조를 통해 여러 대의 서버에 분산해 저장하고, 분산시에는 데이터를 상호 복제에 특정 서버에 장애가 발생했을 때에도 데이터의 유실이나 서비스 중지가 없는 형태의 구조를 갖고 있습니다.&lt;/li&gt;
  &lt;li&gt;HBase, MongoDB 등이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/10/NAVER-Interview-Preparation-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/10/NAVER-Interview-Preparation-2.html</guid>
        
        <category>Spring</category>
        
        <category>Framework</category>
        
        <category>Database</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 1일차] 운영체제</title>
        <description>&lt;h1 id=&quot;기술-면접-준비-1일차-포스팅---운영체제&quot;&gt;기술 면접 준비 1일차 포스팅 - 운영체제&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;코어-core&quot;&gt;코어 (Core)&lt;/h2&gt;

&lt;h3 id=&quot;코어란-무엇인가요&quot;&gt;코어란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CPU의 기본 계산 단위&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;프로세스-process&quot;&gt;프로세스 (Process)&lt;/h2&gt;

&lt;h3 id=&quot;프로세스는-무엇인가요&quot;&gt;프로세스는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;프로세스란 실행 중인 프로그램을 의미하고 보조저장장치로부터 메모리에 적재되어 &lt;strong&gt;CPU의 할당을 받을 수 있는 단위&lt;/strong&gt;를 말합니다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스의-메모리-구조는-어떻게-되죠&quot;&gt;프로세스의 메모리 구조는 어떻게 되죠??&lt;/h4&gt;

&lt;p&gt;프로세스는 기본적으로 실행 코드가 저장되는 &lt;strong&gt;text 영역&lt;/strong&gt;, 전역 변수 등을 수록하는 &lt;strong&gt;data 영역&lt;/strong&gt;, 프로세스 실행 중에 동적으로 할당되는 메모리인 &lt;strong&gt;heap 영역&lt;/strong&gt;, 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 &lt;strong&gt;stack 영역&lt;/strong&gt;으로 이루어져 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스는-운영체제에-어떻게-저장-되죠&quot;&gt;프로세스는 운영체제에 어떻게 저장 되죠??&lt;/h4&gt;

&lt;p&gt;프로세스는 &lt;strong&gt;PCB&lt;/strong&gt;라는 자료구조를 통해서 저장되어집니다. PCB란 Process Control Block의 줄임말으로 특정 &lt;strong&gt;프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조&lt;/strong&gt;이고 이는 &lt;u&gt;PID, Process Status, PC, CPU 레지스터, CPU 스케줄링 정보&lt;/u&gt; 등으로 구성되어 집니다.&lt;/p&gt;

&lt;h3 id=&quot;스레드-thread&quot;&gt;스레드 (Thread)&lt;/h3&gt;

&lt;h4 id=&quot;스레드란-무엇인가요&quot;&gt;스레드란 무엇인가요?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;스레드는 프로세스의 CPU 이용을 위한 기본 단위&lt;/strong&gt;로 프로세스의 주소 공간이나 자원등을 공유해 프로세스를 여러 실행 흐름으로 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;멀티-스레딩이란-무엇인가요&quot;&gt;멀티 스레딩이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;하나의 프로세스를 다수의 실행 단위 즉, 여러개의 스레드로 구분&lt;/strong&gt;하여 프로세스의 자원을 공유해 &lt;strong&gt;처리 능력을 향상&lt;/strong&gt; 시키는 것을 멀티스레딩이라고 합니다.&lt;/p&gt;

&lt;h4 id=&quot;스택을-스레드마다-독립적으로-할당하는-이유가-있나요&quot;&gt;스택을 스레드마다 독립적으로 할당하는 이유가 있나요?&lt;/h4&gt;

&lt;p&gt;스택은 함수의 인자, 복귀 주소, 지역 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 &lt;strong&gt;스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가&lt;/strong&gt;되는 것이기 때문에 프로세스를 여러 실행 흐름으로 만들기 위해서는 스레드에 스택을 독립적으로 할당해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;pc-register를-스레드마다-독립적으로-할당하는-이유&quot;&gt;PC Register를 스레드마다 독립적으로 할당하는 이유&lt;/h4&gt;

&lt;p&gt;PC 값은 다음에 실행될 명령어의 주소를 나타내므로 &lt;strong&gt;프로세스의 개별 실행 흐름인 스레드가 독립적으로 명령어들을 실행하기 위해선 스레드에 PC 레지스터가 독립적으로 할당&lt;/strong&gt;되어야 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;멀티-스레드-multithread&quot;&gt;멀티 스레드 (MultiThread)&lt;/h2&gt;

&lt;h3 id=&quot;멀티-스레드의-장단점은-무엇인가요&quot;&gt;멀티 스레드의 장단점은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드를 통해 하나의 실행 흐름인 프로세스를 여러 개의 실행 흐름으로 만들 수 있습니다. 이를 통해 프로세스의 처리 능력 향상과 자원의 소모가 줄어드는 것을 기대할 수 있습니다. 하지만 여러 개의 스레드가 동일한 자원을 접근할 경우 경쟁 조건이 발생할 수 있으며 동기화를 신경 써줘야 합니다.&lt;/strong&gt; 스레드간의 동기화를 위한 동기화 기법들은 매우 다양하며 잘못 사용할 경우 병목 현상을 발생시킬 수 있어 이를 사용하기 위해 많은 자원이 필요하다는 것이 단점입니다.&lt;/p&gt;

&lt;h3 id=&quot;멀티-스레드와-멀티-프로세스의-차이는-무엇인가요&quot;&gt;멀티 스레드와 멀티 프로세스의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드와 멀티 프로세스의 차이는 여러 실행흐름을 프로세스를 통해서 만드느냐 아니면 프로세스 내의 스레드를 통해서 만드느냐의 차이입니다.&lt;/strong&gt; 이 두가지 기법 다 동시에 여러 작업을 수행한다는 점에서 목적은 같지만, 서로 장단점이 존재하기 때문에 개발 도메인에서 적합한지, 단점이 뭐가 있고, 장점은 뭐가 있는지, 왜 이 기법을 사용해야 하는지에 대해 팀 내에서 깊게 논의 한 후 시스템에 적용해야 한다고 생각합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스케줄러-scheduler&quot;&gt;스케줄러 (Scheduler)&lt;/h2&gt;

&lt;h3 id=&quot;프로세스-스케줄러란-무엇인가요&quot;&gt;&lt;strong&gt;프로세스 스케줄러란 무엇인가요??&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;멀티 프로세스 기법을 사용하는 시스템은 프로세스의 실행 순서를 스케줄링 해야만 합니다. 이러한 &lt;strong&gt;프로세스의 실행 순서를 스케줄링하는 도구를 프로세스 스케줄러&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로세스-스케줄러에는-어떠한-것들이-존재하죠&quot;&gt;&lt;strong&gt;프로세스 스케줄러에는 어떠한 것들이 존재하죠?&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;프로그램이 저장되어 있는 디스크에서 메모리로 프로세스 스케줄링을 담당하는 Job Schduler, CPU와 메모리 사이의 스케줄링을 담당하는 CPU Schecudler, 메모리에서 디스크로 프로세스 스케줄링을 담당하는 Swapper등이 있는걸로 알고 있습빈다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케줄러란-무엇인가요&quot;&gt;CPU 스케줄러란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Ready Queue에 있는 프로세스들을 스케줄링하는 스케줄러를 CPU 스케줄러&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케줄러의-기법에는-어떤게-있을까요&quot;&gt;CPU 스케줄러의 기법에는 어떤게 있을까요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;먼저 Ready Queue에 들어온 프로세스를 먼저 처리하는 First Come Fist Serve(FCFS) 스케줄링 기법&lt;/strong&gt;, &lt;strong&gt;CPU Burst Time이 짧은 프로세스를 먼저 처리하는 Shortest Job First(SJF) 스케줄링 기법&lt;/strong&gt;, SJF 기법 기반으로 &lt;strong&gt;새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어져 가장 짧은 프로세스를 먼저 처리하는 Shortest Remaining time First(SRT) 기법&lt;/strong&gt;, &lt;strong&gt;프로세스에 우선순위를 부여하여 우선순위가 높은 프로세스를 먼저 처리하는 Priority Schduling 기법&lt;/strong&gt;, &lt;strong&gt;프로세스에 CPU 할당 시간을 정해 놓아 CPU를 할당하는 방법인 Round Robin 기법&lt;/strong&gt; 등이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;동기와-비동기의-차이는-무엇인가요&quot;&gt;동기와 비동기의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;동기는 요청과 동시에 결과가 일어나는 경우를 동기라고 표현하고, 비동기는 요청과 결과가 동시에 일어나지 않는 경우를 비동기라고 표현한다.&lt;/p&gt;

&lt;h3 id=&quot;block과-non-block의-차이는-무엇인가요&quot;&gt;block과 non-block의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;요청에 대한 응답을 얻기 까지 다른 실행 흐름들이 기다리는 것을 blocking이라고 하고, 다른 실행 흐름이 요청에 대한 응답을 대기하지 않고 자유롭게 CPU나 메모리 등을 이용하는 상황을 non-blocking 이라고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;프로세스-동기화-process-synchronization&quot;&gt;프로세스 동기화 (Process Synchronization)&lt;/h2&gt;

&lt;h3 id=&quot;critical-section은-무엇인가요&quot;&gt;Critical Section은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역을 Critical Section&lt;/strong&gt; 이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;critical-section-problem을-해결하기-위한-조건이-무엇일까요&quot;&gt;Critical Section Problem을 해결하기 위한 조건이 무엇일까요?&lt;/h3&gt;

&lt;p&gt;Critical Section Problem을 해결하기 위한 조건은 첫 번째 &lt;strong&gt;특정 프로세스가 Critical Section을 수행하고 있다면 다른 프로세스는 이 Critical Section에 들어오지 못하게 하는 상호 배제(Mutual Exclusion)&lt;/strong&gt; 조건입니다.&lt;/p&gt;

&lt;p&gt;두 번째는 Critical Section에서 실행중인 프로세스가 없고, &lt;strong&gt;별도의 동작이 없는 프로세스들만 Critical Section 진입 후보 프로세스로서 참여할 수 있다는 조건인 Progress&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;세 번째는 &lt;strong&gt;특정 프로세스가 Ciritcal Section에 진입 신청 후 받아들여지기까지 기간이 한정되어야 함을 나타내는 Bounded Waiting&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&quot;critical-section-problem을-해결하기-위한-기법에는-무엇이-있나요&quot;&gt;Critical Section Problem을 해결하기 위한 기법에는 무엇이 있나요?&lt;/h3&gt;

&lt;p&gt;첫 번째는 &lt;strong&gt;하드웨어 기반 해결책인 Lock&lt;/strong&gt;입니다. Critical Section에 진입하기전에 Lock을 얻고, Critical Section에서 빠져 나올 때 Lock을 방출함으로써 프로세스간에 동기화를 유지합니다.&lt;/p&gt;

&lt;p&gt;두 번째는 &lt;strong&gt;Semaphores 입니다. 소프트웨어 상에서 Ciritcal Section 문제를 해결하기 위한 동기화 도구&lt;/strong&gt;이며, 두 개의 프로세스 사이에서 동기화를 유지할 수 있는 이진 세마포와 프로세스 세개 이상의 프로세스 사이에서 동기화를 유지할 수 있는 카운팅 세마포가 있습니다.&lt;/p&gt;

&lt;p&gt;세 번째는 &lt;strong&gt;모니터 입니다. 모니터는 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메모리-관리-전략&quot;&gt;메모리 관리 전략&lt;/h2&gt;

&lt;h3 id=&quot;swapping-이란-무엇인가요&quot;&gt;Swapping 이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Swapping 이란 메모리의 관리를 위해 사용되는 기법&lt;/strong&gt;입니다. CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치(하드디스크)로 내보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 과정을 swap (스왑시킨다) 이라 한다. &lt;strong&gt;주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조 기억장치로 내보내는 과정을 swap-out&lt;/strong&gt; 이라 한다. swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 Swapping이 시작된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;swapping을-하면서-발생하는-문제점에-대해서-알고-있나요&quot;&gt;Swapping을 하면서 발생하는 문제점에 대해서 알고 있나요?&lt;/h3&gt;

&lt;p&gt;대표적으로 &lt;strong&gt;단편화(Fragmentation) 문제&lt;/strong&gt;를 들 수 있습니다. 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 사이에 사용 하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데 이를 단편화라고 합니다.&lt;/p&gt;

&lt;p&gt;단편화의 종류는 크게 외부 단편화와 내부 단편화로 나눌 수 있습니다. &lt;strong&gt;외부 단편화란 메모리에서 프로세스 사이 사이 남는 공간들을 의미하는 것이고, 내부 단편화란 프로세스가 사용하는 메모리 공간에서 남는 부분을 의미하는 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-외부-단편화를-해소하기-위한-방법은-무엇이-있을까요&quot;&gt;그렇다면 외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;압축&lt;/strong&gt;이 있을 것 같습니다. 외부 단편화를 해소하기 위해 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아, 자유 공간을 확보하는 방법론 이지만, &lt;u&gt;작업효율이 좋지 않아 잘 사용하지 않습니다.&lt;/u&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-또-다른-외부-단편화-문제를-해결할-수-있는-방법은-무엇인가요&quot;&gt;그렇다면 또 다른 외부 단편화 문제를 해결할 수 있는 방법은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;대표적인 예로는 메모리 공간이 연속적이어야 한다는 제약을 없애는 &lt;strong&gt;페이징 기법&lt;/strong&gt;을 들 수 있습니다. &lt;strong&gt;물리 메모리를 Frame 이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이러한 페이징 기법을 통해 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;즉, 하나의 프로세스가 사용하는 공간을 여러개의 페이지로 나뉘어서 논리 메모리에서 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장하는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하지만 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있다고 생각합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션이란-무엇입니까&quot;&gt;세그멘테이션이란 무엇입니까?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;세그멘테이션은 프로세스를 물리적 크기의 단위가 아닌 논리적 내용의 단위인 세그먼트로 분할하고 메모리를 할당하며 주소를 변환하는 기법이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 분할해 둘 수 없고, &lt;strong&gt;메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세그먼트의 단위가 다르기 때문에 메모리에 서로 다른 크기를 가진 여러 세그먼트를 저장할 시 외부 단편화가 생기는 문제점이 존재해 잘 사용하지는 않습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;가상-메모리-virtual-memory&quot;&gt;가상 메모리 (Virtual Memory)&lt;/h2&gt;

&lt;h3 id=&quot;가상-메모리란-무엇인가&quot;&gt;가상 메모리란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;가상 메모리란 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법&lt;/strong&gt;이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;왜-가상-메모리가-나오게-되었는가&quot;&gt;왜 가상 메모리가 나오게 되었는가?&lt;/h3&gt;

&lt;p&gt;실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 또한 멀티 프로세스상에서 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생했기 때문에 이를 해결하기 위해 가상 메모리 기법이 나오게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;가상-메모리를-통해서-우리는-어떤-장점을-얻을-수-있는가&quot;&gt;가상 메모리를 통해서 우리는 어떤 장점을 얻을 수 있는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로그램의 일부분만 메모리에 올릴 수 있게 되었고 이를 통해 물리 메모리 크기에 제약을 받지 않게 되었습니다. 고로 더 많은 프로그램을 동시에 실행할 수 있게 되었다. 또한 swap에 필요한 입출력이 줄었기 때문에 프로그램들이 빠르게 실행된다는 장점을 가지고 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;가상-메모리는-어떻게-동작하는가&quot;&gt;가상 메모리는 어떻게 동작하는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다.&lt;/strong&gt; 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가상 주소 공간이란 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간&lt;/strong&gt;이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 현재 직접적으로 필요치 않는 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 합니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다&lt;/strong&gt;. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;요구-페이징-demand-paging이란-무엇인가&quot;&gt;요구 페이징 (Demand Paging)이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며 가상 메모리 시스템에서 많이 사용된다.&lt;/strong&gt; 요구 페이징을 사용하는 가상 메모리에서는 &lt;strong&gt;실행과정에서 필요해질 때 페이지들이 적재된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘이란-무엇인가&quot;&gt;페이지 교체 알고리즘이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;요구 페이징에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, &lt;strong&gt;프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 되는 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘의-순서는-어떻게-되는가&quot;&gt;페이지 교체 알고리즘의 순서는 어떻게 되는가?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;디스크에서 필요한 페이지의 위치를 찾는다.&lt;/li&gt;
  &lt;li&gt;빈 페이지 프레임을 찾는다.
    &lt;ul&gt;
      &lt;li&gt;페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.&lt;/li&gt;
      &lt;li&gt;희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.&lt;/li&gt;
  &lt;li&gt;사용자 프로세스 재 시작&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘에는-어떠한-것들이-있는가&quot;&gt;페이지 교체 알고리즘에는 어떠한 것들이 있는가?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;FIFO 페이지 교체 : 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다.&lt;/li&gt;
  &lt;li&gt;최적 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 알고리즘이다.&lt;/li&gt;
  &lt;li&gt;LRU (Least Recently Used) 페이지 교체 : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. (최적 알고리즘 근사 알고리즘)&lt;/li&gt;
  &lt;li&gt;LFU (Least Frequently Used) 페이지 교체 : 참조 횟수가 가장 적은 페이지를 교체하는 방법이다.&lt;/li&gt;
  &lt;li&gt;MFU (Most Frequently Used) 페이지 교체 : 참조 횟수가 가장 많은 페이지를 교체하는 방법이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;캐시cache&quot;&gt;캐시(Cache)&lt;/h2&gt;

&lt;h3 id=&quot;캐시-메모리란-무엇인가&quot;&gt;캐시 메모리란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;캐시 메모리란 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;캐시-메모리에서-가장-신경써야-하는-문제는-무엇인가&quot;&gt;캐시 메모리에서 가장 신경써야 하는 문제는 무엇인가?&lt;/h3&gt;

&lt;p&gt;캐시 메모리의 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 예측할 수 있어야 한다. &lt;strong&gt;즉, 적중률(hit rate)을 극대화 시켜야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;적중률hit-rate을-극대화-시키기-위해-어떻게-해야-하는가&quot;&gt;적중률(hit rate)을 극대화 시키기 위해 어떻게 해야 하는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;적중률을 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용한다.&lt;/strong&gt; 즉, Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.&lt;/p&gt;

&lt;h3 id=&quot;지역성은-어떻게-나뉘는가&quot;&gt;지역성은 어떻게 나뉘는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;데이터 지역성은 대표적으로 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉘고 이는 다음과 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 26 Nov 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/11/26/NAVER-Interview-Preparation-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/11/26/NAVER-Interview-Preparation-1.html</guid>
        
        <category>Operating-System</category>
        
        
        <category>Interview</category>
        
      </item>
    
  </channel>
</rss>