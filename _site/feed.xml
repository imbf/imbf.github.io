<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Green Frog Developer</title>
    <description>객체지향을 사랑하고 클린코드에 관심이 많습니다. 질문을 좋아하고 생각하는 것을 좋아합니다.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 10 Dec 2020 20:34:57 +0900</pubDate>
    <lastBuildDate>Thu, 10 Dec 2020 20:34:57 +0900</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>[기술 면접 준비 - 2일차] Spring Framework &amp;&amp; Database</title>
        <description>&lt;h1 id=&quot;spring-framework&quot;&gt;Spring Framework&lt;/h1&gt;

&lt;h3 id=&quot;spring을-많이-공부하셨다고-했는데-spring-framework가-무엇인지-저희에게-설명해-주실-수-있나요&quot;&gt;Spring을 많이 공부하셨다고 했는데, Spring Framework가 무엇인지 저희에게 설명해 주실 수 있나요?&lt;/h3&gt;

&lt;p&gt;스프링 프레임워크란 자바를 위한 오픈소스 애플리케이션 프레임워크로서 &lt;strong&gt;자바 기반 엔터프라이즈 애플리케이션 개발을 위해 다양한 서비스를 제공해주는 프레임워크&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-framework의-특징은-무엇인가요&quot;&gt;Spring Framework의 특징은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;Spring Framework에는 여러 가지 특징이 존재하지만 대표적인 특징을 뽑자면 &lt;strong&gt;IoC, AOP, PSA&lt;/strong&gt;라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC란 Inversion of Control의 줄임말으로 개발자가 작성한 프로그램의 제어권이 개발자가 아닌 프레임워크에 넘어가 스프링에서 사용자의 코드를 호출하는 것을 말합니다.&lt;/strong&gt; 이는 사실 Spring Framework만의 특징은 아니고, 많은 프로그램들이 IoC를 적용하고 있습니다. &lt;strong&gt;IoC는 DI와 DL에 의해 구현되는데 DI는 클래스 및 계층간에 필요한 의존관계를 빈 설정 정보를 바탕으로 IoC Container가 자동으로 연결해주는 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP란 Aspect Oriented Programming의 줄임말로 여러 모듈에서 공통적으로 사용하는 기능을 추출하여 핵심 로직에 영향을 끼치지 않게 공통 기능을 끼워 넣는 개발 형태를 의미합니다.&lt;/strong&gt; AOP의 사용 예로는 로깅, 트랜잭션, 보안 등이 있습니다. (사실 이는 자바의 상속이나 합성을 이용해서 구현할 수 있지만, 프로그래머가 작성하는 클래스간의 결합도가 높아진다는 측면에서 좋지는 않다고 생각합니다.) (컴파일 타임, 로드 타임, 런타임 등에서 AOP를 적용 가능하다고 알고 있습니다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PSA란 Portable Service Abstraction의 줄임말로 추상화 계층을 사용해서 특정 기술을 내부에 숨기고 개발자에게 편의성을 제공하며 제공되는 기술을 다른 기술 스택으로 간편하게 바꿀 수 있는 확장성을 갖고 있는 것이 PSA입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-ioc-conatiner에-대해서는-알고-있나요&quot;&gt;그렇다면 IoC Conatiner에 대해서는 알고 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IoC 컨테이너란 Bean 즉, IoC Container에서 관리하는 객체의 생성과 관계설정, 사용, 제거 등의 전체 라이프 사이클을 관리해주는 작업을 하는 컨테이너를 IoC 컨테이너라고 부릅니다.&lt;/strong&gt; IoC Container의 대표적인 명세는 BeanFactory인데 요즘은 이를 상속하는 ApplicationContext를 사용하는 추세입니다. ApplicationContext는 Bean Factory의 기능 뿐만 아니라, 메세지 다국화, 이벤트 발행 기능, 리소스 로딩 기능 등의 여러 기능을 명세하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-ioc-container의-bean-등록-방법에는-무엇이-있는가&quot;&gt;Spring IoC Container의 Bean 등록 방법에는 무엇이 있는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;xml 설정파일을 이용해서 Bean 등록, @Annotatation을 통해 Bean 등록하는 방법 등이 존재합니다.&lt;/strong&gt; 하지만 Annotation 기반의 Bean 등록시에는 Component Scan을 꼭 필요로 하는데요, Component Scan을 직접 등록해 줄 수도 있겠지만 Spring Boot는 Component Scan까지 자동으로 구성해줘, 너무 잘 사용하고 있습니다!!!&lt;/p&gt;

&lt;h3 id=&quot;spring-boot-이야기를-하셨는데-spring-boot와-spring-framework의-차이점은-무엇인가요&quot;&gt;Spring Boot 이야기를 하셨는데, Spring Boot와 Spring Framework의 차이점은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스프링 부트와 스프링 프레임워크의 가장 큰 차이는 Auto Configuration의 차이인 것 같습니다.&lt;/strong&gt; 한 예로써 Spring MVC 프로젝트를 Spring Framework 기반으로 구성을 한다면, 컴포넌트 스캔, bean 설정, Dispatcher Servlet 설정, View Resolver, JDBC 설정, 웹 jar 설정 등의 다양한 설정을 해야하지만 이를 Spring Boot 기반으로 구성함으로써 초기 개발 환경 세팅에 걸리는 리소스를 많이 아낄 수 있다고 생각합니다.&lt;/p&gt;

&lt;p&gt;스프링 부트 프로젝트를 생성할 시 스프링 부트에서는 내장 서블릿 컨테이너인 톰캣(tomcat)이 자동적으로 설정됩니다.&lt;/p&gt;

&lt;h3 id=&quot;web-server-vs-web-application-server의-차이를-아시나요&quot;&gt;Web Server vs Web Application Server의 차이를 아시나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Web Server는 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠인 HTML, image file, css 등을 제공하는 서버&lt;/strong&gt;를 말합니다. Web Server의 예로는 Apach Server, Nginx 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Web Application Server는 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server&lt;/strong&gt;를 말합니다. HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어입니다. WAS는 Web Container 혹은 Servlet Container라고도 불리며 대표적인 예로는 Tomcat, Jetty 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Web Server와 WAS를 분리하는 이유는 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 분리합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-bean을-주입받는-방법에는-무엇이-있나요&quot;&gt;Spring Bean을 주입받는 방법에는 무엇이 있나요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;@Autowired 애노테이션으로 필드에 주입받을 수도 있구요, 생성자를 통해서 주입 받을 수 있고, setter를 통해서 주입 받을 수 있습니다.&lt;/strong&gt; Bean이 주입 될 때 같은 이름 및 같은 타입의 빈이 존재한다면 @Primary 애노테이션으로 우선순위 설정할 수 있고, @Qulifier 애노테이션으로 Bean 이름을 통해서 주입 받을 수 있고, 해당 타입의 빈을 모두 List를 통해서 주입 받을 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;database-system&quot;&gt;Database System&lt;/h1&gt;

&lt;h3 id=&quot;데이터베이스를-사용하는-이유는-무엇인가요&quot;&gt;데이터베이스를 사용하는 이유는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;데이터베이스가 등장하기 전에 데이터는 파일 시스템을 이용하여 관리되었습니다. &lt;strong&gt;이로 인해 데이터의 종속성 문제와 무결성 문제가 발생하였으며 이를 해결하기 위한 데이터베이스 시스템이 등장하게 되었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터베이스의-특징은-무엇인가요&quot;&gt;데이터베이스의 특징은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;데이터베이스의 특징은 크게 5가지로 나눌 수 있고 이는 &lt;strong&gt;데이터의 독립성, 무결성, 보안성, 일관성, 중복 최소화&lt;/strong&gt;를 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;primary-key-foreign-key-entity-relation-모델에-대해서-설명해주세요&quot;&gt;Primary Key, Foreign Key, Entity Relation 모델에 대해서 설명해주세요&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Primary Key는 테이블에서 각 Row를 유일하게 구분하는 Column을 의미&lt;/strong&gt;하구요, &lt;strong&gt;Foreign Key는 하나의 테이블에 있는 Column중 다른 테이블의 행(row)을 식별할 수 있는 키&lt;/strong&gt;를 말한다. &lt;strong&gt;Entity Relation은 데이터베이스 설계에서 엔티티간의 관계를 표시해주기 위한 모델&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;쿼리-문제&quot;&gt;쿼리 문제&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/interview/naver-interview-preparation2-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테이블 생성 - 테이블 명은 ‘student’로 할 것&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CREATE TABLE student (name VARCHAR(10) NOT NULL, num INT NOT NULL, pnum VARCHAR(20) NOT NULL, address VARCHAR(10) NOT NULL, email VARCHAR(10) NOT NULL, sec VARCHAR(2) NOT NULL, PRIMARY KEY(num));&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;테이블 수정 - 대학교(university)를 추가하고 null 값을 허용하게 하라&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ALTER TABLE student ADD university VARCHAR(10) NULL;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 삽입 - 임의의 데이터 2개를 추가하라&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;INSERT INTO student (name, num, pnum, address, email, sex) VALUES (“홍길동”, 11, 010-1111-1111, “서울시”, “kim@com”, “여”);&lt;/li&gt;
  &lt;li&gt;INSERT INTO student (name, num, pnum, address, email, sex) VALUES (“홍길동”, 11, 010-1111-1111, “서울시”, “kim@com”, “여”);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 수정 - 홍길동의 핸드폰 번호를 010-5555-5555로 변경하라&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UPDATE student SET pnum=”010-5555-5555” WHERE name=”홍길동”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 검색&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;전체 자료 조회 : SELECT * FROM student;&lt;/li&gt;
  &lt;li&gt;학번이 3번보다 이상인 사람들의 이름과 학번을 조회 : SELECT name, num FROM student WHERE num &amp;gt;= 3 ORDER BY num DESC;&lt;/li&gt;
  &lt;li&gt;김자로 시작하는 학생의 이름을 조회 : SELECT name FROM student WHERE name LIKE ‘김%’;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;ORDER BY xx DESC (내림차순)&lt;/li&gt;
    &lt;li&gt;ORDER BY xx ASC (오름차순)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;데이터 삭제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 자료(행) : DELETE FROM students;&lt;/li&gt;
  &lt;li&gt;특정 자료(행) : DELETE FROM students WHERE name=”홍길동”;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;join이란-무엇인가&quot;&gt;Join이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Join 이란 2개 이상의 테이블에서 조건에 맞는 데이터를 추출하기 위하여 사용하는 쿼리문&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;조인에는-어떠한-종류들이-있는가&quot;&gt;조인에는 어떠한 종류들이 있는가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Inner Join: 2개 이상의 테이블에서 교집합만을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A INNER JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Left Join: 2개 이상의 테이블에서 from에 해당하는 부분을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A LEFT JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Right Join : 2개 이상의 테이블에서 from과 join하는 테이블에 해당하는 부분을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A RIGHT JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Outer Join : 아웃터 조인 또는 풀 조인이라고 불림, 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) SELECT A.name, B.age FROM tableA A OUTER JOIN tableB B ON A.no_emp = B.no_emp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인덱스index란-무엇인가요&quot;&gt;인덱스(Index)란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;데이터베이스의 데이터를 빠르게 검색 및 정렬하기 위해서 인덱스를 두는 방법&lt;/strong&gt;입니다. (일반적인 책 뒤에 있는 색인을 보는 방법과 비슷합니다.)&lt;/p&gt;

&lt;h3 id=&quot;dbms에서-사용하고-잇는-index-자료구조는-무엇인가요&quot;&gt;DBMS에서 사용하고 잇는 Index 자료구조는 무엇인가요??&lt;/h3&gt;

&lt;p&gt;대표적으로 B+ Tree 인덱스 알고리즘과, Hash 인덱스 알고리즘이 존재하는 것으로 알고 있습니다. &lt;strong&gt;B+ Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이고, Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;hash란-무엇인가요&quot;&gt;Hash란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;해시란 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값입니다.&lt;/strong&gt; 이렇게 매핑 하는 함수를 해시 함수라고 하며 이로부터 얻어진 값을 해시 값, 해시 코드, 짧게 말해서 해시라고도 합니다.&lt;/p&gt;

&lt;p&gt;해시의 단점은 정렬할 수 없고, 순서에 따라 값을 가져올 수도 없기 때문에 &lt;u&gt;상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash와 어울리지 않는다는 것이 단점&lt;/u&gt;입니다. 또한 Hash Function의 의존도가 높고, 공간 효율성이 떨어진다는 점이 단점입니다. 하지만 평균 데이터 처리의 시간복잡도는 O(1)(상수 시간)에 가깝기 때문에 사용하기 빠릅니다.&lt;/p&gt;

&lt;h3 id=&quot;트랜잭션transaction이란-무엇인가요&quot;&gt;트랜잭션(Transaction)이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;트랜잭션transaction의-성질은-무엇인가요&quot;&gt;트랜잭션(Transaction)의 성질은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;트랜잭션의 성질은 ACID라고 불리는 &lt;strong&gt;원자성(Atomicity), 일관성(Consistency), 독립성(Isolation), 지속성(Durability)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원자성은 트랜잭션의 연산이 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다라는 것을 의미합니다.&lt;/li&gt;
  &lt;li&gt;일관성은 트랜잭션이 그 실행을 성공적으로 완료된 다음의 상태에서도 데이터베이스느 언제나 일관성 있는 데이터를 보장해야 한다는 것을 의미합니다.&lt;/li&gt;
  &lt;li&gt;독립성은 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다는 것을 의미합니다.&lt;/li&gt;
  &lt;li&gt;지속성은 성공적으로 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다는 것을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정규화는-무엇인가요&quot;&gt;정규화는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;정규화란 데이터베이스에서 중복을 최소화하고 갱신 이상을 없애기 위해 하나의 테이블을 둘 이상으로 분리하는 작업&lt;/strong&gt;이다. 갱신 이상에는 삽입 이상, 삭제 이상, 수정 이상 등을 포함한다.&lt;/p&gt;

&lt;h3 id=&quot;정규형에는-무엇이-있는가&quot;&gt;정규형에는 무엇이 있는가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1차 정규형: 각 로우마다 컬럼의 값이 1개씩만 있어야 하는 형태를 의미합니다. 이를 컬럼이 원자값(Atomic Value)를 갖는다고 합니다.
    &lt;ul&gt;
      &lt;li&gt;각 로우의 컬럼이 값이 1개 이상일 경우 1차 정규형을 만족하지 못한다고 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2차 정규형: &lt;strong&gt;주키가 합성키&lt;/strong&gt;며 부분종속(기본키 중에 특정 컬럼에만 종속된 컬럼)이 없어야 한다는 것입니다. 테이블의 모든 컬럼이 완전 함수적 종속을 만족하는 것입니다.
    &lt;ul&gt;
      &lt;li&gt;주키가 합성키이며, 기본키 중에서 특정 컬럼에만 종속된 컬럼이 있을 경우 2차 정규형을 만족하지 못한다고 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3차 정규형: 어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다. 즉, X-&amp;gt;Y, Y-&amp;gt;Z의 경우에 의해서 추론될 수 있는 X-&amp;gt;Z의 종속관계가 없는 경우를 의미한다.
    &lt;ul&gt;
      &lt;li&gt;일반 컬럼이 다른 일반 컬럼에 종속되는 경우 제 3정규형을 만족하지 못한다고 볼 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BCNF 정규형: 3차 정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형입니다.
    &lt;ul&gt;
      &lt;li&gt;ex) 일반 컬럼이 후보키를 결정하는 경우에 3차 정규형을 만족하면서 BCNF는 만족하지 않는 경우이다. =&amp;gt; 테이블 분리가 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nosql이란-무엇인가요&quot;&gt;NoSQL이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는데 특화되어있으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NoSQL은 SQL보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공합니다.&lt;/li&gt;
  &lt;li&gt;단순 검색 및 추가 작업을 위한 매우 최적화된 key-value 저장 공간을 사용합니다.&lt;/li&gt;
  &lt;li&gt;빅데이터 시대에 따라 많은 양의 데이터를 효율적으로 처리하기 위해 등장하였습니다.&lt;/li&gt;
  &lt;li&gt;분산형 구조를 통해 여러 대의 서버에 분산해 저장하고, 분산시에는 데이터를 상호 복제에 특정 서버에 장애가 발생했을 때에도 데이터의 유실이나 서비스 중지가 없는 형태의 구조를 갖고 있습니다.&lt;/li&gt;
  &lt;li&gt;HBase, MongoDB 등이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/12/10/NAVER-Interview-Preparation-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/12/10/NAVER-Interview-Preparation-2.html</guid>
        
        <category>Spring</category>
        
        <category>Framework</category>
        
        <category>Database</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[기술 면접 준비 - 1일차] 운영체제</title>
        <description>&lt;h1 id=&quot;기술-면접-준비-1일차-포스팅---운영체제&quot;&gt;기술 면접 준비 1일차 포스팅 - 운영체제&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;코어-core&quot;&gt;코어 (Core)&lt;/h2&gt;

&lt;h3 id=&quot;코어란-무엇인가요&quot;&gt;코어란 무엇인가요??&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CPU의 기본 계산 단위&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;프로세스-process&quot;&gt;프로세스 (Process)&lt;/h2&gt;

&lt;h3 id=&quot;프로세스는-무엇인가요&quot;&gt;프로세스는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;프로세스란 실행 중인 프로그램을 의미하고 보조저장장치로부터 메모리에 적재되어 &lt;strong&gt;CPU의 할당을 받을 수 있는 단위&lt;/strong&gt;를 말합니다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스의-메모리-구조는-어떻게-되죠&quot;&gt;프로세스의 메모리 구조는 어떻게 되죠??&lt;/h4&gt;

&lt;p&gt;프로세스는 기본적으로 실행 코드가 저장되는 &lt;strong&gt;text 영역&lt;/strong&gt;, 전역 변수 등을 수록하는 &lt;strong&gt;data 영역&lt;/strong&gt;, 프로세스 실행 중에 동적으로 할당되는 메모리인 &lt;strong&gt;heap 영역&lt;/strong&gt;, 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 &lt;strong&gt;stack 영역&lt;/strong&gt;으로 이루어져 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스는-운영체제에-어떻게-저장-되죠&quot;&gt;프로세스는 운영체제에 어떻게 저장 되죠??&lt;/h4&gt;

&lt;p&gt;프로세스는 &lt;strong&gt;PCB&lt;/strong&gt;라는 자료구조를 통해서 저장되어집니다. PCB란 Process Control Block의 줄임말으로 특정 &lt;strong&gt;프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조&lt;/strong&gt;이고 이는 &lt;u&gt;PID, Process Status, PC, CPU 레지스터, CPU 스케줄링 정보&lt;/u&gt; 등으로 구성되어 집니다.&lt;/p&gt;

&lt;h3 id=&quot;스레드-thread&quot;&gt;스레드 (Thread)&lt;/h3&gt;

&lt;h4 id=&quot;스레드란-무엇인가요&quot;&gt;스레드란 무엇인가요?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;스레드는 프로세스의 CPU 이용을 위한 기본 단위&lt;/strong&gt;로 프로세스의 주소 공간이나 자원등을 공유해 프로세스를 여러 실행 흐름으로 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;멀티-스레딩이란-무엇인가요&quot;&gt;멀티 스레딩이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;하나의 프로세스를 다수의 실행 단위 즉, 여러개의 스레드로 구분&lt;/strong&gt;하여 프로세스의 자원을 공유해 &lt;strong&gt;처리 능력을 향상&lt;/strong&gt; 시키는 것을 멀티스레딩이라고 합니다.&lt;/p&gt;

&lt;h4 id=&quot;스택을-스레드마다-독립적으로-할당하는-이유가-있나요&quot;&gt;스택을 스레드마다 독립적으로 할당하는 이유가 있나요?&lt;/h4&gt;

&lt;p&gt;스택은 함수의 인자, 복귀 주소, 지역 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 &lt;strong&gt;스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가&lt;/strong&gt;되는 것이기 때문에 프로세스를 여러 실행 흐름으로 만들기 위해서는 스레드에 스택을 독립적으로 할당해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;pc-register를-스레드마다-독립적으로-할당하는-이유&quot;&gt;PC Register를 스레드마다 독립적으로 할당하는 이유&lt;/h4&gt;

&lt;p&gt;PC 값은 다음에 실행될 명령어의 주소를 나타내므로 &lt;strong&gt;프로세스의 개별 실행 흐름인 스레드가 독립적으로 명령어들을 실행하기 위해선 스레드에 PC 레지스터가 독립적으로 할당&lt;/strong&gt;되어야 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;멀티-스레드-multithread&quot;&gt;멀티 스레드 (MultiThread)&lt;/h2&gt;

&lt;h3 id=&quot;멀티-스레드의-장단점은-무엇인가요&quot;&gt;멀티 스레드의 장단점은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드를 통해 하나의 실행 흐름인 프로세스를 여러 개의 실행 흐름으로 만들 수 있습니다. 이를 통해 프로세스의 처리 능력 향상과 자원의 소모가 줄어드는 것을 기대할 수 있습니다. 하지만 여러 개의 스레드가 동일한 자원을 접근할 경우 경쟁 조건이 발생할 수 있으며 동기화를 신경 써줘야 합니다.&lt;/strong&gt; 스레드간의 동기화를 위한 동기화 기법들은 매우 다양하며 잘못 사용할 경우 병목 현상을 발생시킬 수 있어 이를 사용하기 위해 많은 자원이 필요하다는 것이 단점입니다.&lt;/p&gt;

&lt;h3 id=&quot;멀티-스레드와-멀티-프로세스의-차이는-무엇인가요&quot;&gt;멀티 스레드와 멀티 프로세스의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드와 멀티 프로세스의 차이는 여러 실행흐름을 프로세스를 통해서 만드느냐 아니면 프로세스 내의 스레드를 통해서 만드느냐의 차이입니다.&lt;/strong&gt; 이 두가지 기법 다 동시에 여러 작업을 수행한다는 점에서 목적은 같지만, 서로 장단점이 존재하기 때문에 개발 도메인에서 적합한지, 단점이 뭐가 있고, 장점은 뭐가 있는지, 왜 이 기법을 사용해야 하는지에 대해 팀 내에서 깊게 논의 한 후 시스템에 적용해야 한다고 생각합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스케줄러-scheduler&quot;&gt;스케줄러 (Scheduler)&lt;/h2&gt;

&lt;h3 id=&quot;프로세스-스케줄러란-무엇인가요&quot;&gt;&lt;strong&gt;프로세스 스케줄러란 무엇인가요??&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;멀티 프로세스 기법을 사용하는 시스템은 프로세스의 실행 순서를 스케줄링 해야만 합니다. 이러한 &lt;strong&gt;프로세스의 실행 순서를 스케줄링하는 도구를 프로세스 스케줄러&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로세스-스케줄러에는-어떠한-것들이-존재하죠&quot;&gt;&lt;strong&gt;프로세스 스케줄러에는 어떠한 것들이 존재하죠?&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;프로그램이 저장되어 있는 디스크에서 메모리로 프로세스 스케줄링을 담당하는 Job Schduler, CPU와 메모리 사이의 스케줄링을 담당하는 CPU Schecudler, 메모리에서 디스크로 프로세스 스케줄링을 담당하는 Swapper등이 있는걸로 알고 있습빈다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케줄러란-무엇인가요&quot;&gt;CPU 스케줄러란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Ready Queue에 있는 프로세스들을 스케줄링하는 스케줄러를 CPU 스케줄러&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케줄러의-기법에는-어떤게-있을까요&quot;&gt;CPU 스케줄러의 기법에는 어떤게 있을까요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;먼저 Ready Queue에 들어온 프로세스를 먼저 처리하는 First Come Fist Serve(FCFS) 스케줄링 기법&lt;/strong&gt;, &lt;strong&gt;CPU Burst Time이 짧은 프로세스를 먼저 처리하는 Shortest Job First(SJF) 스케줄링 기법&lt;/strong&gt;, SJF 기법 기반으로 &lt;strong&gt;새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어져 가장 짧은 프로세스를 먼저 처리하는 Shortest Remaining time First(SRT) 기법&lt;/strong&gt;, &lt;strong&gt;프로세스에 우선순위를 부여하여 우선순위가 높은 프로세스를 먼저 처리하는 Priority Schduling 기법&lt;/strong&gt;, &lt;strong&gt;프로세스에 CPU 할당 시간을 정해 놓아 CPU를 할당하는 방법인 Round Robin 기법&lt;/strong&gt; 등이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;동기와-비동기의-차이는-무엇인가요&quot;&gt;동기와 비동기의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;동기는 요청과 동시에 결과가 일어나는 경우를 동기라고 표현하고, 비동기는 요청과 결과가 동시에 일어나지 않는 경우를 비동기라고 표현한다.&lt;/p&gt;

&lt;h3 id=&quot;block과-non-block의-차이는-무엇인가요&quot;&gt;block과 non-block의 차이는 무엇인가요?&lt;/h3&gt;

&lt;p&gt;요청에 대한 응답을 얻기 까지 다른 실행 흐름들이 기다리는 것을 blocking이라고 하고, 다른 실행 흐름이 요청에 대한 응답을 대기하지 않고 자유롭게 CPU나 메모리 등을 이용하는 상황을 non-blocking 이라고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;프로세스-동기화-process-synchronization&quot;&gt;프로세스 동기화 (Process Synchronization)&lt;/h2&gt;

&lt;h3 id=&quot;critical-section은-무엇인가요&quot;&gt;Critical Section은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역을 Critical Section&lt;/strong&gt; 이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;critical-section-problem을-해결하기-위한-조건이-무엇일까요&quot;&gt;Critical Section Problem을 해결하기 위한 조건이 무엇일까요?&lt;/h3&gt;

&lt;p&gt;Critical Section Problem을 해결하기 위한 조건은 첫 번째 &lt;strong&gt;특정 프로세스가 Critical Section을 수행하고 있다면 다른 프로세스는 이 Critical Section에 들어오지 못하게 하는 상호 배제(Mutual Exclusion)&lt;/strong&gt; 조건입니다.&lt;/p&gt;

&lt;p&gt;두 번째는 Critical Section에서 실행중인 프로세스가 없고, &lt;strong&gt;별도의 동작이 없는 프로세스들만 Critical Section 진입 후보 프로세스로서 참여할 수 있다는 조건인 Progress&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;세 번째는 &lt;strong&gt;특정 프로세스가 Ciritcal Section에 진입 신청 후 받아들여지기까지 기간이 한정되어야 함을 나타내는 Bounded Waiting&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&quot;critical-section-problem을-해결하기-위한-기법에는-무엇이-있나요&quot;&gt;Critical Section Problem을 해결하기 위한 기법에는 무엇이 있나요?&lt;/h3&gt;

&lt;p&gt;첫 번째는 &lt;strong&gt;하드웨어 기반 해결책인 Lock&lt;/strong&gt;입니다. Critical Section에 진입하기전에 Lock을 얻고, Critical Section에서 빠져 나올 때 Lock을 방출함으로써 프로세스간에 동기화를 유지합니다.&lt;/p&gt;

&lt;p&gt;두 번째는 &lt;strong&gt;Semaphores 입니다. 소프트웨어 상에서 Ciritcal Section 문제를 해결하기 위한 동기화 도구&lt;/strong&gt;이며, 두 개의 프로세스 사이에서 동기화를 유지할 수 있는 이진 세마포와 프로세스 세개 이상의 프로세스 사이에서 동기화를 유지할 수 있는 카운팅 세마포가 있습니다.&lt;/p&gt;

&lt;p&gt;세 번째는 &lt;strong&gt;모니터 입니다. 모니터는 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메모리-관리-전략&quot;&gt;메모리 관리 전략&lt;/h2&gt;

&lt;h3 id=&quot;swapping-이란-무엇인가요&quot;&gt;Swapping 이란 무엇인가요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Swapping 이란 메모리의 관리를 위해 사용되는 기법&lt;/strong&gt;입니다. CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치(하드디스크)로 내보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 과정을 swap (스왑시킨다) 이라 한다. &lt;strong&gt;주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조 기억장치로 내보내는 과정을 swap-out&lt;/strong&gt; 이라 한다. swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 Swapping이 시작된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;swapping을-하면서-발생하는-문제점에-대해서-알고-있나요&quot;&gt;Swapping을 하면서 발생하는 문제점에 대해서 알고 있나요?&lt;/h3&gt;

&lt;p&gt;대표적으로 &lt;strong&gt;단편화(Fragmentation) 문제&lt;/strong&gt;를 들 수 있습니다. 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 사이에 사용 하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데 이를 단편화라고 합니다.&lt;/p&gt;

&lt;p&gt;단편화의 종류는 크게 외부 단편화와 내부 단편화로 나눌 수 있습니다. &lt;strong&gt;외부 단편화란 메모리에서 프로세스 사이 사이 남는 공간들을 의미하는 것이고, 내부 단편화란 프로세스가 사용하는 메모리 공간에서 남는 부분을 의미하는 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-외부-단편화를-해소하기-위한-방법은-무엇이-있을까요&quot;&gt;그렇다면 외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;압축&lt;/strong&gt;이 있을 것 같습니다. 외부 단편화를 해소하기 위해 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아, 자유 공간을 확보하는 방법론 이지만, &lt;u&gt;작업효율이 좋지 않아 잘 사용하지 않습니다.&lt;/u&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-또-다른-외부-단편화-문제를-해결할-수-있는-방법은-무엇인가요&quot;&gt;그렇다면 또 다른 외부 단편화 문제를 해결할 수 있는 방법은 무엇인가요?&lt;/h3&gt;

&lt;p&gt;대표적인 예로는 메모리 공간이 연속적이어야 한다는 제약을 없애는 &lt;strong&gt;페이징 기법&lt;/strong&gt;을 들 수 있습니다. &lt;strong&gt;물리 메모리를 Frame 이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이러한 페이징 기법을 통해 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;즉, 하나의 프로세스가 사용하는 공간을 여러개의 페이지로 나뉘어서 논리 메모리에서 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장하는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하지만 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있다고 생각합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션이란-무엇입니까&quot;&gt;세그멘테이션이란 무엇입니까?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;세그멘테이션은 프로세스를 물리적 크기의 단위가 아닌 논리적 내용의 단위인 세그먼트로 분할하고 메모리를 할당하며 주소를 변환하는 기법이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 분할해 둘 수 없고, &lt;strong&gt;메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세그먼트의 단위가 다르기 때문에 메모리에 서로 다른 크기를 가진 여러 세그먼트를 저장할 시 외부 단편화가 생기는 문제점이 존재해 잘 사용하지는 않습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;가상-메모리-virtual-memory&quot;&gt;가상 메모리 (Virtual Memory)&lt;/h2&gt;

&lt;h3 id=&quot;가상-메모리란-무엇인가&quot;&gt;가상 메모리란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;가상 메모리란 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법&lt;/strong&gt;이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;왜-가상-메모리가-나오게-되었는가&quot;&gt;왜 가상 메모리가 나오게 되었는가?&lt;/h3&gt;

&lt;p&gt;실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 또한 멀티 프로세스상에서 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생했기 때문에 이를 해결하기 위해 가상 메모리 기법이 나오게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;가상-메모리를-통해서-우리는-어떤-장점을-얻을-수-있는가&quot;&gt;가상 메모리를 통해서 우리는 어떤 장점을 얻을 수 있는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로그램의 일부분만 메모리에 올릴 수 있게 되었고 이를 통해 물리 메모리 크기에 제약을 받지 않게 되었습니다. 고로 더 많은 프로그램을 동시에 실행할 수 있게 되었다. 또한 swap에 필요한 입출력이 줄었기 때문에 프로그램들이 빠르게 실행된다는 장점을 가지고 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;가상-메모리는-어떻게-동작하는가&quot;&gt;가상 메모리는 어떻게 동작하는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다.&lt;/strong&gt; 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가상 주소 공간이란 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간&lt;/strong&gt;이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 현재 직접적으로 필요치 않는 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 합니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다&lt;/strong&gt;. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;요구-페이징-demand-paging이란-무엇인가&quot;&gt;요구 페이징 (Demand Paging)이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며 가상 메모리 시스템에서 많이 사용된다.&lt;/strong&gt; 요구 페이징을 사용하는 가상 메모리에서는 &lt;strong&gt;실행과정에서 필요해질 때 페이지들이 적재된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘이란-무엇인가&quot;&gt;페이지 교체 알고리즘이란 무엇인가?&lt;/h3&gt;

&lt;p&gt;요구 페이징에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, &lt;strong&gt;프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 되는 것을 의미합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘의-순서는-어떻게-되는가&quot;&gt;페이지 교체 알고리즘의 순서는 어떻게 되는가?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;디스크에서 필요한 페이지의 위치를 찾는다.&lt;/li&gt;
  &lt;li&gt;빈 페이지 프레임을 찾는다.
    &lt;ul&gt;
      &lt;li&gt;페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.&lt;/li&gt;
      &lt;li&gt;희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.&lt;/li&gt;
  &lt;li&gt;사용자 프로세스 재 시작&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘에는-어떠한-것들이-있는가&quot;&gt;페이지 교체 알고리즘에는 어떠한 것들이 있는가?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;FIFO 페이지 교체 : 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다.&lt;/li&gt;
  &lt;li&gt;최적 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 알고리즘이다.&lt;/li&gt;
  &lt;li&gt;LRU (Least Recently Used) 페이지 교체 : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. (최적 알고리즘 근사 알고리즘)&lt;/li&gt;
  &lt;li&gt;LFU (Least Frequently Used) 페이지 교체 : 참조 횟수가 가장 적은 페이지를 교체하는 방법이다.&lt;/li&gt;
  &lt;li&gt;MFU (Most Frequently Used) 페이지 교체 : 참조 횟수가 가장 많은 페이지를 교체하는 방법이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;캐시cache&quot;&gt;캐시(Cache)&lt;/h2&gt;

&lt;h3 id=&quot;캐시-메모리란-무엇인가&quot;&gt;캐시 메모리란 무엇인가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;캐시 메모리란 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;캐시-메모리에서-가장-신경써야-하는-문제는-무엇인가&quot;&gt;캐시 메모리에서 가장 신경써야 하는 문제는 무엇인가?&lt;/h3&gt;

&lt;p&gt;캐시 메모리의 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 예측할 수 있어야 한다. &lt;strong&gt;즉, 적중률(hit rate)을 극대화 시켜야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;적중률hit-rate을-극대화-시키기-위해-어떻게-해야-하는가&quot;&gt;적중률(hit rate)을 극대화 시키기 위해 어떻게 해야 하는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;적중률을 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용한다.&lt;/strong&gt; 즉, Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.&lt;/p&gt;

&lt;h3 id=&quot;지역성은-어떻게-나뉘는가&quot;&gt;지역성은 어떻게 나뉘는가?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;데이터 지역성은 대표적으로 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉘고 이는 다음과 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 26 Nov 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/interview/2020/11/26/NAVER-Interview-Preparation-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/interview/2020/11/26/NAVER-Interview-Preparation-1.html</guid>
        
        <category>Operating-System</category>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>[Jenkins로 CI/CD 구축하기 - 1] Ubuntu(18.04)에 Jenkins 설치하기</title>
        <description>&lt;p&gt;이번 포스팅에서는 Ubuntu(18.04)에 Jenkins를 설치하고 환경 설정까지 하는 방법을 공유하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://imbf.github.io/devops/2020/10/28/What-is-The-DevOps.html&quot;&gt;DevOps가 무엇인가?&lt;/a&gt; 에 대해서는 이전 포스팅에서 다루었고, 이번부턴 Jenkins로 CI/CD 구축하기 시리즈를 시작하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;이번 포스팅은 시리즈의 첫 번째 주제인 &lt;strong&gt;Ubuntu(18.04)에 Jenkins 설치하고 환경 설정하기&lt;/strong&gt; 입니다. &lt;strong&gt;Ubuntu(18.04)에 Jenkins를 설정하고 관련 환경을 구성하면서 겪었던 이슈 및 방법&lt;/strong&gt;에 대해서 공유할 예정입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;내가 지식을 받았을 때 처럼 나의 지식과 경험이 누군가에게는 도움이 되길 간절히 소망합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ubuntu1804에-jenkins-설치하기&quot;&gt;Ubuntu(18.04)에 Jenkins 설치하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;는 사용자의 편의성에 초점을 맞춘 &lt;strong&gt;Linux 배포판&lt;/strong&gt;입니다. 고로 우리는 Ubuntu를 사용할 때 Linux와 비슷하게 여겨도 큰 상관이 없습니다.&lt;u&gt;(특정 기능 사용시 다른 배포판(CentOS 등)과 사용하는 명령어가 다르긴 하다.)&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;Ubuntu 18.04는 Ubuntu에서 2년마다 발표하는 LTS(Long Term Support)중의 하나이며, 이 OS 환경에서 Jenkins를 설치하는 방법을 소개할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;우리는 Jenkins 버전 중 현재 가장 최신의 Long Term Support(LTS) Release를 설치할 예정이며 과정은 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-jenkins-설치를-위해-repository-key-추가&quot;&gt;1. Jenkins 설치를 위해 Repository key 추가&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;키가 잘 추가 되었다면 &lt;strong&gt;OK&lt;/strong&gt;라는 문구를 보실 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-서버의-sourceslist에-jenkins-패키지-저장소를-추가&quot;&gt;2. 서버의 sources.list에 Jenkins 패키지 저장소를 추가&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo sh -c 'echo deb https://pkg.jenkins.io/debian-stable binary/ &amp;gt; \
    /etc/apt/sources.list.d/jenkins.list'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-패키지-인덱스-정보-업데이트&quot;&gt;3. 패키지 인덱스 정보 업데이트&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-jenkins-패키지-설치&quot;&gt;4. Jenkins 패키지 설치&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;여기까지 잘 따라 오셨다면 Jenkins는 잘 설치 되었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-java-jdk-8-설치&quot;&gt;5. Java JDK 8 설치&lt;/h3&gt;

&lt;p&gt;하지만 Jenkins를 실행하기 위해서는 특정 버젼의 &lt;strong&gt;Java JDK&lt;/strong&gt;가 필요함으로 설치해주도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install openjdk-8-jdk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Java JDK 8 버전이 잘 설치 되었을 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;java -version&lt;/code&gt;이라고 bash에 입력해주면 아래와 같은 로그를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-2.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-jenkins-실행하기&quot;&gt;6. Jenkins 실행하기&lt;/h3&gt;

&lt;p&gt;이제 Jenkins와 Java도 잘 설치 되었음으로 &lt;strong&gt;Jenkins를 실행&lt;/strong&gt;해 보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl start jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jenkins가 정상적으로 잘 실행 되었다면 아래와 같은 명령어를 bash에 입력할 시 &lt;strong&gt;jenkins service의 상태를 체크&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl status jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;저와 같은 로그가 보인다면, Jenkins가 잘 실행 된 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-3.png&quot; style=&quot;width:90%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;7-jenkins-포트-변경하기&quot;&gt;7. Jenkins 포트 변경하기&lt;/h3&gt;

&lt;p&gt;Jenkins를 실행시켰을 때 기본적으로 8080 포트에서 동작합니다. 하지만 Spring Project의 경우 기본 포트가 8080이기 때문에 중복되어 불편할 수 있음으로 &lt;strong&gt;Jenkins 포트를 9090포트로 바꾸어&lt;/strong&gt; 주도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vi /etc/default/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 작업은 아주 간단합니다. 아래와 같이 vi 에디터를 사용해서 /etc/default/Jenkins 파일의 &lt;strong&gt;HTTP_PORT를 9090포트로 변경&lt;/strong&gt;해주면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-4.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Jenkins 포트를 9090으로 변경했다면 &lt;strong&gt;Jenkins를 재실행&lt;/strong&gt; 해주도록 합시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8-방화벽-설정&quot;&gt;8. 방화벽 설정&lt;/h3&gt;

&lt;p&gt;기본적으로 OS는 보안을 위해 방화벽으로 주요 포트 이외의 대부분의 포트에 다른 호스트들의 접근을 막아놓기 마련입니다.&lt;/p&gt;

&lt;p&gt;그래서, &lt;strong&gt;ufw를 사용하여 다른 호스트가 나의 9090포트에 접근할 수 있도록 열어 놓아야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ufw allow 9090
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;특정 호스트만 나의 9090포트에 접근할 수 있도록 할 수 있지만 이 부분은 생략하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;잘 설정이 되었으면 아래와 같은 명령어를 입력합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ufw status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어 입력시 아래와 같이 9090 포트의 Rule이 생성되었다면 성공입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-5.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;9-jenkins-설정하기&quot;&gt;9. Jenkins 설정하기&lt;/h3&gt;

&lt;p&gt;이제 Jenkins를 실행하기 위한 모든 작업이 끝이 났습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;추가적으로 Jenkins의 초기 설정인 Plugin 설치, 계정 설정, secret key 입력을 진행하도록 하겠습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;브라우저를 통해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://(hostIp or hostName):9090&lt;/code&gt; 에 접속시 아래와 같은 화면을 보실 수 있으며&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-6.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;/var/lib/jenkins/secrets/initialAdminPassword 에 가서 password를 복사해서 Administrator password 폼에 입력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-7.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;폼에 Password를 입력하고 Continue를 클릭하면 다음과 같은 &lt;strong&gt;플러그인 설치 화면&lt;/strong&gt;이 나오게 되는데 &lt;strong&gt;본인이 사용하는 플러그인을 잘 모른다면 Install Suggested Plugins를 클릭&lt;/strong&gt;하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-8.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Install Suggested Plugins 버튼을 클릭하면 &lt;strong&gt;권장 Plugin 설치가 진행되니, Getting Started 게이지가 다 찰 때까지 기다리면 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-9.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플러그인 설치가 완료되면 &lt;strong&gt;계정 설정 페이지&lt;/strong&gt;가 나오게 되는데 폼을 다 채우고 save and Continue 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이 계정 정보는 브라우저를 통해 Jenkins 접속시 항상 입력해야 함으로 꼭 잊어버리지 않아야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-10.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;계정 설정 완료 후 추가적으로 1~2가지 설정을 마치면 아래와 같은 Jenkins 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/install-jenkins-in-ubuntu-11.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 기반으로 독자 여러분이 본인의 입맛에 맞게끔 Jenkins를 요리해서 사용하면 됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이로써 Ubuntu(18.04)에 Jenkins 설치하기 및 관련 환경 구성하기를 마치며 다음에는 &lt;strong&gt;Jenkins에 GitHub Webhook 연동하기&lt;/strong&gt; 포스팅으로써 찾아오도록 하겠습니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Nov 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devops/2020/11/26/Install-Jenkins-in-Ubuntu(18.04).html</link>
        <guid isPermaLink="true">http://localhost:4000/devops/2020/11/26/Install-Jenkins-in-Ubuntu(18.04).html</guid>
        
        <category>DevOps</category>
        
        <category>CI/CD</category>
        
        <category>Jenkins</category>
        
        <category>Ubuntu</category>
        
        
        <category>DevOps</category>
        
      </item>
    
      <item>
        <title>[Operating System - Chapter 6] 동기화 도구들</title>
        <description>&lt;p&gt;이 포스팅은 공룡책으로 알려진 Operating System Concepts의 6장인 &lt;strong&gt;Synchronization Tools&lt;/strong&gt;를 공부하면서 정리한 포스팅이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6-동기화-도구들-synchronization-tools&quot;&gt;6. 동기화 도구들 (Synchronization Tools)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;협력적 프로세스는 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 영향을 받는 프로세스이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 장에서는 논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하여, 이를 통해 &lt;strong&gt;데이터의 일관성&lt;/strong&gt;을 유지하는 다양한 메커니즘에 대해 논의하도록 하겠다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;61-배경-background&quot;&gt;6.1 배경 (Background)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;우리는 이미 프로세스가 병행하게 또는 병렬로 실행될 수 있다는 것을 알고 있다. 본 장에서는 프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 &lt;strong&gt;데이터의 무결성&lt;/strong&gt;에 어떤 문제를 일으키는지에 관해 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 경쟁 상황(race condition)이라고 한다.&lt;/strong&gt; 경쟁 상황으로부터 보호하기 위해, 우리는 한순간에 하나의 프로세스만이 데이터를 조작하도록 보장해야 한다. 이러한 보장을 위해, 우리는 어떤 형태로든 프로세스들이 동기화되도록 할 필요가 있다.&lt;/p&gt;

&lt;p&gt;또한 다중 코어 시스템의 대두와 더불어 다중 스레드 어플리케이션의 개발에 대한 관심이 증가하고 있다. 다중 스레드 어플리케이션에서는 자원을 공유할 가능성이 매우 높은 여러 스레드가 서로 다른 처리 코어에서 병렬로 실행된다. 이러한 상황에서 race condition은 더 빈번하게 발생할 수 있어, 스레드들이 동기화되도록 할 필요가 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;62-임계구역-문제-the-critical-section-problem&quot;&gt;6.2 임계구역 문제 (The Critical Section Problem)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로세스 동기화에 관한 논의는 소위 임계구역 문제라고 불리는 문제로부터 시작한다. n개의 프로세스 {P0, P1, …, P(n-1)}이 있는 시스템을 고려해 보자.&lt;/p&gt;

&lt;p&gt;각 프로세스는 &lt;strong&gt;임계구역(critical section)&lt;/strong&gt;이라고 부르는 코드를 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다. 이 시스템의 중요한 특징은 &lt;strong&gt;한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다는 사실이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;임계구역 문제는 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜(약속)을 설계하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 프로세스는 자신의 임계구역으로 진입하려면 진입 구역(entry section)에서 진입 허가를 요청해야 하고, 임계구역 뒤에는 퇴출 구역(exit section)이 따라올 수 있다. 코드의 나머지 부분들을 총칭하여 나머지 구역(reaminder section)이라고 한다.&lt;/p&gt;

&lt;p&gt;이를 사용하는 프로세스의 일반적인 구조를 나타낸 그림은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-1.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림에 나와 있는 것처럼 entry section과 exit section은 프로세스의 동기화를 위해서 매우 중요하다.&lt;/p&gt;

&lt;p&gt;임계구역 문제에 대한 해결안은 다음의 &lt;strong&gt;세 가지 요구 조건&lt;/strong&gt;을 충족해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;상호 배제(mutual exclusion):&lt;/strong&gt; 프로세스 P가 자기의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;진행(progress):&lt;/strong&gt; 자기의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않는 프로세스들만 다음에 누가 그 임계구역으로 진입할 수 있는지를 결정하는 데 참여할 수 있으며, 이 선택은 무한정 연기될 수 없다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;한정된 대기(bounded waiting):&lt;/strong&gt; 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;임의의 한순간에 많은 커널 모드 프로세스들이 운영체제 안에서 활성화될 수 있기 때문에 운영체제를 구현하는 코드(커널 코드)는 경쟁 조건이 발생하기 쉽다. &lt;u&gt;경쟁 조건이 발생하기 쉬운 커널 자료구조로는 메모리 할당을 관리하는 자료구조, 프로세스 리스트를 유지하는 자료구조, 인터럽트 처리를 위한 자료구조 등이 있다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;운영체제 내에서 임계구역을 다루기 위해서 &lt;strong&gt;선점형 커널&lt;/strong&gt;과 &lt;strong&gt;비선점형 커널&lt;/strong&gt;의 두 가지 일반적인 접근법이 사용된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;선점형 커널은 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;선점형 커널에 대해서는 동일한 주장을 할 수 없어 경쟁 조건이 발생할 수 있기 때문에 공유되는 커널 자료구조에서 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비선점형 커널은 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한 순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로 경쟁 조건을 염려할 필요는 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;커널 모드 프로세스가 대기 중인 프로세스에 프로세서를 양도하기 전에 오랫동안 실행할 위험이 적기 때문에 선점형 커널은 더 응답이 민첩할 수 있다. 하지만 선점형 커널을 설계하기 앞서 경쟁 조건을 잘 고려해야만 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;63-peterson의-해결안-petersons-solution&quot;&gt;6.3 Peterson의 해결안 (Peterson’s Solution)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Peterson 해결안은 Critical Section과 Remainder Section을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다. 보통 프로세스는 P0와 P1로 번호를 매긴다. Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을 공유하도록 하여 해결한다. 이는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Critical Section으로 진입할 순번을 나타내는 변수&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 각 프로세스가 Critical Section으로 진입할 준비가 되었다는 것을 표현한 배열&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;flag[i]가 참이라면 Pi가 Critical Section으로 진입할 준비가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Pi의 Peterson 알고리즘은 다음과 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-2.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Critical Section으로 진입하기 위해서는 Pi는 먼저 flag[i]를 참으로 만들고, turn을 j로 지정한다. 이렇게 함으로써 Pi는 Pj가 Critical Section으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다. 만일 두 프로세스가 동시에 진입하기를 원한다면 진입 turn은 거의 동시에 i와 j로 지정될 것이다. 이 때의 경우 turn의 궁극적인 값이 둘 중 누가 먼저 Critical Section으로 진입할 것인가를 결정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flag[j]가 false(Pj가 remainder section 수행)가 되거나 turn이 i(Pj는 준비완료됬고, Pi가 Entry Section에서 대기하고 있음)일 경우 Pi는 Critical Section에 들어갈 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Peterson의 해결안이 Ciritical Section 문제를 해결하기 위해선 위에서 명시한 것 처럼 3가지 요구조건을 만족해야 한다. 같이 살펴보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상호 배재(Mutual Exclusion)
    &lt;ul&gt;
      &lt;li&gt;flag[2]와 turn 변수에 의해서 하나의 프로세스만 Critical Section에서 연산을 수행할 수 있음으로 Mutual Exclusion는 지켜진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;진행(Progress)
    &lt;ul&gt;
      &lt;li&gt;각 프로세스가 자신이 Critical Section을 수행할 동안 while문에서 다른 프로세스를 유한하게 대기하도록 만드는 방법을 통하여 Progress를 지킬 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한정된 대기(bounded waiting)
    &lt;ul&gt;
      &lt;li&gt;각 프로세스들은 Critical Section에 진입하려는 요청을 한 후부터 다른 프로세스가 Critical Section을 수행하는 동안 유한하게 대기함으로 bounded waiting 또한 지켜진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Peterson의 해결안은 최신 컴퓨터 아키텍처에서 작동한다고 보장되지 않는다. &lt;u&gt;주된 이유는 시스템 성능을 향상하기 위해 프로세스 또는 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 재정렬&lt;/u&gt; 할 수 있기 때문이다. 예로 들어, Peterson 해결안의 entry section의 첫 두 문장의 순서를 바꾸게 되면 임계구역 문제를 해결할 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;64-동기화를-위한-하드웨어-지원-hardware-support-for-synchronization&quot;&gt;6.4 동기화를 위한 하드웨어 지원 (Hardware Support for Synchronization)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Critical Section 문제의 소프트 웨어 기반 해결책은 최신 컴퓨터 아키텍처에서 작동하지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;이 절에서는 Critical Section 문제를 해결하기 위한 지원을 제공하는 &lt;strong&gt;세 가지 하드웨어 명령&lt;/strong&gt;을 제시한다. 이러한 프리미티브(초기의, 원초적인, …) 연산은 동기화 도구로 직접 사용될 수 있거나 더 추상적인 동기화 기법의 기초 형태로 사용될 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;641-메모리-장벽-memory-barriers&quot;&gt;6.4.1 메모리 장벽 (Memory Barriers)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식을 메모리 모델이라고 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 메모리 모델은 두 가지 범주 중 하나에 속한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;강한 순서:&lt;/strong&gt; 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;약한 순서:&lt;/strong&gt; 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;컴퓨터 아키텍처는 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공하여 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장&lt;/strong&gt;한다. 이러한 명령어를 &lt;strong&gt;메모리 장벽(Memory Barriers) 또는 메모리 펜스(Memory Fences)&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;메모리 장벽 명령어가 실행될 때, 시스템은 후속 적재 또는 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 한다. 따라서 명령이 재정렬 되더라도 메모리 장벽은 향후 적재 또는 저장 작업이 수행되기 전에 저장 작업이 메모리에서 완료되어 다른 프로세서에 보이도록 한다.&lt;/p&gt;

&lt;p&gt;메모리 장벽은 매우 낮은 수준의 연산으로 간주하며 일반적으로 Mutual Exclusion을 보장하는 특수 코드를 작성할 때 커널 개발자만 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;642-하드웨어-명령어-hardware-instructions&quot;&gt;6.4.2 하드웨어 명령어 (Hardware Instructions)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;많은 현대 기계들은 한 워드(word)의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적으로 교환(swap)할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어들을 제공한다.&lt;/strong&gt; 우리는 이들을 사용하여 간단한 방식으로 Critical Section을 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;이 명령어들을 추상적으로 표현하자면 test_and_set()과 compare_and_swap()이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;test_and_set()&lt;/strong&gt; 명령어는 원자적(atomically)으로 실행된다. 아래의 그림은 test_and_set() 명령어의 정의문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-3.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 활용한 Critical Section의 Mutucal Exclsion 해결 알고리즘은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-6.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 알고리즘은 lock이라는 공유 변수가 한 프로세스에서 false일 경우 lock을 true로 만들고 자신은 Critical Section으로 들어간다. Critical Section에서 빠져나온 프로세스가 lock을 false로 만들면 다른 프로세스가 Critical Section에 들어가고 이러한 과정이 반복되는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;compare_and_swap()&lt;/strong&gt; 명령어는 test_and_set() 명령어와 마찬가지로 두 개의 워드에 원자적인 연산을 하지만 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다. 아래의 그림은 compare_and_swap() 명령어의 정의문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-4.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Critical Section 요구 조건을 모두 만족시키는 compare_and_swap() 명령어를 이용한 알고리즘에 대해서 설명하도록 하겠다. 공통 데이터 및 코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 프로세스i가 대기하고 있다는 것을 나타내는 배열&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-5.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pi가 임계구역에 진입하는 경우는 오직 waiting[i] == false 이든지 key == 0 이 되어야 한다. lock이 0일 때에만 key가 0 이되고 lock이 1로 바뀌면서 무한 루프에서 빠져나올 수 있다.&lt;/p&gt;

&lt;p&gt;waiting[i]를 false로 바꾸고 임계 구역을 실행한 뒤 i를 순차적으로 증가시켜 자신과 같을 때 까지 또는 i가 기다리고 있을 때 까지 무한 루프를 돌고, 선택된 프로세스를 Ciritical Section에 진입할 수 있도록 해주는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;위의 알고리즘은 Ciritical Section 해결안이 만족해야 하는 요구조건인 Mutual Exclusion, Progress, Bounded Waiting를 모두 만족한다.&lt;/p&gt;

&lt;h4 id=&quot;643-원자적-변수-atomic-variables&quot;&gt;6.4.3 원자적 변수 (Atomic Variables)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;원자적 변수(atomic variable)은 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다. 원자적 변수는 카운터가 증가할 때와 같이 갱신되는 동안 단일 변수에 대한 데이터 경쟁이 있을 수 있는 상황에서 상호 배제를 보장하는데 사용할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라 특별한 원자적 데이터 유형을 제공한다.&lt;/p&gt;

&lt;p&gt;원자적 변수는 운영체제 및 병행 응용 프로그램에서 일반적으로 사용되지만 카운터 및 시퀀스 생성기와 같은 공유 데이터 한 개의 갱신에만 제한되는 경우가 많다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;65-mutex-locks&quot;&gt;6.5 Mutex Locks&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;mutex lock은 mutual exclusion lock의 축약 형태로서 Critical Section을 해결하기위한 하드웨어 기반의 해결책보다 상위 수준의 해결책이다.&lt;/strong&gt; 우리는 Critical Section을 보호하고, 따라서 Racing Condition을 방지하기 위해 mutex lock을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉, 프로세스는 Critical Section에 들어가기 전에 반드시 lock을 획득해야 하고 Critical Section을 빠져나올 때 lock을 반환해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mutex lock 에 대해서 알기 위해서 우리는 3가지를 알아야 한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;acquire(): 락을 획득하는 함수&lt;/li&gt;
  &lt;li&gt;release(): 락을 반환하는 함수&lt;/li&gt;
  &lt;li&gt;available: 락의 가용 여부를 표시하는 변수&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;acquire() 함수의 정의는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* busy wait */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;release() 함수의 정의는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래의 그림은 Mutex lock을 사용한 Critical Section 문제 해결 알고리즘이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-7.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 설명한 구현 방식의 단점은 &lt;strong&gt;바쁜 대기(busy waiting)&lt;/strong&gt;를 해야 한다는 것이다. 프로세스가 임계구역에 있는 동안 임계구역에 들어가기 원하는 다른 프로세스들은 acquire() 함수를 호출하는 반복문을 계속 실행해야 한다. 이러한 busy waiting은 다른 프로세스가 생산적으로 사용할 수 있는 CPU 주기를 낭비한다.&lt;/p&gt;

&lt;p&gt;우리가 설명한 mutex lock 유형을 &lt;strong&gt;스핀락(spinlock)&lt;/strong&gt;이라고도 한다. 락을 사용할 수 있을 때까지 프로세스가 회전하기 때문이다. 그러나 스핀락은 프로세스가 락을 기다려야 하고 문맥 교환에 상당한 시간이 소요될 때 문맥 교환이 필요하지 않다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;최신 다중 코어 컴퓨팅 시스템에서 스핀락은 많은 운영체제에서 널리 사용된다. &lt;strong&gt;일반적으로 락이 유지되는 기간이 문맥 교환을 두 번(1.스레드를 대기상태로 2.대기중인 스레드를 복원) 하는 시간보다 짧은 경우 스핀락을 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;락 경합(Lock Competition)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;락에 대한 경합 상태일 수도 비경합 상태일 수도 있다.&lt;/p&gt;

  &lt;p&gt;락을 획득하려고 시도하는 동안 스레드가 봉쇄되면 락은 경합 상태로 간주한다.&lt;/p&gt;

  &lt;p&gt;스레드가 락을 얻으려고 시도할 때 락을 사용할 수 있으면 락은 비경합 상태로 간주한다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;높은 경합 상태의 락은 병행 실행 응용 프로그램의 성능을 전체적으로 저하한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;66-세마포-semaphores&quot;&gt;6.6 세마포 (Semaphores)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;세마포 S는 정수 변수로서, 초기화를 제외하고는 단지 두 개의 표준 원자적(atomical) 연산 wait()와 signal()로만 접근할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;wait() 연산은 원래 “검사하다”를 의미하는 네덜란드어 proberen에서 &lt;strong&gt;P&lt;/strong&gt;, 그리고 signal() 연산은 “증가하다”를 의미하는 verhogen에서 &lt;strong&gt;V&lt;/strong&gt;라고 지어졌다.&lt;/p&gt;

&lt;p&gt;wait()의 정의는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// busy wait&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;signal()의 정의는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;wait()와 signal() 연산 시 세마포의 정수 값을 변경하는 연산은 반드시 원자적으로 수행되어야 한다.&lt;/p&gt;

&lt;h4 id=&quot;661-세마포-사용법-semaphore-usage&quot;&gt;6.6.1 세마포 사용법 (Semaphore Usage)&lt;/h4&gt;

&lt;p&gt;운영체제는 종종 카운팅(counting)과 이진(binary) 세마포를 구분한다. &lt;strong&gt;카운팅 세마포의 값은 제한 없는 영역을 갖지만 이진 세마포의 값은 0과 1사이의 값만 가능하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;카운팅 세마포는 유한한 개수를 가진 자원에 대한 접근을 제어하는데 사용될 수 있다.&lt;/strong&gt; 세마포는 가용한 자원의 개수로 초기화된다. 각 자원을 사용하려는 프로세스는 세마포에 wait() 연산을 수행하며, 이때 세마포의 값은 감소한다. 프로세스가 자원을 방출할 때는 signal() 연산을 수행하고 세마포는 증가하게 된다. &lt;strong&gt;세마포의 값이 0이 되면 모든 자원이 사용중임을 나타낸다.&lt;/strong&gt; 이후 자원을 사용하려는 프로세스는 세마포 값이 0보다 커질 때까지 봉쇄된다.&lt;/p&gt;

&lt;h4 id=&quot;662-세마포-구현-semaphore-implementation&quot;&gt;6.6.2 세마포 구현 (Semaphore Implementation)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Busy Waiting을 피하기 위해 세마포 S를 대기하면서 일시 중지된 프로세스는 다른 프로세스가 signal() 연산을 실행하면 재시작되어야 한다.&lt;/strong&gt; 프로세스는 sleep() 연산에 의해서 일시 중지되고 wakeup() 연산에 의하여 재시작된다. (대기상태 &amp;lt;-&amp;gt; 준비 완료 상태)&lt;/p&gt;

&lt;p&gt;세마포를 활용한 Critical Section 문제 해결 알고리즘을 구현하기 위해 세마포의 정의는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;wait() 연산의 정의는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;signal() 연산의 정의는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;wakeup()과 sleep()은 프로세스를 일시 중지 or 재실행시키는 운영체제의 기본적인 시스템 콜이다.&lt;/p&gt;

&lt;p&gt;세마포의 프로세스 리스트는 Bounded Waiting를 보장하도록 잘 구현해야만 한다.&lt;/p&gt;

&lt;p&gt;단일 Processor 환경에서는 wait()와 signal() 연산들이 원자적으로 실행되는것을 보장하기 위해 실행되는 동안 인터럽트를 금지함으로써 해결할 수 있지만, 다중 코어 환경에서는 모든 처리 코어에서 인터럽트를 금지하여야만 한다. 이는 매우 어려울 수 있으며 성능을 심각하게 감소시킬 수 있음으로 많은 부분을 고려해야만 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;67-모니터-monitors&quot;&gt;6.7 모니터 (Monitors)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;mutex락 혹은 세마포를 사용할 때에도 타이밍 오류는 여전히 발생할 수 있다. 예로들어, wait()과 signal() 연산의 순서가 뒤바뀌는 경우, Critical Section이 끝나고 signal()대신 wait()이 호출되는 경우&lt;/p&gt;

&lt;p&gt;이러한 오류를 처리하기 위한 한 가지 전략은 간단한 동기화 도구를 통합하여 고급 언어 구조물을 제공하는 것이다. 이번엔 고급 언어 구조물 중 하나인 &lt;strong&gt;모니터(monitor)&lt;/strong&gt;를 살펴보자!!&lt;/p&gt;

&lt;h4 id=&quot;671-모니터-사용법-monitor-usage&quot;&gt;6.7.1 모니터 사용법 (Monitor Usage)&lt;/h4&gt;

&lt;p&gt;추상화된 데이터 형(abstract data type, ADT)은 데이터와 이 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호한다. 이때 함수의 구현은 ADT의 특정한 구현과 독립적이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모니터 형은 모니터 내부에서 프로그래머가 정의한 상호 배제가 보장되는 일련의 연산자 집합을 포함하는 ADT이다.&lt;/strong&gt; 모니터 형은 인스턴스의 상태를 정의하는 변수들과 이를 조작할 수 있는 프로시저 또는 함수들의 본체도 같이 포함하고 있다.&lt;/p&gt;

&lt;p&gt;따라서 모니터 내에 정의된 함수만이 오직 모니터 내에 지역적으로 선언된 변수들과 형식 매개변수들에만 접근할 수 있다. (객체의 캡슐화와 매우 비슷한 구조)&lt;/p&gt;

&lt;p&gt;아래의 그림은 모니터의 개략도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-8.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모니터 구조물은 모니터 안에 항상 하나의 프로세스만이 활성화되도록 보장해 준다.&lt;/strong&gt; 그러나 지금까지 정의한 모니터 구조물은 어떤 동기화 기법을 모델링하는 데에는 충분한 능력을 제공하지 않는다.&lt;/p&gt;

&lt;p&gt;condition이라는 구조물로 동기화 기법들을 제공해 보자. 자신의 동기화 기법을 작성할 필요가 있는 프로그래머는 하나 이상의 condition 형의 변수를 정의할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 condition 형 변수에 호출될 수 있는 연산은 오직 wait()와 signal()이다. x.wait()은 이 연산을 호출한 프로세스는 다른 프로세스가 x.signal()을 호출할 때까지 일시 중지 되어야 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;Java와 C# 등을 포함한 많은 프로그래밍 언어들은 이 절에서 설명한 모니터의 개념을 편입 시켰다.&lt;/p&gt;

&lt;h4 id=&quot;672-세마포를-이용한-모니터의-구현-implementing-a-monitor-using-semaphores&quot;&gt;6.7.2 세마포를 이용한 모니터의 구현 (Implementing a Monitor Using Semaphores)&lt;/h4&gt;

&lt;p&gt;각 모니터마다 mutex라는 이진 세마포가 정의되고 그 초기 값은 1이다. 프로세스는 모니터로 들어가기 전에 wait(mutex)를 실행하고 모니터를 나온 후에 signal(mutex)을 실행해야 한다.&lt;/p&gt;

&lt;p&gt;모니터 구현 시 signal-and-wait 기법을 사용한다. Signaling 프로세스는 실행 재개되는 프로세스가 모니터를 떠나는지 아니면 wait() 할 때까지 그 자신이 다시 기다려야 하므로 next라는 이진 세마포가 추가로 필요하게 되고 0으로 초기화된다.&lt;/p&gt;

&lt;p&gt;signaling 프로세스는 자신을 중단시키기 위해 next를 사용할 수 있다. 정수형 변수 next_count에서도 next에서 일시 중지 되는 프로세스의 개수를 세기 위해 제공된다. 따라서 각 외부 프로시저 F는 아래로 대체된다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 일시 중지된 프로세스가 존재한다면&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// next 프로세스를 실행 재개한다.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 알고리즘을 작성한다면 Mutual Exclusion은 보장된다.&lt;/p&gt;

&lt;h4 id=&quot;673-모니터-내에서-프로세스-수행-재개-resuming-processes-within-a-monitor&quot;&gt;6.7.3 모니터 내에서 프로세스 수행 재개 (Resuming Processes within a Monitor)&lt;/h4&gt;

&lt;p&gt;“조건 변수 x에 여러 프로세스가 일시 중지 되어 있을 때 어떠한 프로세스를 수행 재개시킬 것인가??”에 대해서 논의해 보면 가장 간단한 방법은 FCFS 순이다. 하지만 많은 경우 이러한 간단한 스케줄링 기법은 충분하지 않다.&lt;/p&gt;

&lt;p&gt;이를 위해서 아래와 같은 형식의 &lt;strong&gt;conditional-wait 구조&lt;/strong&gt;를 사용할 수 있다. 이 구조물은 다음과 같은 형태를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x.wait(c);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여기서 c는 정수이고, 우선순위 번호(priority number)라고 불리며 일시 중지 되는 프로세스의 이름과 함께 저장된다. 즉, x.signal()이 수행되면 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 수행 재개 된다.&lt;/p&gt;

&lt;p&gt;이 새로운 기법을 설명하기 위해 아래와 같은 구조를 가진 ADT인 ResourceAllocator 모니터를 예로든다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/synchronization-tools-9.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 모니터는 한 개의 자원을 여러 프로세스 사이에 할당해 준다. 각 프로세스는 자원을 할당받기를 원하면 그 자원을 사용할 최대 시간을 지정한다. 모니터는 이 중 가장 적은 시간을 희망한 프로세스에 자원을 할당해 준다. 이 자원을 액세스하려는 프로세스는 아래의 순서를 따라야 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// R은 ResourceAllocator형 인스턴스이다.&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;access&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;time을 사용해서 한 개의 자원을 접근하는데 무리없이 동작하는 것 처럼 보이지만 사실 다음과 같은 문제가 발생할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 자원에 대한 허락을 받지 않고 자원을 액세스 할 경우&lt;/li&gt;
  &lt;li&gt;프로세스가 자원에 대한 허락을 받은 다음 그 자원을 방출하지 않을 경우&lt;/li&gt;
  &lt;li&gt;프로세스가 자원에 대한 허락을 받지 않았는데도 그 자원을 방출할 경우&lt;/li&gt;
  &lt;li&gt;프로세스가 자원에 대한 허락을 받은 다음 방출하지 않은 상태에서 또 그 자원을 요청할 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 위와 동일한 문제들은 모니터를 사용할 때 뿐만 아니라 세마포를 사용할 때도 동일하게 발생한다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해서 &lt;strong&gt;자원 액세스 연산 자체를 ResourceAllocator 모니터 내부에 두는 방법&lt;/strong&gt;이 있고, 프로세스들이 올바른 순서를 지키도록 보장하기 위해서 &lt;strong&gt;ResourceAllocator 모니터와 모니터가 관리하는 자원을 사용하는 모든 프로그램을 검사&lt;/strong&gt;하는 방법이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;68-라이브니스-liveness&quot;&gt;6.8 라이브니스 (Liveness)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;라이브니스는 프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성을 말한다.&lt;/strong&gt; 즉, 프로세스가 lock을 얻기 위해 무기한 대기하는 것은 “라이브니스 실패”의 한 예이다.&lt;/p&gt;

&lt;p&gt;다양한 형태의 라이브니스 실패가 존재한다. 그러나 모두 성능과 응답성이 나쁜 것이 특징이다. 라이브니스 실패의 매우 간단한 예는 무한 루프이다. 즉, Mutex 락 및 Semaphore를 사용하여 상호 배제를 제공하려는 노력은 종종 병행 프로그래밍에서 이러한 실패로 이어질 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;681-교착-상태-deadlock&quot;&gt;6.8.1 교착 상태 (Deadlock)&lt;/h4&gt;

&lt;p&gt;대기 큐를 가진 Semaphore 구현은 두 개 이상의 프로세스들이, 오로지 대기 중인 프로세스들 중 하나에 의해서만 야기될 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal()연산&lt;/code&gt;를 무한정 기다리는 상황이 발생할 수 있다. 이런 상태에 도달했을 때, 이들 프로세스들을 &lt;strong&gt;교착 상태(deadlock)&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;한 집합 내의 모든 프로세스가 그 집합 내의 다른 프로세스만이 유발할 수 있는 이벤트를 기다릴 때, 이 프로세스들의 집합이 교착 상태에 있다고 말한다.&lt;/strong&gt; 우리가 여기서 주로 관심을 두고 있는 “이벤트”들은 mutex 락과 Sempahore 같은 자원의 획득과 방출이다.&lt;/p&gt;

&lt;h4 id=&quot;682-우선순위-역전-priority-inversion&quot;&gt;6.8.2 우선순위 역전 (Priority Inversion)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;높은 우선순위 프로세스가 현재 낮은 우선순위 프로세스 또는 연속된 낮은 우선순위 프로세스들에 의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 스케줄링의 어려움이 생기게 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;통상 커널데이터는 락에 의해 보호되기 때문에 낮은 우선순위 프로세스가 자원의 사용을 마칠 때까지 높은 우선순위 프로세스가 기다려야 한다. 낮은 우선순위 프로세스가 또 다른 높은 우선순위 프로세스에 의해 선점되는 경우에 상황은 더욱 복잡해진다. 이러한 경우 낮은 우선순위 프로세스는 계속 기다려야만 한다. 이 라이브니스 문제는 &lt;strong&gt;우선순위 역전(priority inversion)&lt;/strong&gt;문제로 알려져 있다.&lt;/p&gt;

&lt;p&gt;통상 우선순위 역전 문제는 &lt;strong&gt;우선순위 상속 프로토콜(priority-inheritance protocol)&lt;/strong&gt;을 구현하여 해결한다. 우선순위 상속 프로토콜의 하나의 예시로서, 더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속받는다. 자원 사용이 끝나면 원래 우선순위로 되돌아간다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;69-평가evaluation&quot;&gt;6.9 평가(Evaluation)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;일반적으로 하드웨어 솔루션은 매우 낮은 수준으로 간주하며 mutex 락과 같은 다른 동기화 도구를 구성하기 위한 기초로 사용된다.&lt;/p&gt;

&lt;p&gt;그러나 최근 lock overhead 없이 경쟁 조건으로부터 보호하는 &lt;strong&gt;lock free algorithm&lt;/strong&gt;을 구현하기 위해 CAS(Compare And Swap) 명령을 사용하는데 중점을 두고 있다. 이러한 락 없는 솔루션은 오버헤드가 낮고 확장성이 있기 때문에 인기를 얻고 있지만 알고리즘 자체는 개발 및 테스트가 어려운 경우가 많다.&lt;/p&gt;

&lt;p&gt;CAS 기반 접근 방식은 낙관적인 접근법으로 간주되고, locking 기반 접근 방식은 비관적 전략으로 간주된다.&lt;/p&gt;

&lt;p&gt;경쟁 조건을 해결하기 위한 기법의 선택은 시스템 성능에도 큰 영향을 줄 수 있다.&lt;/p&gt;

&lt;p&gt;모니터와 조건 변수와 같은 고급 도구의 매력은 단순성과 사용 편의성으로부터 나온다.&lt;/p&gt;

&lt;p&gt;다행스럽게도 병행 프로그래밍의 요구 사항을 해결하는 확장 가능하고 효율적인 도구를 개발하기 위한 많은 연구가 진행되고 있다. 이는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;더 효율적인 코드를 생성하는 컴파일러 설계&lt;/li&gt;
  &lt;li&gt;병행 프로그래밍을 지원하는 언어 개발&lt;/li&gt;
  &lt;li&gt;기존 라이브러리 및 API의 성능 향상&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 7장에서는 개발자가 사용할 수 있는 다양한 운영체제 및 API가 이 장에서 제시된 동기화 도구를 어떻게 구현하는지 알아보도록 하자.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;6장에서는 프로세스 중심의 동기화에 대해서 주로 다루었다. 나는 프로세스 동기화 뿐만 아니라 멀티 스레드를 처리하는 다중 코어 시스템에서 어떻게 스레드간에 동기화를 유지하는지도 궁금하기 때문에 추후 더 공부할 계획이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6장은 여기서 마치도록 하고 7장인 Synchonization Examples에서 뵙도록 하겠다. 꾸벅~&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Nov 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/computer-science(cs)/2020/11/04/Synchronization-Tools.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer-science(cs)/2020/11/04/Synchronization-Tools.html</guid>
        
        <category>Operating-System</category>
        
        <category>CS</category>
        
        <category>Mutex</category>
        
        <category>Lock</category>
        
        <category>Semaphore</category>
        
        <category>Monitor</category>
        
        
        <category>Computer-Science(CS)</category>
        
      </item>
    
      <item>
        <title>DevOps란 무엇인가?</title>
        <description>&lt;p&gt;이 글은 DevOps에 관한 정보를 담고 있는 글이다.&lt;/p&gt;

&lt;p&gt;DevOps는 &lt;a href=&quot;https://github.com/JNU-econovation/webper&quot;&gt;webper 프로젝트&lt;/a&gt;에 적용했던 방법론이기도 하고, 예전부터 공부해 보고 싶어서 DevOps에 대한 많은 문서를 공부해보고 나의 생각 및 관련 자료들을 이 포스팅을 통해 정리하였다.&lt;/p&gt;

&lt;p&gt;“DevOps란 무엇인가?”에 대한 포스팅을 시작으로 프로젝트 개발시 DevOps를 달성(?)할 수 있는 여러 자동화 툴들과 인프라 구성 방법에 대해서 탐구할 생각이다!! 물론 이들 또한 포스팅으로 정리해 올릴 생각이기 때문에 독자 여러분들이 많은 관심을 주셨으면 좋겠다.&lt;/p&gt;

&lt;p&gt;지금부터 DevOps에 대해서 알아가기 위해 긴 여정을 떠나도록 하겠다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-devops란-무엇인가&quot;&gt;1. DevOps란 무엇인가?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;DevOps란 무엇인가에 대해서 소개하기 앞서 DevOps는 “문화”인가? “방법론”인가? “추상적인 개념”인가? “도구”인가? “철학”인가?에 대해서 단 하나로 정의하기는 쉽지 않다. DevOps는 문화이면서, 특정한 목적을 이루는 방법론이고, 철학이기도 하다. 개인적으로는 &lt;u&gt;DevOps는 목적을 이루기 위한 방법론&lt;/u&gt;으로써 표현하는 것이 가장 맞는 것 같기도 하다.&lt;/p&gt;

&lt;p&gt;DevOps에 관한 많은 글을 읽어본 나의 입장에서 생각해 봤을 때 DevOps를 하나의 카테고리로 구분하기에는 참 쉽지 않다. 각 문서가 설명하는 DevOps에 대한 정의는 각각 다르지만, &lt;strong&gt;DevOps를 통해 이루고자 하는 바는 모두 동일하다.&lt;/strong&gt; 그래서 나는 DevOps를 설명하기위해 하나의 개념으로 정의하기 보다는 DevOps를 통해 이루고자 하는 바를 명시해 주어 이를 통해 독자가 다양한 생각을 할 수 있게끔 제시해주고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DevOps는 Dev(개발)와 Ops(운영)를 합쳐 비즈니스(User)의 요구사항을 단기간에 반영할 수 있는 품질 높은 소프트웨어를 만들고자 하는 목적을 가진다. 이를 통해 팀 내의 협업이 증진되는 것은 덤이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;저자는 DevOps 목적을 이루기 위해 다양한 아키텍처, 자동화 툴, Ias, VCS, Cloud, … 등이 사용될 수 있다고 생각하지만 이러한 방법들이 곧 DevOps라고는 절대 생각하지 않는다. 현재 진행중인 프로젝트의 상황에 맞추어서 잘 사용하면 된다고 생각한다. 하지만 이러한 방법들을 적용하는데 있어서 Best Practice는 존재하니 독자들은 참고하기 바란다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-devops가-도입되기-전-전통적인-개발-방법론의-문제점과-해결책&quot;&gt;2. DevOps가 도입되기 전 전통적인 개발 방법론의 문제점과 해결책&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;전통적인 개발 방법론의 문제점에 대해서 정말 잘 정리해 준 &lt;a href=&quot;https://happycloud-lee.tistory.com/45&quot;&gt;포스팅&lt;/a&gt;이 존재한다. 저자는 개발 경력이 짧아서 전통적인 개발 방법론의 문제점에 대해서 절실히 느껴본 적이 없으니 이를 참고해서 글을 작성하도록 하겠다.&lt;/p&gt;

&lt;h3 id=&quot;전통적인-개발-운영-체계&quot;&gt;전통적인 개발 운영 체계&lt;/h3&gt;

&lt;p&gt;일반적인 개발 운영 체계는 아래의 그림과 같다. 개발팀에 의해서 개발이 끝나면, 시스템은 테스트를 거쳐서 운영팀에 이관되고, 운영팀은 해당 시스템을 배포 및 관리 운영한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/what-is-the-devops-1.png&quot; style=&quot;width:30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;운영팀으로 이관된 시스템들은 개발팀이 거의 관여하지 않고, 운영팀에 의해서 운영된다.&lt;/u&gt;&lt;/p&gt;

&lt;h3 id=&quot;probelm-1-문제-발생&quot;&gt;Probelm 1. 문제 발생&lt;/h3&gt;

&lt;p&gt;시스템을 운영하다 보면, 반드시 장애나 이슈가 생기기 마련이다. 개발팀은 애플리케이션을 볼 수는 있지만, 아랫단의 인프라 시스템은 볼 수 있는 능력이 없다. 반대로 운영팀은 인프라 시스템은 잘 알지만, 애플리케이션 자체에 대해서는 잘 알지 못한다.&lt;/p&gt;

&lt;p&gt;문제가 발생했을 경우 운영팀과 개발팀에서 문제의 정확한 이유를 도출해내서 관련된 팀에게 문제 처리를 맡기면 되지만 위에 말한 것 처럼 각 팀은 서로의 분야 이외에는 알지 못하기 때문에 본인이 아는 지식 범위 밖에서 문제가 발생된다면 이것은 무조건 나의 잘못이 아니라고 간주해 다른 팀에게 처리를 떠넘기는 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;이러한 상황들을 개념으로 정의한 것이 있는데 이게 &lt;strong&gt;Fingerpointyness&lt;/strong&gt; 이다. &lt;strong&gt;Fingerpointyness란 정확하게 누가 어떤 문제를 해결해야 하는지 정의되지 않은 상황에서, 협업이 없어지고 문제 해결이 엉뚱한 방향으로 가는 현상을 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Fingerpointyness의 절차는 아래의 그림과 같으며, 자세히 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/devops/what-is-the-devops-2.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Freaking out &amp;amp; find fault (문제 발견)&lt;/strong&gt; : 문제가 발생하고 내용을 파악하는 단계이다. 자기 분야에서 문제가 어떤 것인지, 한정된 지식으로 현상 자체를 인지하는 수준이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Blaming Covering ass 단계 (욕하기)&lt;/strong&gt; : 정확한 원인이 아닌 문제의 현상이 파악되면 본인이 아는 지식 범위 이외일 경우 서로 미루기를 한다. 문제가 미루어진 쪽이 문제의 원인이라면 다행이지만 아닌 경우 서로 미루게 되면서 문제의 근본적인 원인은 해결되지 않고 시간만 계속 간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Whining, Hiding, Hurt Ego 단계 (맘 상처 입기)&lt;/strong&gt; : 계속해서 서로에게 문제를 넘기다 보면, 문제를 숨기거나 상대방을 헐뜯거나 하면서 결국은 서로는 상처를 입게 되고, 점점 커뮤니케이션은 없어지고 관계는 악화된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Figuring it out (문제 원인 분석)&lt;/strong&gt; : 문제가 해결되어야 하는 시간이 가까워져 오면, 문제를 풀긴 풀어야 하니 어떻게든지 스스로 모여서 문제를 같이 보게 되거나, 상위 매니저를 통하여 강제적으로 모여 문제에 대한 원인 분석을 해서 결국 원인을 파악하게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fixing things(문제 해결)&lt;/strong&gt; : 결과적으로 원인 파악 및 문제가 해결된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;결국엔 문제가 해결되어 다행이지만, 팀 간에 남겨진 협업 문제는 해결되지 못하고 점점 쌓여만 간다…&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem-2-운영-이슈에-대한-전달-문제&quot;&gt;Problem 2. 운영 이슈에 대한 전달 문제&lt;/h3&gt;

&lt;p&gt;개발팀은 서비스를 배포한 후 운영에는 거의 관심을 두지 않기 때문에, 고객과의 접점이 거의 없다. 하지만 User의 요구사항(VoC)을 받는 쪽은 운영팀이기 때문에 이러한 요구사항을 전달받아 개발팀에게 넘겨주게 되는데… 개발팀이 당연히 좋아할 일이 없다.&lt;u&gt;(비즈니스(User)의 요구사항을 전달할 권한이 없는 운영팀이 일을 주어서 개발팀의 일이 늘어나는데 어떠한 개발자가 좋아하겠는가??)&lt;/u&gt; 결국 이러한 운영팀의 요구사항들은 개발팀에게 거절되기 쉽고 서비스기획(비즈니스) 팀에게 넘어가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;수 많은 소프트웨어가 존재하는 현 시대에 소프트웨어가 살아남기 위해서는 사용자의 요구사항을 즉각적으로 반영해야만 하는데 개발과 운영의 분리는 이러한 트렌드와의 거리를 점점 멀어지게 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem-3-변경-요건&quot;&gt;Problem 3. 변경 요건&lt;/h3&gt;

&lt;p&gt;서비스가 운영 배포된 후에도, 비즈니스(기획팀)에 의해서, 서비스에 대한 신규 요구 사항은 계속적으로 나오게 되고, 새로운 변경 요건은 신규 개발과, 테스트 배포 그리고 지속적인 운영을 요구 하게 된다.&lt;/p&gt;

&lt;p&gt;하지만 잦은 요구사항은 코드의 잦은 변경과 배포를 요구하게 되고 제대로된 테스트를 거치지 못한 경우 잦은 장애를 유발하게 된다.&lt;/p&gt;

&lt;p&gt;이러한 배경으로 인해서 운영팀은 잦은 배포를 꺼려하게 되고, 조금 더 전통적이고 형식적인 관점에서 주기적인 릴리즈와 테스트를 요구하게 된다. &lt;strong&gt;더 잦은 장애가 발생됨으로 인해서 장애에 대한 적절한 대응책이 없다면 개발팀과 운영팀의 관계는 더 악화 되어 간다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;우리는 어떠한 방식으로 위의 문제들을 해결할 수 있을까??&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결론은 개발팀과 운영팀 사이에 존재하는 벽을 허물고 팀 간에 협업을 통해 비즈니스(User)의 요구사항을 단기간에 반영할 수 있는 높은 품질의 소프트웨어를 개발해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 문제들을 해결하기 위해서 나온 것이 &lt;strong&gt;DevOps&lt;/strong&gt;이다. 즉, 개발과 운영을 합쳐 사용자의 의견에 민감하게 반응하는 높은 품질을 소프트웨어를 만들자는 목적을 가진다.&lt;/p&gt;

&lt;p&gt;하지만 개발과 운영.. 하나만 제대로 하기에도 벅찬데 어떻게 2개를 한번에 한다는 말인가??&lt;/p&gt;

&lt;p&gt;같이 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-devops와-같은-좋은-개념이-왜-이제서야-발전하게-되었는가&quot;&gt;3. DevOps와 같은 좋은 개념이 왜 이제서야 발전하게 되었는가?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;개발과 운영을 동시에 하는것은 당연히 어렵다. 개발과 운영은 영역 자체가 매우 상이하고, 요구되는 기술 능력도 많이 차이나기 때문에, 일반적인 엔지니어가 양쪽을 모두 커버하기가 어렵다.&lt;/p&gt;

&lt;p&gt;하지만 근래에는 조금 쉬워졌다. 이러한 이유는 다음과 같다.&lt;/p&gt;

&lt;h3 id=&quot;인터넷의-발전&quot;&gt;인터넷의 발전&lt;/h3&gt;
&lt;p&gt;인터넷의 엄청난 발전 덕분에 우리는 원하는 정보 대부분을 인터넷을 통해 얻을 수 있다. 아니 전부라고 해도 이상하지 않다. 과거에는 주로 서적 및 교육을 통해서 지식을 얻었다면 요즘은 인터넷, 오픈 소스, Youtube, SlideShare 등의 다양한 플랫폼들을 통해서 지식을 습득할 수 있게 되었다. 본인이 원하는 정보는 다 인터넷 속에 있으니 이 얼마나 좋은 시대인가??&lt;/p&gt;

&lt;h3 id=&quot;오픈-소스의-발전&quot;&gt;오픈 소스의 발전&lt;/h3&gt;
&lt;p&gt;인터넷이 발전하면서, IT의 흐름이 크게 바뀐 것중에 하나는 더 이상 오라클이나 IBM과 같은 대형 벤더의 주도 기술이 아니라 페이스북이나 구글과 같은 거대 B2C 서비스가 IT의 흐름을 이끌기 시작했고, 이러한 업체들이 오픈소스를 적극적으로 후원 및 장려하기 시작했다. 오픈 소스에서 많은 지식들을 배울 수 있으며, 전세계의 개발자들과 이야기할 수도, 일을 할 수도 있게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;좋은-도구들의-발전&quot;&gt;좋은 도구들의 발전&lt;/h3&gt;
&lt;p&gt;오픈 소스의 발전으로 인해, 좋은 툴들이 많아 졌다. 개발에 관련된 툴 뿐만 아니라, 빌드, 배포, 모니터링에 대한 툴도 많아졌기 때문에, 운영 업무에 해당 하는 부분들을 상당 부분 자동화를 할 수 있게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;클라우드의-등장&quot;&gt;클라우드의 등장&lt;/h3&gt;
&lt;p&gt;클라우드 컴퓨팅의 가장 큰 특징 중의 하나는 사용자가 인프라(서버 설치, 네트워크 케이블 구성)를 구성할 필요가 없이, 간단하게 책상 앞에 앉아서 웹사이트를 몇번 클릭 하는 것만으로도 지구 반대편의 데이터 센터에 서버, 스토리지 구성, 네트워크 구성이 가능하게 되었다는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;
&lt;p&gt;개발을 할 때 필요한 모듈을 오픈 소스를 조합해서 만들 수 있으며, 좋은 도구들을 통해서 빌드나 배포등을 쉽게 자동화할 수 있게 되었고, 클라우드를 통해 개발자도 네트워크, 서버등에 대한 설정들을 할 수 있어지고, 부족한 정보들은 인터넷을 통해 얻을 수 있게 되었다. &lt;strong&gt;결과적으로 개발자가 할 수 있는 영역이 더욱 더 넓어져 인프라에 대한 전문 지식 없이도, 인터넷과 오픈 소스 그리고 클라우드의 도움을 받아서, 운영을 같이할 수 있는 환경이 마련됬다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-devops를-도입함으로써-얻는-장점은-무엇인가&quot;&gt;4. DevOps를 도입함으로써 얻는 장점은 무엇인가?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;DevOps를 도입함으로써 팀은 다양한 혜택들을 얻을 수 있다. 물론 DevOps가 장점만 가져다 주는 건 아니지만, DevOps를 도입하기에 적절한 비즈니스 환경을 가지고 있는 조직의 경우 실보다는 득이 훨씬 많을 것이라고 생각된다. (나는 DevOps 찬양론자가 아니다.)&lt;/p&gt;

&lt;p&gt;DevOps를 도입함으로써 얻을 수 있는 혜택에 대해서 몇가지 정리해 보았는데 참고 해 보자.&lt;/p&gt;

&lt;h3 id=&quot;speed-속도&quot;&gt;Speed (속도)&lt;/h3&gt;
&lt;p&gt;DevOps를 도입한 팀은 운영과 개발에 경계가 없어짐으로 작업 속도가 빨라지고 고객을 위해 더 빠르게 혁신하고, 시장 변화에 더 잘 적응하고, 좀 더 효율적으로 비즈니스 성과를 창출할 수 있다. 예를 들어 MSA와 CI/CD를 사용하면 팀에서 서비스를 주도적으로 운영하여 업데이트를 좀 더 빠르게 릴리스 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;rapid-delivery-신속한-전달&quot;&gt;Rapid Delivery (신속한 전달)&lt;/h3&gt;
&lt;p&gt;DevOps는 릴리스의 빈도와 속도를 개선하여 제품을 더 빠르게 혁신하고 개선할 수 있다. 새로운 기능의 릴리스와 버그 수정 속도가 빨라질수록 비즈니스(User)의 요구에 더 빠르게 대응하여 경쟁 우위를 강화할 수 있다. 이 과정에서 CI(Continuous Integration) / CD(Continuous Delivery)를 사용할 수 있는데 이는 빌드에서 배포까지 소프트웨어 릴리스 프로세스를 자동화하는 방식입니다.&lt;/p&gt;

&lt;h3 id=&quot;reliability-안전성&quot;&gt;Reliability (안전성)&lt;/h3&gt;
&lt;p&gt;DevOps는 최종 사용자에게 지속적으로 긍정적인 경험을 제공하는 한편 더욱 빠르게 안정적으로 제공할 수 있도록 어플리케이션 업데이트와 인프라 변경의 품질을 보장한다. CI/CD와 같은 방식을 사용하여 각 변경 사항이 제대로 작동하며 안전한지 테스트하고, Monitoring과 Logging방식을 통해 실시간으로 성능에 대한 정보를 얻을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;scale-확장&quot;&gt;Scale (확장)&lt;/h3&gt;
&lt;p&gt;DevOps는 개발자가 규모에 따라 인프라와 개발 프로세스를 운영 및 관리한다. 자동화와 일관성이 지원되므로 위험을 줄이면서 복잡한 시스템 또는 변화하는 시스템을 효율적으로 관리할 수 있다. 예를 들어 Iac(Infrastructure as Code)를 사용하면 개발, 테스트 및 프로덕션 환경을 반복 가능하고 더 효율적인 방식으로 관리할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;improved-collaboration-협업-향상&quot;&gt;Improved Collaboration (협업 향상)&lt;/h3&gt;
&lt;p&gt;주인의식 및 책임과 같은 가치를 강조하는 DevOps 모델에서는 Product/Service 개발에 좀 더 효과적인 팀을 구축한다. 개발자와 운영팀은 긴밀하게 협업하고, 많은 책임을 공유하며, 워크플로를 결합한다. 이를 통해 비효율성을 줄이고 시간을 절약하고 소프트웨어의 품질을 높일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;security-보안&quot;&gt;Security (보안)&lt;/h3&gt;
&lt;p&gt;DevOps는 제어를 유지하고 준수하면서 신속하게 개발을 진행할 수 있다. 자동화된 규정 준수 정책, 세분화된 제어 및 구성 관리 기술을 사용함으로써 보안을 그대로 유지하면서 DevOps 모델을 도입할 수 있다. 예를 들어 Iac와 코드형 정책을 사용하면 규모에 따라 규정 준수를 정의하고 추적할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-devops의-특징은-무엇인가&quot;&gt;5. DevOps의 특징은 무엇인가?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;DevOps에는 아주 다양한 특징들이 있지만, 몇 가지만 정리해보도록 하겠다.&lt;/p&gt;

&lt;h3 id=&quot;product-based-teams-over-component-teams-product-기반-팀-구조&quot;&gt;Product-Based Teams Over Component Teams (Product 기반 팀 구조)&lt;/h3&gt;
&lt;p&gt;DevOps는 기존의 Dev, QA, Ops 등으로 이루어진 Component 기반의 팀 대신에, Product/Service 기반의 팀 구조를 사용한다. Product/Service 기반의 팀 구조를 도입하게 된다면 개발과 운영 사이의 사일로를 제거할 수 있어 DevOps를 성공적으로 도입할 수 있는 확률이 높아진다.&lt;/p&gt;

&lt;h3 id=&quot;automating-repetitive-tasks-반복적인-작업의-자동화&quot;&gt;Automating repetitive tasks (반복적인 작업의 자동화)&lt;/h3&gt;
&lt;p&gt;모든 수작업은 자동화된 작업에 비해 위험이 증가되기 때문에, DevOps 팀은 자동화에 집착해야 한다. 이러한 자동화 작업 툴들은 주로 운영 업무에서 많이 쓰이는데, 일반적으로 우리가 CI(Continuous Integration)이나 CD(Continuous Delivery)등을 이용해 다루는 빌드, 배포, 테스트 자동화들이 이에 속한다. 반복적인 작업의 자동화를 통해서 개발 자원들의 작업 효율을 높이고 빠른 서비스 업데이트를 가능하게 하며, 자동화 시스템 구축을 통해서 전체 시스템에 대한 이해도를 높일 수 있게 한다.&lt;/p&gt;

&lt;h3 id=&quot;widely-shared-metrics-전체에-공유되어지는-지표&quot;&gt;Widely Shared Metrics (전체에 공유되어지는 지표)&lt;/h3&gt;
&lt;p&gt;DevOps는 팀 전체가 기준으로 삼을 수 있는 서비스에 대한 공통적인 지표(Metric)가 필요하다. 서비스를 개발하고 개선했을 때, 이를 평가하고 현재의 서비스의 진행 상태 (성공 여부, 시스템의 안정성, 사용자의 반응 등)를 인지할 수 있는 기준이 필요하다는 것이다. 또한 이러한 데이터를 기반으로 하는 의사 결정은 DevOps 조직의 주요 측면 중 하나이다.&lt;/p&gt;

&lt;h3 id=&quot;teamwork-over-individual-work-개인적인-업무-보다는-팀워크&quot;&gt;Teamwork Over Individual Work (개인적인 업무 보다는 팀워크)&lt;/h3&gt;
&lt;p&gt;DevOps 팀은 높은 수준의 전문성과 엔지니어링을 필요로 한다. 전문성은 올바른 일을 할 수 있는 능력, “아니오”라고 말할 수 있는 용기, 기꺼이 도움을 요청하고, 정중하게 동의하지 않으며, 서로 개방적이고 정직한 협업을 할 수 있는 능력을 반영한다. 팀 내의 구성원들이 동의하지 않거나 논쟁하거나 비판할 때 서로를 무시해서는 안되고 사람이 아니라 아이디어에 동의하지 않아야 한다.&lt;/p&gt;

&lt;h3 id=&quot;fail-fast-over-delayed-learning-빠른-실패를-통한-학습&quot;&gt;Fail Fast Over Delayed Learning (빠른 실패를 통한 학습)&lt;/h3&gt;
&lt;p&gt;성숙한 DevOps 팀은 실수로부터 배우기 위해 &lt;a href=&quot;https://dzone.com/articles/devops-postmortems-why-and-how-to-use-them&quot;&gt;post mortems&lt;/a&gt;을 수행하고 관련된 자료들은 조직 전체에 공유되어진다. 여기에는 효과적인 피드백 루프와 높은 수준의 자동화를 필요로 한다. 이 외에도 성숙한 DevOps 팀은 서로를 신뢰하고 서로 도전하며 지속적인 개선을 추구하는 문화를 가지고 있다. 실수가 빨리 공유되어지고 이를 철저히 분석함으로써 조직은 한 걸음 더 성장할 수 있는 기회를 빨리 접한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6-devops-toolchain&quot;&gt;6. DevOps ToolChain&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;DevOps ToolChain이란 DevOps를 적용하기 위해 도와주는 특정한 툴들의 조합이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DevOps는 기술 보다는 관행에 가깝기 때문에 소프트웨어 개발의 모든 단계를 정의할 수 있는 단일 도구는 없어 DevOps의 적용을 도와주는 Tool들의 집합인 ToolChain이 형성되었다.&lt;/p&gt;

&lt;p&gt;ToolChain을 적절히 활용하면 DevOps의 목적인 비즈니스(User)의 요구사항을 단기간에 반영할 수 있는 품질 높은 소프트웨어를 만들 수 있는 확률이 높아진다. ToolChain에 속해있는 Tool들을 DevOps를 이루기 위한 Best Practice라고 보아도 좋지만 이를 사용한다고 해서 DevOps가 도입되는 것은 아니라고 생각한다. 즉, ToolChain을 사용하여 빠른 배포, 코드의 품질 향상 등의 목적을 이룰 수 있지만 이들을 도입한다고 해서 무조건적으로 이루어지는 것은 아니기 때문에 팀 내에서 DevOps를 이루기 위한 노력을 꾸준히 해야된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반적으로 Toolchain이란 tool들이 연속적으로 실행되고 각각의 tool에 대한 결과 또는 출력이 다음 tool에 대한 시작 환경 또는 입력이 되는 것을 의미하지만, &lt;u&gt;요즘 toolchain은 연속으로 실행되지 않는 관련있는 툴들의 집합을 언급할 때도 사용된다.&lt;/u&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;devops를-위한-핵심-카테고리들에-대해서-알아보고-관련된-특정-tool에-대해서도-알아보자&quot;&gt;DevOps를 위한 핵심 카테고리들에 대해서 알아보고 관련된 특정 tool에 대해서도 알아보자.&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;표현 방식&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Category
      &lt;ul&gt;
        &lt;li&gt;Specific Tool Involved&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Planning (기획)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;GitLab&lt;/li&gt;
      &lt;li&gt;Tasktop&lt;/li&gt;
      &lt;li&gt;CollabNet’s VersionOne&lt;/li&gt;
      &lt;li&gt;Trello&lt;/li&gt;
      &lt;li&gt;Azure Boards&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Issue Tracking (이슈 추적)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Atlassian’s Jira&lt;/li&gt;
      &lt;li&gt;JetBrains’ YouTrack&lt;/li&gt;
      &lt;li&gt;Zendesk&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Source Control (소스 코드 관리)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Git&lt;/li&gt;
      &lt;li&gt;GitHub&lt;/li&gt;
      &lt;li&gt;GitLab&lt;/li&gt;
      &lt;li&gt;Bitbucket&lt;/li&gt;
      &lt;li&gt;Subversion&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Build Tools (빌드 도구)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Maven / gradle&lt;/li&gt;
      &lt;li&gt;MSBuild&lt;/li&gt;
      &lt;li&gt;Rake&lt;/li&gt;
      &lt;li&gt;JFrog Artifactory&lt;/li&gt;
      &lt;li&gt;NuGet&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Tesing Tools (테스팅 도구)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;JUnit&lt;/li&gt;
      &lt;li&gt;xUnit.net&lt;/li&gt;
      &lt;li&gt;Selenium&lt;/li&gt;
      &lt;li&gt;Jasmine&lt;/li&gt;
      &lt;li&gt;Cucumber&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Continuous Integration (지속적인 통합)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Jenkins&lt;/li&gt;
      &lt;li&gt;Travis CI&lt;/li&gt;
      &lt;li&gt;Circle CI&lt;/li&gt;
      &lt;li&gt;AWS CodePipeline&lt;/li&gt;
      &lt;li&gt;Concourse&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Continuous Deployment(Delivery) (지속적인 전달(배포))&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Spinnaker&lt;/li&gt;
      &lt;li&gt;Octopus Deploy&lt;/li&gt;
      &lt;li&gt;AWS CodeDeploy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Configuration-Management Tools (설정 관리 도구)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Terraform&lt;/li&gt;
      &lt;li&gt;BOSH&lt;/li&gt;
      &lt;li&gt;Chef&lt;/li&gt;
      &lt;li&gt;Ansible&lt;/li&gt;
      &lt;li&gt;Puppet&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cloud Playform (클라우드 플랫폼)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Amazon Web Service(AWS)&lt;/li&gt;
      &lt;li&gt;Microsoft Azure&lt;/li&gt;
      &lt;li&gt;Google Cloud Platform&lt;/li&gt;
      &lt;li&gt;Container Schedulers(k8s, Docker Swarm, …)&lt;/li&gt;
      &lt;li&gt;Heroku&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Monitoring and Logging Tools (모니터링 및 로깅 도구)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ELK Stack&lt;/li&gt;
      &lt;li&gt;Pinpoint&lt;/li&gt;
      &lt;li&gt;Zipkin&lt;/li&gt;
      &lt;li&gt;New Relic&lt;/li&gt;
      &lt;li&gt;Prometheus&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Communication Tools (의사소통 도구)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Slack&lt;/li&gt;
      &lt;li&gt;Microsoft Teams&lt;/li&gt;
      &lt;li&gt;Google Hangouts&lt;/li&gt;
      &lt;li&gt;Zoom&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Knowledge Sharing Tools (지식 공유 도구)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;GitHub Pages&lt;/li&gt;
      &lt;li&gt;Confluence&lt;/li&gt;
      &lt;li&gt;Jekyll&lt;/li&gt;
      &lt;li&gt;Google Sites&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 다양한 카테고리들은 DevOps를 수행하는데 전반적으로 도움이되는 카테고리들이다. DevOps ToolChain은 팀에서 지속 가능한 방식으로 고객에게 지속적으로 가치를 제공하고 차별화를 지원하는 위치에서 사용되어져야 한다고 생각한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DevOps ToolChain은 DevOps를 이루기 위한 Best Practice이지만, 이는 DevOps의 목적을 이루기 위한 하나의 수단일 뿐이지 유일한 수단이 아니라는 점을 다시 한번 강조하며 이번 포스팅을 마치도록 하겠다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다음에는 DevOps를 이루기 위한 중요한 부분인 CI/CD 시리즈로 찾아뵙도록 하겠습니다. 꾸벅~&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;참고&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dzone.com/articles/5-characteristics-of-a-devops-organisation&quot;&gt;https://dzone.com/articles/5-characteristics-of-a-devops-organisation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dzone.com/articles/the-devops-toolchain&quot;&gt;https://dzone.com/articles/the-devops-toolchain&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DevOps_toolchain&quot;&gt;https://en.wikipedia.org/wiki/DevOps_toolchain&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/devops/what-is-devops/&quot;&gt;https://aws.amazon.com/ko/devops/what-is-devops/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bcho.tistory.com/815&quot;&gt;https://bcho.tistory.com/815&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bcho.tistory.com/817&quot;&gt;https://bcho.tistory.com/817&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DevOps&quot;&gt;https://en.wikipedia.org/wiki/DevOps&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Many Documents&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 28 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devops/2020/10/28/What-is-The-DevOps.html</link>
        <guid isPermaLink="true">http://localhost:4000/devops/2020/10/28/What-is-The-DevOps.html</guid>
        
        <category>DevOps</category>
        
        <category>CI/CD</category>
        
        <category>Cloud</category>
        
        <category>Cooperation</category>
        
        
        <category>DevOps</category>
        
      </item>
    
      <item>
        <title>[Operating System - Chapter 5] CPU 스케줄링</title>
        <description>&lt;p&gt;이 포스팅은 공룡책으로 알려진 Operating System Concepts의 5장인 &lt;strong&gt;CPU Scheduling&lt;/strong&gt;를 공부하면서 정리한 포스팅이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-cpu-스케줄링-cpu-scheduling&quot;&gt;5. CPU 스케줄링 (CPU Scheduling)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;CPU 스케줄러는 다중 프로그램 운영체제의 기본이다. &lt;strong&gt;운영체제는 CPU를 프로세스 간에 교환함으로써, 컴퓨터를 보다 생산적으로 만든다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최신 운영체제에서는 실질적으로 프로세스가 아니라 커널 수준 스레드를 스케줄 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CPU, Core, Processor, Thread 용어 설명&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Processor&lt;/strong&gt; &lt;a href=&quot;https://techterms.com/definition/processor&quot;&gt;참조 링크&lt;/a&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;프로세서란 컴퓨터와 전자기기들에 내장된 작은 칩을 말한다.&lt;/li&gt;
    &lt;li&gt;프로세서의 기본적인 역할은 입력을 받아서 적절한 출력을 제공하는 것이다.&lt;/li&gt;
    &lt;li&gt;이러한 작업들은 간단한 작업처럼 보일 수 있지만 최신 프로세서는 초당 수 조 개의 계산을 처리할 수 있다.&lt;/li&gt;
    &lt;li&gt;프로세서의 한 종류로써 마우스 및 키보드 입력 처리, 응용 프로그램 실행과 같은 모든 기본 시스템 명령을 처리하는 
&lt;strong&gt;컴퓨터의 중앙 프로세서인 CPU(Central Processing Unit)&lt;/strong&gt;이 있다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;&lt;strong&gt;중앙처리장치(CPU)&lt;/strong&gt; &lt;a href=&quot;https://www.quora.com/What-is-the-difference-between-a-processor-and-a-CPU-Are-they-the-same-or-different&quot;&gt;참조 링크&lt;/a&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;프로세서의 주된 유형이며, 하나 이상의 코어로 구성됩니다.&lt;/li&gt;
    &lt;li&gt;코어들은 병렬적으로 수행하지만, 다른 데이터 스트림에서 다른 명령 스트림을 사용하여 별도의 계산을 수행할 수 있다.&lt;/li&gt;
    &lt;li&gt;CPU 코어들은 코어 자신이 소유하고 있거나, 공유되어지는 캐쉬를 가진다. 캐쉬는 메인메모리에 대한 데이터 내용을 미러링 하는 작은 데이터 블록입니다.&lt;/li&gt;
    &lt;li&gt;CPU 코어들은 모든 컴퓨팅 연산을 가능하게하는 일반적인 목적 프로세서 입니다.&lt;/li&gt;
    &lt;li&gt;컴퓨터는 일반적으로 다른 타입의 프로세서들인 GPU, MCP등을 가진다.&lt;/li&gt;
    &lt;li&gt;모든 CPU들은 프로세서이지만, 모든 프로세서는 CPU가 아니다!!! &lt;strong&gt;즉, CPU는 프로세서의 타입이다!&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;코어(Core) : CPU의 기본 계산 단위&lt;/p&gt;

  &lt;p&gt;스레드(Thread) : CPU 이용의 기본 단위&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;51-기본-개념-basic-concepts&quot;&gt;5.1 기본 개념 (Basic Concepts)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는데 있다.&lt;/strong&gt; 어떤 프로세스가 대기해야 할 경우, 운영체제는 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.&lt;/p&gt;

&lt;p&gt;즉, &lt;u&gt;CPU 이용률을 최대화 하는 것은 다중 프로세서 운영체제 설계의 핵심&lt;/u&gt;이 된다.&lt;/p&gt;

&lt;h4 id=&quot;511-cpu---io-버스트-사이클-cpu---io-burst-cycle&quot;&gt;5.1.1 CPU - I/O 버스트 사이클 (CPU - I/O Burst Cycle)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로세스의 실행은 CPU Burst로 시작된다. 뒤이어 I/O Burst가 발생하고, 그 뒤를 이어 또 다른 CPU Burst가 발생하며, 이어 또 다른 I/O Burst 등등으로 진행된다. 결국 아래의 그림처럼 마지막 CPU Burst는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-1.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU Burst들의 지속시간을 광범위하게 측정한 그래프는 CPU 스케줄링 알고리즘을 구현할 때 매우 중요하다.&lt;/p&gt;

&lt;h4 id=&quot;512-cpu-스케줄러cpu-scheduler&quot;&gt;5.1.2 CPU 스케줄러(CPU Scheduler)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행&lt;/strong&gt;해야 한다. 선택 절차는 &lt;strong&gt;CPU 스케줄러(CPU Scheduler)&lt;/strong&gt;에 의해 수행된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ready Queue는 반드시 FIFO 방식의 큐가 아니어도 되고, 우선순위 큐, 트리 등으로 구현될 수 있다. 일반적으로 큐에 있는 레코드들은 프로세스의 프로세스 제어 블록(PCB)들 이다.&lt;/p&gt;

&lt;h4 id=&quot;513-선점-및-비선점-스케줄링-preemptive-and-nonpreemptive-scheduling&quot;&gt;5.1.3 선점 및 비선점 스케줄링 (Preemptive and Nonpreemptive Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;CPU 스케줄링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)&lt;/li&gt;
  &lt;li&gt;프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)&lt;/li&gt;
  &lt;li&gt;프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)&lt;/li&gt;
  &lt;li&gt;프로세스가 종료할 때&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;비선점 스케줄링(nonpreemptive)하에서는, 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.&lt;/strong&gt; (1, 4번)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;선점 스케줄링(preemptive)은 시분할 시스템에서 타임 슬라이스가 소진되었거나, 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, 현 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다.&lt;/strong&gt; (2, 3번)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터가 다수의 프로세스에 의해 공유될 때 racing condition이 발생될 수 있다.&lt;/li&gt;
  &lt;li&gt;mutex lock, monitor 등의 기법을 사용해서 racing condition을 피한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;race condition (경쟁 상태)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;경쟁 상태(race condition)란 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다. 입력 변화의 타이밍이나 순서가 예상과 다르게 작동하면 정상적인 결과가 나오지 않게 될 위험이 있는데 이를 경쟁 위험이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;인터럽트는 어느 시점에서건 일어날 수 있고, 커널에 의해서 항상 무시될 수는 없기 때문에, 인터럽트에 의해서 영향을 받는 코드 부분은 반드시 &lt;strong&gt;동시 사용으로부터 보호&lt;/strong&gt;되어야 한다.&lt;/p&gt;

&lt;h4 id=&quot;514-디스패처-dispatcher&quot;&gt;5.1.4 디스패처 (Dispatcher)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;디스패처(Dispatcher)는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈&lt;/strong&gt;이며 다음과 같은 작업을 진행한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한 프로세스에서 다른 프로세스로 문맥을 교환하는 일&lt;/li&gt;
  &lt;li&gt;사용자 모드로 전환하는 일&lt;/li&gt;
  &lt;li&gt;프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump) 하는 일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 &lt;strong&gt;디스패치 지연(dispatch latency)&lt;/strong&gt;라고 하고 아래의 그림과 같이 일어난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-2.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;문맥 교환은 자발적 문맥 교환과 비자발적 문맥 교환으로 나뉜다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;자발적 문맥 교환:&lt;/strong&gt; 현재 사용 불가능한 자원을 요청했을 때 프로세스가 CPU 제어를 포기한 경우 발생&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비자발적 문맥 교환:&lt;/strong&gt; 타임 슬라이스가 만료되었거나 우선순위가 더 높은 프로세스에 의해 선점되는 경우와 같이 CPU를 빼앗겼을 때 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;52-스케줄링-기준-scheduling-criteria&quot;&gt;5.2 스케줄링 기준 (Scheduling Criteria)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;여러 CPU 스케줄링 알고리즘 사이에서 하나를 선택하기 위한 CPU 스케줄링 비교 기준은 다음과 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 이용률(Utilization): 어느 기간 동안 또는 특정 SNAPSHOT에서의 CPU의 이용률을 말한다.&lt;/li&gt;
  &lt;li&gt;처리량(Throughput): 단위 시간당 완료된 프로세스의 개수로써 나타낼 수 있다.&lt;/li&gt;
  &lt;li&gt;총처리 시간(Turnaround Time): 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다.&lt;/li&gt;
  &lt;li&gt;대기 시간(Waiting Time): 대기 시간은 프로세스가 준비 큐에서 대기하면서 보낸 시간의 합이다.&lt;/li&gt;
  &lt;li&gt;응답 시간(Response Time): 하나의 Request를 제출한 후 첫 번째 Response가 나올 때까지의 시간이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CPU Utilization, Throughput을 최대화하고 Turaround Time, Waiting Time, Response Time을 최소화 하는 알고리즘의 선택이 바람직한 선택이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 대부분의 알고리즘의 경우는 Trade-Off 임으로 본인의 Context에 맞춰서 선택하는 것이 가장 좋은 방법이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;53-스케줄링-알고리즘-scheduling-algorithms&quot;&gt;5.3 스케줄링 알고리즘 (Scheduling Algorithms)&lt;/h3&gt;

&lt;p&gt;CPU 스케줄링은 준비 큐에 있는 어느 프로세스에 CPU 코어를 할당할 것인지를 결정하는 문제를 다룬다.&lt;/p&gt;

&lt;h4 id=&quot;531-선입-선처리-알고리즘-first-come-first-served-scheduling-fcfs&quot;&gt;5.3.1 선입 선처리 알고리즘 (First Come First Served Scheduling, FCFS)&lt;/h4&gt;

&lt;p&gt;선입 선처리(FCFS) 스케줄링 알고리즘은 가장 간단한 CPU 스케줄링 알고리즘이다. &lt;strong&gt;이 방법에서는 CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로세스가 준비 큐에 진입하면, 이 프로세스의 프로세스 제어 블록(PCB)을 큐의 끝에 연결한다. CPU가 가용 상태가 되면, 준비 큐의 앞부분에 있는 프로세스에 할당된다. 이 실행 상태의 프로세스는 이어 준비 큐에서 제거된다.&lt;/p&gt;

&lt;p&gt;FCFS의 부정적인 측면으로는 선입 선처리 정책하에서 평균대기 시간은 종종 대단히 길 수 있다는 점을 갖고 있다. (대화형 시스템에 적절하지 않다.)&lt;/p&gt;

&lt;p&gt;선입 선처리 스케줄링 알고리즘은 &lt;strong&gt;비선점형 알고리즘&lt;/strong&gt;이다. 일단 CPU가 한 프로세스에 할당되면, 그 프로세스가 종료하는지 또는 I/O 처리를 요구하든지 하여 CPU를 방출할 때까지 CPU를 점유한다.&lt;/p&gt;

&lt;h4 id=&quot;532-최단-작업-우선-스케줄링-shortest-job-first-schduling&quot;&gt;5.3.2 최단 작업 우선 스케줄링 (Shortest Job First Schduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;최단 작업 우선(Shortest Job First, SJF) 알고리즘은 CPU 버스트 길이가 가장 작은 프로세스부터 순서적으로 CPU 코어를 할당한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최단 작업 우선(SJF) 스케줄링 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균대기 시간을 가진다는 점에서 최적임을 증명할 수 있다. 하지만 각 프로세스의 CPU 버스트 길이는 알 수 있는 방법이 없기 때문에 CPU 스케줄링 수준에서는 구현하기가 어렵다. 따라서 우리는 프로세스별 CPU 버스트의 길이를 예측해서 스케줄링 해야만 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SJF 알고리즘은 선점형이거나 또는 비선점형일 수 있다. 비선점형일 경우 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택이 발생한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;533-라운드-로빈-스케줄링-round-robin-scheduling-rr&quot;&gt;5.3.3 라운드 로빈 스케줄링 (Round Robin Scheduling, RR)&lt;/h4&gt;

&lt;p&gt;라운드 로빈(RR) 스케줄링 알고리즘은 선입 선처리 스케줄링과 유사하지만 &lt;strong&gt;시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다.&lt;/strong&gt; &lt;strong&gt;시간 할당량(time quantum), 또는 타임슬라이스(time slice)라고 하는 작은 단위의 시간을 정의한다. CPU 스케줄러는 준비 큐를 돌면서 한 번에 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RR 알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다. 극단적인 경우, 시간 할당량이 매우 크면, RR 정책은 FCFS와 같다. 반대로 시간 할당량이 매우 적다면 RR 정책은 매우 많은 문맥 교환을 야기한다.&lt;/p&gt;

&lt;p&gt;시간 할당량의 크기는 알고리즘의 성능과 Trade Off 관계임으로 문맥에 적절한 시간 할당량의 크기를 설정하자.&lt;/p&gt;

&lt;h4 id=&quot;534-우선순위-스케줄링-priority-scheduling&quot;&gt;5.3.4 우선순위 스케줄링 (Priority Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;우선순위가 각 프로세스들에 연관되어 있으며, CPU 코어는 가장 높은 우선순위를 가진 프로세스에 할당된다.&lt;/strong&gt; 우선순위가 같은 프로세스들은 보통 FCFS 순서로 스케줄 된다.&lt;/p&gt;

&lt;p&gt;우선순위는 내부적 또는 외부적으로 정의될 수 있다. &lt;strong&gt;우선순위 스케줄링은 선점형이거나 또는 비선점형이 될 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우선순위 스케줄링 알고리즘의 주요 문제는 &lt;strong&gt;무한 봉쇄(indefinite blocking)&lt;/strong&gt; 또는 &lt;strong&gt;기아 상태(starvation)&lt;/strong&gt;이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄 된 것으로 간주할 수 있다. (Blocking)&lt;/li&gt;
  &lt;li&gt;부하가 과중한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수 도 있다. (Starvation)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;낮은 우선순위의 프로세스들이 무한히 봉쇄되는 문제에 대한 한가지 해결 방안은 &lt;strong&gt;노화(aging)&lt;/strong&gt;이다. &lt;strong&gt;노화는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우선순위 스케줄링의 문제점을 해결할 수 있는 또 다른 방법은 &lt;strong&gt;우선순위 스케줄링과 라운드 로빈 스케줄링을 결합하는 방법&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h4 id=&quot;535-다단계-큐-스케줄링-multilevel-queue-scheduling&quot;&gt;5.3.5 다단계 큐 스케줄링 (Multilevel Queue Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;다단계 큐 스케줄링 방법은 우선순위 스케줄링이 라운드 로빈과 결합한 스케줄링 알고리즘이다.&lt;/strong&gt; 이 방식의 가장 일반적인 형태에서 우선순위가 각 프로세스에 정적으로 할당되며 프로세스는 실행시간 동안 동일한 큐에 남아 있다.&lt;/p&gt;

&lt;p&gt;아래의 그림과 같이 프로세스 유형에 따라 프로세스를 여러 개의 개별 큐로 분할하기 위해 다단계 큐 스케줄링 알고리즘을 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-3.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;각 큐에는 자체 스케줄링 알고리즘을 구현할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우선순위를 가진 큐 별로 CPU를 선점할 수도 있고, 큐들 사이에 CPU의 시간을 나누어서 사용할 수도 있으니, 본인이 사용하는 문맥에 따라서 알고리즘을 적절히 활용하자.&lt;/p&gt;

&lt;h4 id=&quot;536-다단계-피드백-큐-스케줄링-multilevel-feedback-queue-scheduling&quot;&gt;5.3.6 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)&lt;/h4&gt;

&lt;p&gt;다단계 큐 스케줄링 알고리즘에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다. &lt;strong&gt;이와 반대로 다단계 피드백 큐 스케줄링 알고리즘에서는 프로세스가 큐들 사이를 이동하는 것을 허용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다단계 피드백 큐 스케줄링 알고리즘은 Aging과 Starvation을 예방한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 알고리즘은 특정 시스템에 부합하도록 구성이 가능함으로 현대 사용되는 CPU 스케줄링 알고리즘 중 가장 일반적인 CPU 스케줄링 알고리즘이다.&lt;/p&gt;

&lt;p&gt;하지만, 가장 좋은 스케줄러로 동작하기 위해서는 모든 매개변수 값들을 선정하는 특정 방법이 필요하기 떄문에 가장 복잡한 알고리즘이기도하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;54-스레드-스케줄링-thread-scheduling&quot;&gt;5.4 스레드 스케줄링 (Thread Scheduling)&lt;/h3&gt;

&lt;h4 id=&quot;541-경쟁-범위-contention-scope&quot;&gt;5.4.1 경쟁 범위 (Contention Scope)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;사용자 스레드와 커널 스레드의 연관 관계를 다대일과 다대다 모델로 구현하는 시스템에서는 스레드 라이브러리는 사용자 수준 스레드를 가용한 LWP(Light Weight Process)상에서 스케줄 한다.&lt;/strong&gt; 이러한 기법은 동일한 프로세스에 속한 스레드들 사이에서 CPU를 경쟁하기 때문에 &lt;strong&gt;프로세스 경쟁 범위(process contention scope, PCS)&lt;/strong&gt;로 알려져 있다.&lt;/p&gt;

&lt;p&gt;CPU상에서 어느 커널 스레드를 스케줄 할 것인지를 결정하기 위해서 커널은 &lt;strong&gt;시스템 경쟁 범위(system contention scope, SCS)&lt;/strong&gt;를 사용한다. SCS 스케줄링에서의 CPU에 대한 경쟁은 시스템상의 모든 스레드 사이에서 일어난다.&lt;/p&gt;

&lt;p&gt;전형적으로 PCS는 우선순위에 따라 행해진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;542-pthread-스케줄링-pthread-scheduling&quot;&gt;5.4.2 Pthread 스케줄링 (Pthread Scheduling)&lt;/h4&gt;

&lt;p&gt;스레드를 생성하면서 PCS 또는 SCS를 지정할 수 있는 POSIX Pthreads API를 소개하도록 하겠다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD SCOPE PROCESS&lt;/code&gt;는 PCS 스케줄링을 사용하여 스레드를 스케줄 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD SCOPE SYSTEM&lt;/code&gt;는 SCS 스케줄링을 사용하여 스레드를 스케줄 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다대다 모델을 구현하는 시스템에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD_SCOPE_PROCESS&lt;/code&gt; 정책이 사용자 수준 스레드를 가용한 LWP로 스케줄 한다.&lt;/p&gt;

&lt;p&gt;다대다 시스템에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD_SCOPE_SYSTEM&lt;/code&gt; 스케줄링 정책은 각 사용자 수준 스레드를 LWP를 생성하고 바인드 하게 될 것이고 결과적으로 일대일 모델을 사용하게 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;55-다중-처리기-스케줄링-multiple-processor-scheduling&quot;&gt;5.5 다중 처리기 스케줄링 (Multiple Processor Scheduling)&lt;/h3&gt;

&lt;p&gt;여러 개의 CPU가 사용 가능하다면, 여러 스레드가 병렬로 실행될 수 있으므로 &lt;strong&gt;부하 공유(load sharing)&lt;/strong&gt;가 가능해진다. 그러나 스케줄링 문제는 그에 상응하여 더욱 복잡해진다.&lt;/p&gt;

&lt;h4 id=&quot;551-다중-처리기-스케줄링에-대한-접근-방법-appraches-to-multiple-processor-scheduling&quot;&gt;5.5.1 다중 처리기 스케줄링에 대한 접근 방법 (Appraches to Multiple Processor Scheduling)&lt;/h4&gt;

&lt;p&gt;다중 처리기 시스템의 CPU 스케줄링에 관한 한 가지 해결 방법은 마스터 서버(master server)라는 &lt;strong&gt;하나의 프로세서가 모든 스케줄링 결정과 I/O처리 그리고 다른 시스템의 활동을 취급하게 하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이러한 비대칭 다중 처리(asymmetric multiprocessing)는 오직 하나의 코어만 시스템 자료구조에 접근하여 &lt;u&gt;자료 공유의 필요성을 배제하기 때문에 간단&lt;/u&gt;하다.&lt;/strong&gt; (이러한 방식의 단점은 마스터 서버가(master server) 전체 시스템 성능을 저하할 수 있는 병목이 된다는 것이다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다중 처리기를 지원하기 위한 표준 접근 방식은 대칭 다중 처리(symmetric multiprocessing, SMP)이며 각 프로세서는 스스로 스케줄링 할 수 있다.&lt;/strong&gt; 각 프로세서의 스케줄러가 준비 큐를 검사하고 실행할 스레드를 선택하여 스케줄링이 진행된다. &lt;strong&gt;(거의 모든 최신 운영체제는 SMP를 사용한다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스케줄 대상이 되는 스레드를 관리하기 위한 두 가지 전략은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 스레드가 공통 준비 큐에 있을 수 있다. (racing condition 발생 가능)&lt;/li&gt;
  &lt;li&gt;각 프로세서는 자신만의 스레드 큐를 가질 수 있다. (일반적인 방식)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래의 그림은 스케줄 대상이 되는 스레드를 관리하기 위한 두 가지 전략을 그림으로 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-4.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;552-다중-코어-프로세스-multicore-processor&quot;&gt;5.5.2 다중 코어 프로세스 (Multicore Processor)&lt;/h4&gt;

&lt;p&gt;현대 컴퓨터 하드웨어는 동일한 여러 개의 처리 코어를 장착하여 &lt;strong&gt;다중 코어 프로세서(multicore processor)&lt;/strong&gt;가 된다. &lt;strong&gt;각 코어는 구조적인 상태를 유지하고 있어서 운영체제 입장에서는 개별적인 논리적 CPU처럼 보이게 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드 처리 코어란 하나의 코어에 2개 이상의 하드웨어 스레드가 할당되어 있는 코어를 말한다.&lt;/strong&gt; 이렇게 하면 메모리를 기다리는 동안 하나의 하드웨어 스레드가 중단되면 코어가 다른 스레드로 전환할 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 이중 스레드 처리 코어를 보이고 이 코어에서 스레드 0과 1의 실행이 인터리브 되는 모습을 보인다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터리브(interleave)는 성능을 높이기 위해 데이터가 서로 인접하지 않도록 배열하는 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-5.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;운영체제 관점에서 각 하드웨어 스레드는 명령어 포인터 및 레지스터 집합과 같은 구조적 상태를 유지하므로 소프트웨어 스레드를 실행할 수 있는 논리적 CPU로 보인다. 이를 &lt;strong&gt;칩 다중 스레딩(chip multi-threading, CMT)&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 칩 다중 스레딩을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-6.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 프로세서에는 4개의 컴퓨팅 코어가 있으며 각 코어에는 2개의 하드웨어 스레드가 있다. &lt;u&gt;운영체제의 관점에서 볼 때 8개의 논리적 CPU가 있는 것 처럼 보인다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 Processor를 다중 스레드화 하는 데에는 &lt;strong&gt;거친(coarse-grained) 다중 스레딩&lt;/strong&gt;과 &lt;strong&gt;세밀한(fine-grained) 다중 스레딩&lt;/strong&gt;의 2가지 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;coarse-grained multithreading에서는 스레드가 메모리 스톨과 같은 긴 지연시간을 가진 이벤트가 발생할 때까지 한 코어에서 수행된다.&lt;/li&gt;
  &lt;li&gt;fine-grained multithreading에서는 보통 명령어 주기의 경계에서 같이 좀 더 세밀한 정밀도를 가진 시점에서 스레드 교환이 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;결과적으로 다중 스레드 다중 코어 프로세스는 아래의 그림과 같이 현실적으로 두 개의 다른 스케줄링 단계가 필요하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-7.png&quot; style=&quot;width:45%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;운영체제가 각 하드웨어 스레드(논리적 프로세서)에서 실행할 소프트웨어 스레드를 선택할 때 결정해야 하는 스케줄링 결정을 한다.&lt;/li&gt;
  &lt;li&gt;각 코어가 실행할 하드웨어 스레드를 결정하는 방법을 명시한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;553-부하-균등화-load-balancing&quot;&gt;5.5.3 부하 균등화 (Load Balancing)&lt;/h4&gt;

&lt;p&gt;SMP(symmetric multiprocessing, 대칭 다중 처리) 시스템에서 프로세서가 하나 이상이라는 것을 최대한 활용하려면, &lt;strong&gt;부하(Load)를 모든 프로세서에 균등하게 배분(Balancing)하는 것이 매우 중요하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부하 균등화(Load balancing)은 SMP 시스템의 모든 프로세서 사이에 부하가 고르게 배분되도록 시도한다.&lt;/strong&gt; &lt;u&gt;부하 균등화는 통상 각 처리기가 실행할 스레드를 위한 자기 자신만의 준비 큐를 가지고 있는 시스템에서만 필요한 기능이라는 것을 주의해야 한다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;부하 균등화를 위해서는 &lt;strong&gt;push migration와 pull migration 방식&lt;/strong&gt;의 두 가지 일반적인 접근법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;push migration:&lt;/strong&gt; 특정 태스크가 주기적으로 각 처리기의 부하를 검사하고 만일 불균형 상태로 밝혀지면 과부하인 처리기에서 쉬고 있거나 덜 바쁜 처리기로 스레드를 이동(또는 push)시킴으로써 부하를 분배 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;pull migration:&lt;/strong&gt; 쉬고 있는 프로세서가 바쁜 프로세서를 기다리고 있는 프로세스를 pull할 때 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Load balancing의 개념은 여러 가지로써 존재할 수 있으니 문맥에 잘 맞추어서 구현 및 선택 하자.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;(ex. 각 큐에 들어 있는 스레드 수로써 Load balancing, 각 큐에 스레드 우선순위를 균등하게 분배하는 Load balancing)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;554-처리기-선호도-processor-affinity&quot;&gt;5.5.4 처리기 선호도 (Processor Affinity)&lt;/h4&gt;

&lt;p&gt;SMP(symmetric multiprocessing)을 지원하는 대부분의 운영체제는 스레드를 한 프로세서에서 다른 프로세서로 이주시키지 않고 대신 같은 프로세서에서 계속 실행시키면서 이용하려 한다. 이를 &lt;strong&gt;프로세서 선호도&lt;/strong&gt;라고 한다. &lt;strong&gt;즉, 프로세스는 현재 실행 중인 프로세서에 대한 선호도를 보인다.&lt;/strong&gt; (캐쉬 등의 리소스 관련해)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Processor Affinity는 여러 형태를 띈다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;약한 선호도(soft affinity):&lt;/strong&gt; 운영체제는 프로세스를 특정 처리기에서 실행시키려고 노력은 하지만 프로세스가 처리기 사이에서 이주하는 것은 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;강한 선호도(gard affinity):&lt;/strong&gt; 운영체제는 시스템 콜을 통하여 프로세스는 자신이 실행될 처리기 집합을 명시할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;많은 시스템에서 soft affinity와 hard affinity를 모두 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Load Balancing은 종종 Processor Affinity의 장점을 상쇄한다.&lt;/strong&gt; 즉, 동일한 프로세서에서 스레드를 계속 실행하면 스레드가 해당 프로세서의 캐시 메모리에 있는 데이터를 활용할 수 있다는 이점이 있다. 하지만, 스레드를 한 프로세서에서 다른 프로세서로 이동하여 부하를 균등하게 조정하면 이러한 이점이 사라진다.&lt;/p&gt;

&lt;p&gt;결국 이러한 기술들은 Trade off 관계 임으로 자신의 문맥에 맞추어서 잘 활용하자.&lt;/p&gt;

&lt;h4 id=&quot;555-이기종-다중-처리-heterogeneous-multiprocessing&quot;&gt;5.5.5 이기종 다중 처리 (Heterogeneous Multiprocessing)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;모바일 시스템에는 현재 다중 코어 아키텍처가 채택되어 있지만 일부 시스템은 동일한 명령어 집합을 실행하지만 전력 소비를 유휴 수준으로 조정하는 기능을 포함하여 클록 속도 및 전력 관리 측면에서 차이가 나는 코어를 사용하여 설계되었다.&lt;/strong&gt; 이러한 시스템을 &lt;strong&gt;이기종 다중 처리(HMP)&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;HMP의 목적은 작업의 특정 요구에 따라 특정 코어에 작업을 할당하여 &lt;u&gt;전력 소비를 더 잘 관리&lt;/u&gt;하는 것이다.&lt;/p&gt;

&lt;p&gt;이를 지원하는 ARM프로세서의 경우 이 유형의 아키텍처를 big.LITTLE이라고 하며 고성능 big코어가 에너지 효율적인 LITTLE코어와 결합한다. big 코어는 더 많은 에너지를 소비하므로 짧은 시간 동안만 사용해야 한다. 마찬가지로, little 코어는 더 적은 에너지를 사용하므로 더 오랫동안 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;이 방식을 활용해 운영체제는 대화형 응용 프로그램은 big 코어에 할당하고, 백그라운드 배치 프로그램은 little코어에 활용할 수 있게 아키텍처를 설계할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;56-실시간-cpu-스케줄링-real-time-cpu-scheduling&quot;&gt;5.6 실시간 CPU 스케줄링 (Real-Time CPU Scheduling)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;실시간 시스템은 연성(soft) 실시간 시스템과 경성(hard) 실시간 시스템으로 구분된다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;연성 실시간 시스템(soft real-time system):&lt;/strong&gt; 중요한 실시간 프로세스가 스케줄 되는 시점에 관해 아무런 보장을 하지 않는다. (우선권만 보장)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;경성 실시간 시스템(hard real-time system):&lt;/strong&gt; 태스크를 반드시 마감시간까지 서비스를 받을 수 있게끔 보장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;561-지연시간-최소화-minimizing-latency&quot;&gt;5.6.1 지연시간 최소화 (Minimizing Latency)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;이벤트 지연시간(Event Laentcy)이란 이벤트가 발생해서 그에 맞는 서비스가 수행될 때까지의 시간을 말한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다음의 두 가지 유형의 지연시간이 실시간 시스템의 성능을 좌우한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;인터럽트 지연시간:&lt;/strong&gt; CPU에 인터럽트가 발생한 시점부터 해당 인터럽트 처리 루틴(ISR)이 시작하기까지의 시간을 말한다.
    &lt;ul&gt;
      &lt;li&gt;실시간 태스크가 즉시 수행될 수 있도록 인터럽트 지연시간을 최소화하는 것은 실시간 운영체제에 매우 중요한 일이다.&lt;/li&gt;
      &lt;li&gt;인터럽트 지연은 아래의 그림과 같다.
 &lt;img src=&quot;/assets/computer-science/CPU-Scheduling-8.png&quot; style=&quot;width:55%&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디스패치 지연시간:&lt;/strong&gt; 스케줄링 디스패처가 하나의 프로세스를 블록시키고 다른 프로세스를 시작하는 데까지 걸리는 시간을 말한다.
    &lt;ul&gt;
      &lt;li&gt;디스패치 지연시간을 최소화하는 가장 효과적인 방법은 선점형 커널(preemptive kernel)이다.&lt;/li&gt;
      &lt;li&gt;아래의 그림은 디스패치 지연을 보여준다.
 &lt;img src=&quot;/assets/computer-science/CPU-Scheduling-9.png&quot; style=&quot;width:55%&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;디스패치 지연시간의 충돌(conflicts)단계는 다음의 두 가지 요소로 구성되어 있다.
        &lt;ul&gt;
          &lt;li&gt;커널에 동작하는 프로세스에 대한 선점&lt;/li&gt;
          &lt;li&gt;높은 우선순위의 프로세스가 필요한 자원을 낮은 우선순위 프로세스 자원이 방출&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;디스패치 지연시간의 디스패치 단계는 우선순위가 높은 프로세스를 사용 가능한 CPU에 스케줄 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;562-우선순위-기반-스케줄링-priority-based-scheduling&quot;&gt;5.6.2 우선순위 기반 스케줄링 (Priority Based Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;실시간 운영체제의 스케줄러는 선점을 이용한 우선순위 기반의 알고리즘을 지원해야만 한다.&lt;/strong&gt; 우선순위 기반의 스케줄링 알고리즘은 각각의 프로세스의 중요성에 따라서 그 우선순위를 부여한다.&lt;/p&gt;

&lt;p&gt;선점 및 우선순위 기반의 스케줄러를 제공하는 것은 단지 연성 실시간 기능을 제공하는 것에 불과하다. 경성 실시간 시스템에서는 실시간 태스크가 마감시간 내에 확실히 수행되는 것을 보장해야만 하며, 그렇기 때문에 부가적인 스케줄링 기법이 필요하다.&lt;/p&gt;

&lt;p&gt;스케줄러는 프로세스의 주기, 마감시간, 수행시간 사이의 관계를 이용하여 마감시간과 주기적 프로세스의 실행 빈도에 따라 우선순위를 정한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스의 CPU 수행시간 : t&lt;/p&gt;

  &lt;p&gt;CPU로 부터 반드시 서비스를 받아야 하는 마감시간 : d&lt;/p&gt;

  &lt;p&gt;프로세스의 실행 주기 : p&lt;/p&gt;

  &lt;p&gt;주기 태스크의 실행 빈도 : 1/p&lt;/p&gt;

  &lt;p&gt;수행 시간, 마감 시간, 주기의 관계 : 0 &amp;lt;= t &amp;lt;= d &amp;lt;= p&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;563-rate-monotonic-관계-rate-monotonic-scheduling&quot;&gt;5.6.3 Rate Monotonic 관계 (Rate Monotonic Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Rate-monotonic 스케줄링 알고리즘은 선점 가능한 정적 우선순위 정책을 이용하여 주기 태스크들을 스케줄 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;각각의 주기 태스크들은 시스템에 진입하게 되면 주기에 따라서 우선순위가 정해진다. &lt;u&gt;주기가 짧은 태스크는 높은 우선순위가, 주기가 길면 낮은 우선순위가 배정된다.&lt;/u&gt; 높은 우선순위의 프로세스가 낮은 우선순위의 프로세스를 선점한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;즉, 이 정책은 CPU를 더 자주 필요로 하는 태스크에 더 높은 우선순위를 주려는 원리에 기반을 두고 있다.&lt;/p&gt;

&lt;p&gt;Rate Monotonic 스케줄링 기법이 스케줄 할 수 없는 프로세스 집합의 경우 정적 우선순위를 이용하는 다른 알고리즘들 역시 스케줄 할 수 없는 측면에서 &lt;strong&gt;최적(optimal)의 알고리즘&lt;/strong&gt;이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 Rate monotonic 스케줄링 기법을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-10.png&quot; style=&quot;width:65%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Rate-monotonic 스케줄링 기법은 최적(Optimal)이기는 하지만 많은 제약이 있다. CPU 이용률은 한계가 있기 떄문에 CPU 자원을 최대화해서 사용하는 것은 불가능하다. &lt;strong&gt;N개의 프로세스를 스케줄 하는 데 있어 최악의 경우 CPU 이용률은 N(2^(1/N) - 1)이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;564-earliset-deadline-first-스케줄링&quot;&gt;5.6.4 Earliset Deadline First 스케줄링&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Earliest Deadline First(EDF) 스케줄링 기법은 마감시간에 따라서 우선순위를 &lt;u&gt;동적&lt;/u&gt;으로 부여한다.&lt;/strong&gt; 마감시간이 빠를수록 우선순위는 높아지고, 늦을수록 우선순위는 낮아진다.&lt;/p&gt;

&lt;p&gt;EDF 정책에서는, 프로세스가 실행 가능하게 되면 자신의 마감시간을 시스템에 알려야 한다. 우선순위는 새로 실행 가능하게 된 프로세스의 마감시간에 맞춰서 다시 조정된다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 Earliest Deadline First(EDF) 스케줄링 기법을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-11.png&quot; style=&quot;width:65%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EDF는 스케줄링 기법 알고리즘 중에서 이론적으로 최적(Optimal)이다.&lt;/p&gt;

&lt;h4 id=&quot;565-일정-비율의-몫-스케줄링-proportionate-share-scheduling&quot;&gt;5.6.5 일정 비율의 몫 스케줄링 (Proportionate Share Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;일정 비율의 몫(proportional share) 스케줄러는 모든 응용들에 T개의 시간 몫을 할당하여 동작한다.&lt;/strong&gt; 한 개의 응용이 N개의 시간 몫을 할당받으면 그 응용은 모든 프로세스 시간 중 N/T 시간을 할당받게 된다.&lt;/p&gt;

&lt;p&gt;일정 비율의 몫 스케줄러는 응용이 시간 몫을 할당받는 것을 보장하는 승인 제어 정책과 함께 동작해야만 한다. 승인제어 정책은 사용 가능한 충분한 몫이 존재할 때, 그 범위 내의 몫을 요구하는 클라이언트들에게만 실행을 허락한다.&lt;/p&gt;

&lt;h4 id=&quot;566-posix-실시간-스케줄링-posix-real-time-scheduling&quot;&gt;5.6.6 POSIX 실시간 스케줄링 (POSIX Real Time Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;POSIX는 다음과 같이 실시간 스레드를 위하여 두 개의 스케줄링 클래스를 정의한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SCHED FIFO: FIFO큐를 사용하여 먼저 온 것을 먼저 서비스하는 정책에 따라 스레드를 스케줄한다.&lt;/li&gt;
  &lt;li&gt;SCHED RR: 라운드 로빈 정책을 사용하여 같은 우선순위의 스레드에 시간 할당량을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POSIX API는 스케줄링 정책에 관한 정보를 저장하고 얻어내는 다음과 같은 두 개의 함수를 제공한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy)&lt;/li&gt;
  &lt;li&gt;pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 함수의 첫 번째 인자는 스레드의 속성 집합에 대한 포인터이고, 두 번째 인자는 현재의 스케줄링 정책이거나, SCHED_FIFO, SCHED_RR, SCHED_OTHER와 같은 정책을 표현하는 정수 값이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;57-운영체제-사례들-operating-system-examples&quot;&gt;5.7 운영체제 사례들 (Operating System Examples)&lt;/h3&gt;

&lt;p&gt;Solaris와 Windows 시스템은 커널 스레드 스케줄링에 관해 설명하고, Linux 스케줄러의 경우에는 태스크 스케줄링에 관해 설명한다.&lt;/p&gt;

&lt;h4 id=&quot;571-사례-linux-스케줄링-example-linux-scheduling&quot;&gt;5.7.1 사례: Linux 스케줄링 (Example: Linux Scheduling)&lt;/h4&gt;

&lt;p&gt;Linux 2.6.23 커널부터는 완전 공평 스케줄러(Completely Fair Schduler, CFS)가 Linux 시스템의 디폴트 스케줄링 알고리즘이 되었다. 또한 Linux 스케줄러는 각 클래스별로 특정 우선순위를 부여받는 스케줄링 클래스에 기반을 두고 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉, 표준 Linux 커널은 (1) CFS 스케줄링 알고리즘을 사용하는 디폴트 스케줄링 클래스와 (2) 실시간 스케줄링 클래스의 두 스케줄링 클래스를 구현한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CFS 스케줄러는 상대 우선순위에 상응하는 시간 할당량의 길이가 정해져 있는 경직된 규칙을 사용하지 않고 &lt;strong&gt;각 태스크에 CPU 처리시간의 비율을 할당한다.&lt;/strong&gt; 이 비율은 각 태스크에 할당된 &lt;strong&gt;Nice 값&lt;/strong&gt;에 기반을 두고 계산된다. Nice 값은 -20부터 19까지의 범위를 가지며, 값이 적을수록 우선순위는 높아진다. (default nice value is 0)&lt;/p&gt;

&lt;p&gt;CFS는 이산 값을 가지는 시간 할당량을 사용하지 않고 대신에 &lt;strong&gt;목적 지연시간(targeted latency)&lt;/strong&gt;을 찾는다. &lt;u&gt;CPU 시간의 비율은 이 목적 지연시간의 값으로부터 할당된다.&lt;/u&gt; 목적 지연시간은 디폴트 값과 최솟값을 가지며, 시스템상에 활성 태스크의 개수가 일정 임계값보다 많아지면 증가할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;목적 지연시간(targeted latency): 다른 모든 수행 가능한 태스크가 적어도 한 번씩은 실행할 수 있는 시간 간격을 나타낸다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;CFS는 각 태스크별로 vruntime이라는 변수에 태스크가 실행된 시간을 기록하여 가상 실행 시간을 유지한다.&lt;/strong&gt; 이 가상 실행 시간은 태스크의 우선순위에 기반을 둔 감쇠 지수(decay factor)와 관련된다. 낮은 우선순위 태스크는 높은 우선순위 태스크보다 감쇠율이 높다.&lt;/p&gt;

&lt;p&gt;다음에 실행될 태스크를 선택하려면 스케줄러는 단순히 가장 작은 vruntime 값을 가진 태스크를 선택한다. 게다가 실행할 수 있게된 높은 우선순위 태스크는 낮은 우선순위 태스크를 선점할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux는 실시간 태스크에 할당해주는 우선순위 영역과 보통의 태스크에 할당해주는 영역 등 두 개의 별도 영역을 사용한다.&lt;/strong&gt; 실시간 태스크는 0부터 99 사이의 범위에서 정적 우선순위를 부여받고, 보통의 태스크는 100에서 139까지의 영역에서 부여받는다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 태스크 할당을 위한 Linux 시스템의 스케줄링 우선순위를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-12.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CFS 스케줄러는 처리 코어 간의 부하를 균등하게 유지하면서도 NUMA를 인식하고 스레드 이주를 최소화하는 정교한 기술을 사용하여 부하 균등화를 지원한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;불균일 기억 장치 접근(Non-Uniform Memory Access, NUMA)&lt;/strong&gt;는 멀티프로세서 시스템에서 사용되고 있는 컴퓨터 메모리 설계 방법중의 하나로, 메모리에 접근하는 시간이 메모리와 프로세서간의 상대적인 위치에 따라 달라진다. NUMA구조에서 프로세서는 자기의 로컬 메모리에 접근할 때가 원격 메모리에 접근할 때보다 더 빠르다. 원격 메모리는 다른 프로세서에 연결되어 있는 메모리를 말하고 로컬 메모리는 자기 프로세서에 연결되어 있는 메모리를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스레드를 이주하면 캐시 내용을 무효화해야 하거나 NUMA 시스템에서 메모리 액세스 시간이 더 길어져 메모리 액세스 불이익이 발생할 수 있다. 이 문제를 해결하기 위해 Linux는 스케줄링 도메인의 계층적 시스템을 결정한다. &lt;strong&gt;스케줄링 도메인은 서로 부하의 균형을 맞출 수 있는 CPU 코어의 집합이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림은 스케줄링 도메인의 아이디어를 설명한 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-13.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 스케줄링 도메인의 코어는 시스템 자원을 공유하는 방법에 따라 그룹화된다. L1, L2, L3은 캐시를 의미한다. 이 두 도메인은 L3 캐시를 공유할 수 있으므로 &lt;strong&gt;프로세서 수준 도메인(NUMA Node)&lt;/strong&gt;으로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CFS의 기본 전략은 가장 낮은 수준의 레이어부터 시작하여 도메인 안에서 부하의 균형을 맞추는 것이다.&lt;/strong&gt; (도메인내의 부하 균등화 -&amp;gt; 도메인 간에 부화 균등화 -&amp;gt; 다른 NUMA 노드간에 부하 균등화)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반적 원칙으로 전체 시스템이 바쁜 경우 CFS는 NUMA 시스템의 메모리 지연 불이익을 피하고자 각 코어의 로컬 도메인을 벗어나서 부하의 균형을 맞추지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;572-사례-windows-스케줄링-example-wiondows-scheduling&quot;&gt;5.7.2 사례: Windows 스케줄링 (Example: Wiondows Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Windows는 우선순위에 기반을 둔 선점 스케줄링 알고리즘을 사용한다.&lt;/strong&gt; Windows 스케줄러는 가장 높은 우선순위의 스레드가 항상 실행되도록 보장한다. Windwos 커널 중 스케줄링을 담당하는 부분을 &lt;strong&gt;디스패처(dispatcher)&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;디스패처에 의해 선택된 스레드는 높은 우선순위 스레드에 의해 선점되든지, 연산이 다 끝나든지, 시간 할당량이 만료되든지, 입출력을 위한 것과 같은 봉쇄를 일으키는 시스템 콜을 호출할 때까지 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;디스패처는 스레드의 실행 순서를 정하기 위해 32단계의 우선순위를 두고 있다. 우선 순위는 가변 클래스(Variable Class), 실시간 클래스(Real-Time Class)로 구분된다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가변 클래스에 있는 스레드들은 우선순위가 1부터 15까지이다.&lt;/li&gt;
  &lt;li&gt;실시간 클래스는 우선순위 16부터 31까지의 스레드를 포함한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;디스패처는 각 우선순위를 위하여 큐를 사용하고 이들 큐를 높은 우선순위부터 낮은 우선순위까지 조사하면서 준비 상태의 스레드가 있는지를 본다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows API는 프로세스의 우선순위 클래스를 제공하고 우선순위 클래스의 스레드들의 상대적인 우선순위 값을 제공하여 우선순위를 관리한다. 각 스레드의 우선순위는 그 스레드가 속한 우선순위 클래스와 그 클래스 안에서의 상대적인 우선순위(relative priority)에 기반을 둔다. 아래의 그림에는 이 상관관계가 나와 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-14.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스레드의 초기 우선순위는 보통 스레드가 속한 프로세스의 기본 우선순위가 배정된다. 하지만 Windows API를 사용해서 스레드의 기본 우선순위를 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;스레드의 시간 할당량이 만료되면, 그 스레드는 인터럽트 된다. 그 스레드가 가변 우선순위 클래스에 속한다면 우선순위가 낮아진다. 또한 가변 우선순위 스레드가 대기 연산에서 풀려나면 디스패처는 그 우선순위를 높여준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Window 7은 &lt;u&gt;사용자 모드 스케줄링(user-mode scheduling, UMS)&lt;/u&gt;을 도입하였는데, 응용 프로그램이 커널과는 독립적으로 스레드를 생성하고 관리할 수 있게 한다.&lt;/strong&gt; (모든 사용자 모드 스레드가 각자의 문맥을 저장할 수 있게 한다.)&lt;/p&gt;

&lt;h4 id=&quot;573-사례-solaris-스케줄링-example-solaris-scheduling&quot;&gt;5.7.3 사례: Solaris 스케줄링 (Example: Solaris Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Solaris는 우선순위 기반 스레드 스케줄링을 사용한다.&lt;/strong&gt; Solaris는 우선순위에 따라 다음과 같은 6개의 스케줄링 클래스를 정의한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;시분할(time-sharing, TS)&lt;/li&gt;
  &lt;li&gt;대화형(interactive, IA)&lt;/li&gt;
  &lt;li&gt;실시간(real time, RT)&lt;/li&gt;
  &lt;li&gt;시스템(system, SYS)&lt;/li&gt;
  &lt;li&gt;공평 공유(fair share, FSS)&lt;/li&gt;
  &lt;li&gt;고정 우선순위(fixed priority, FP)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;각 클래스에는 서로 다른 우선순위와 서로 다른 스케줄링 알고리즘이 존재한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스의 default scheduling class는 시분할이다.&lt;/strong&gt; 시분할 스케줄링 정책은 다단계 피드백 큐를 사용하여 동적으로 우선순위를 바꾸고, 서로 다른 길이의 타임 슬라이스를 할당한다. &lt;strong&gt;우선순위와 타임 슬라이스 사이에는 반비례 관계가 존재한다.&lt;/strong&gt; 이러한 스케줄링 정책은 대화형 프로세스에는 더 나은 응답 시간을 제공하고, CPU 위주의 프로세스에는 더 나은 처리량을 제공한다.&lt;/p&gt;

&lt;p&gt;대화형 클래스는 시분할 클래스와 같은 스케줄링 정책을 사용하지만, 더 나은 성능을 위해 KDE 또는 GNOME 윈도 관리자에 의해 생성된 윈도윙 응용에 더 높은 우선순위를 준다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 대화형과 시분할 스레드를 스케줄 하기 위한 단순화된 디스패치 테이블을 보인다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/CPU-Scheduling-15.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반적으로 실시간 클래스의 스레드에는 가장 높은 우선순위가 주어진다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Solaris는 스케줄러와 페이지 디먼과 같은 커널 스레드를 실행하기 위해 시스템 클래스를 사용한다. 일단 시스템 스레드의 우선순위는 한 번 설정되면 바뀌지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solaris 9은 고정 우선순위(fixed priority)와 공평 공유(fair share)의 새로운 스케줄링 클래스를 도입&lt;/strong&gt;하였다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;고정 우선순위 클래스&lt;/strong&gt;에 속한 스레드는 시분할 클래스의 스레드와 같은 우선순위를 갖는다. 그러나 이 우선순위는 동적으로 조정되지 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공평 공유 클래스&lt;/strong&gt;는 스케줄링 결정을 위하여 우선순위 대신에 CPU 공유량을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;58-알고리즘의-평가-algorithm-evaluation&quot;&gt;5.8 알고리즘의 평가 (Algorithm Evaluation)&lt;/h3&gt;

&lt;h3 id=&quot;581-결정론적-모델링-deterministic-modeling&quot;&gt;5.8.1 결정론적 모델링 (Deterministic Modeling)&lt;/h3&gt;

&lt;p&gt;평가 방법의 한 중요한 부류로 분석적 평가(analystic evaluation)가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;분석적 평가(analystic evaluation)란 주어진 작업 부하에 대한 알고리즘의 성능을 평가하는 공식이나 값을 생성하기 위해 주어진 알고리즘과 시스템 작업 부하를 이용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분석적 평가의 한 가지 유형은 &lt;strong&gt;결정론적 모델링(deterministic modeling)&lt;/strong&gt;이다. 이 방식은 사전에 정의된 특정한 작업 부하를 받아들여 그 작업 부하에 대한 각 알고리즘의 성능을 정의한다.&lt;/p&gt;

&lt;p&gt;결정론적 모델링은 &lt;strong&gt;단순하고 빠르다.&lt;/strong&gt; 이것은 알고리즘들을 비교할 수 있도록 정확한 값을 제공한다. 그러나 이것은 입력으로 정확한 숫자를 요구하며, 그 응답도 단지 이들의 경우에만 적용된다.&lt;/p&gt;

&lt;h4 id=&quot;582-큐잉-모델-queueing-models&quot;&gt;5.8.2 큐잉 모델 (Queueing Models)&lt;/h4&gt;

&lt;p&gt;많은 시스템에서 실행되는 프로세스들은 날마다 변화하기 떄문에, 결정론적 모델링을 사용할 수 있는 프로세스들(그리고 시간)의 정적인 집합이 없다. 그러나 &lt;strong&gt;결정할 수 있는 것은 CPU와 I/O 버스트의 분포이다.&lt;/strong&gt; 이들의 분포는 측정할 수 있으며 그런 후에 &lt;strong&gt;근삿값을 계산하거나 단순하게 추정할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터 시스템은 서버들의 네트워크로 기술된다. 각 서버는 대기 프로세스들의 큐를 가지고 있다. CPU는 준비 큐를 가진 서버이고, 장치 큐를 가진 I/O 시스템도 마찬가지이다. 도착률과 서비스율을 알기 떄문에, 우리는 이용률, 평균 큐 길이, 평균대기 시간 등을 계산할 수 있다. 이러한 영역에 관한 연구를 &lt;strong&gt;큐잉 네트워크 분석(queueing netwrok analysis)&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;큐잉 모델을 활용해서 알고리즘을 분석하기에는 많은 가정이 필요하고 이에 대한 결과도 실제 시스템의 근사치이기 때문에 연산된 결과의 정확성에는 의심의 여지가 있다.&lt;/p&gt;

&lt;h4 id=&quot;583-모의실험-simulation&quot;&gt;5.8.3 모의실험 (Simulation)&lt;/h4&gt;

&lt;p&gt;스케줄링 알고리즘을 더욱 정확하게 평가하기 위해서는 &lt;strong&gt;모의실험(simulation)&lt;/strong&gt;을 사용할 수 있다. &lt;strong&gt;모의실험을 하는 것은 컴퓨터 시스템의 모델을 프로그래밍하는 것을 포함한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;난수 발생기, 추적파일, 확률 분포를 활용해서 모의 실험을 하게 된다면 유의미한 결과를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;모의실험은 컴퓨터를 오랜 시간 동안 사용하기 때문에 매우 큰 비용이 소요될 수 있다. 또한 simulator의 개발에도 많은 비용이 들 수 있기 때문에 문맥에 적절히 맞추어서 활용하자.&lt;/p&gt;

&lt;h4 id=&quot;584-구현-implementation&quot;&gt;5.8.4 구현 (Implementation)&lt;/h4&gt;

&lt;p&gt;모의실험도 정확성에 한계가 있다. &lt;strong&gt;스케줄링 알고리즘을 완벽히 정확하게 평가하는 유일한 방법은 실제 코드로 작성해 운영체제에 넣고 실행해 보는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 이 방식은 비용이 많이 든다.&lt;/p&gt;

&lt;p&gt;실제 코드의 스케줄링 알고리즘을 변경하고 회귀 테스트를 통해 변경 사항이 더 나빠지지 않았으며, 새로운 버그가 발생하지 않았거나 오래된 버그가 다시 발생하지 않았음을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모든 알고리즘의 평가 방식은 Trade Off 관계임으로, 본인의 문맥에 맞게 적절히 잘 조합해서 사용하자.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;5장은 지금까지 배웠던 운영체제 주제 중에서 이해하기 가장 어려웠다. 이해하는데 많은 시간을 들였기 때문에 이 장을 공부하는데 내가 생각한 시간보다 2배정도 걸린 것 같다!!&lt;/p&gt;

&lt;p&gt;하지만 역시 어려운 만큼 이해하면 재미있고, 무언가 퍼즐이 맞춰진 느낌이 들어 뿌듯하다!! 이렇게 까지 운영체제를 공부해야 할까 싶지만, Top Down으로 공부 해본 입장에서 Bottom Up 방식의 공부 방법은 무조건 필요하다 라고 생각한다!! (재밌기도 하고~!)&lt;/p&gt;

&lt;p&gt;조만간에 다시 복습하기로 약속하고, 6장인 프로세스 동기화로 넘어가겠다!! Bye~&lt;/p&gt;

</description>
        <pubDate>Sun, 18 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/computer-science(cs)/2020/10/18/CPU-Scheduling.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer-science(cs)/2020/10/18/CPU-Scheduling.html</guid>
        
        <category>Operating-System</category>
        
        <category>CS</category>
        
        <category>CPU</category>
        
        <category>Scheduling</category>
        
        
        <category>Computer-Science(CS)</category>
        
      </item>
    
      <item>
        <title>[Operating System - Chapter 4] 스레드와 병행성</title>
        <description>&lt;p&gt;이 포스팅은 공룡책으로 알려진 Operating System Concepts의 4장인 &lt;strong&gt;Threads &amp;amp; Concurrency&lt;/strong&gt;를 공부하면서 정리한 포스팅이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-스레드와-병행성-threads--concurrency&quot;&gt;4. 스레드와 병행성 (Threads &amp;amp; Concurrency)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;대부분의 현대 운영체제는 한 프로세스가 다중 스레드를 포함하는 특성을 제공한다. 또한 다중 CPU를 제공하는 최신 다중 코어 시스템에서 스레드 사용을 통한 병렬 처리의 기회를 식별하는 것이 점차 중요해진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;41-개요-overview&quot;&gt;4.1 개요 (Overview)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;u&gt;스레드(Thread)는 CPU 이용의 기본 단위&lt;/u&gt;이다.&lt;/strong&gt; 스레드는 ID, PC(Program Counter), 레지스터 집합, 스택으로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;또한 스레드는 같은 프로세스에 속한 다른 스레드와 &lt;u&gt;코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유&lt;/u&gt;한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;전통적인 프로세스는 하나의 제어 스레드를 가지고 있지만, 현대 프로세스는 다수의 제어 스레드를 가지고 있기 때문에 해당 &lt;strong&gt;프로세스는 동시에 하나 이상의 작업을 수행&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 The difference between Single-threaded process and Multithreaded process에 대해서 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-1.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스레드는 ID, PC, stack, 레지스터 집합으로 구성되어 있다.&lt;/li&gt;
  &lt;li&gt;멀티스레드 프로세스에서 스레드간에 코드, 데이터, 파일, 신호등의 리소스를 공유한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프로세스(process) (from wiki)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;411-동기-motivation&quot;&gt;4.1.1 동기 (Motivation)&lt;/h4&gt;

&lt;p&gt;현대의 컴퓨터와 모바일 기기에서 작동하는 &lt;u&gt;거의 모든 소프트웨어 응용들은 다중 스레드를 이용&lt;/u&gt;한다. 하나의 어플리케이션은 여러 실행 흐름(스레드)을 가진 독립적인 프로세스로 구현된다.&lt;/p&gt;

&lt;p&gt;멀티 스레드 프로세스가 나오게 된 배경을 설명하기 위해 단일 스레드 프로세스의 defect(결핍)의 예를 들어보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;웹 서버를 예로 들어 보겠다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;하나의 분주한 웹 서버는 수천, 수만 개의 클라이언트들이 병행하게 접근할 수 있다.&lt;/p&gt;

  &lt;p&gt;만약 웹 서버가 전통적인 단일 스레드 프로세스로 작동한다면, 자신의 단일 프로세스로 한 번에 하나의 클라이언트만 서비스할 수 있게 되어 클라이언트는 자신의 요구가 서비스되기까지 매우 긴 시간을 기다려야 한다.&lt;/p&gt;

  &lt;p&gt;이러한 단점을 개선하기 위해서 여러 요청을 수행할 별도의 프로세스들을 만들 수도 있지만 이는 많은 리소스가 필요함으로 많은 오버헤드가 발생한다.&lt;/p&gt;

  &lt;p&gt;프로세스를 새로 만드는 것 보다 &lt;strong&gt;프로세스의 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 그들은 &lt;u&gt;프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용&lt;/u&gt;함으로써 문제를 해결한다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;이를 웹 서버에 적용 시켜보면, 웹 서버가 다중 스레드화 되게끔 만들어서 서버는 클라이언트의 요청을 listen 하는 별도의 스레드를 생성한다. 요청이 들어오면 다른 프로세스를 생성하는 것이 아니라, 요청을 서비스할 새로운 스레드를 생성하고 추가적인 요청을 listen 하기 위한 작업을 재개한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 예시와 비슷하게 &lt;strong&gt;대부분 운영체제 커널도 일반적으로 다중 스레드&lt;/strong&gt;이다. 예를 들어 Linux 시스템에서 시스템을 부트하는 동안 여러 커널 스레드가 생성된다. 각 스레드는 장치 관리, 메모리 관리 또는 인터럽트 처리와 같은 특정 작업을 수행한다.&lt;/p&gt;

&lt;h4 id=&quot;412-장점-benefits&quot;&gt;4.1.2 장점 (Benefits)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;다중 스레드 프로그래밍의 이점은 다음의 4가지 큰 부류로 나눌 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;응답성(responsiveness):&lt;/strong&gt; 대화형 어플리케이션을 다중 스레드화하면 어플리케이션의 일부분이 봉쇄되거나, 긴 작업을 수행하더라도 프로그램의 수행이 계속되는 것을 허용함으로써, 사용자에 대한 응답성을 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자원 공유(resource sharing):&lt;/strong&gt; 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유하기 때문에 스레드간의 통신 기법 없이 협업이 가능하다. (프로세스는 공유메모리 or IPC 기법등이 필요)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;경제성(economy):&lt;/strong&gt; 프로세스 생성보다 스레드를 활용 하는 것이 훨씬 경제적이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;규모 적응성(scalability):&lt;/strong&gt; 멀티 프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있기 때문에 규모 적응성이 뛰어나다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;42-다중-코어-프로그래밍-multicore-programming&quot;&gt;4.2 다중 코어 프로그래밍 (Multicore Programming)&lt;/h3&gt;

&lt;p&gt;다중 스레드 프로그래밍은 여러 컴퓨팅 코어를 보다 효율적으로 사용하고 병행성을 향상시키는 기법을 제공한다.&lt;/p&gt;

&lt;p&gt;아래의 그림과 같이 여러 코어가 있는 시스템에서 병행성은 시스템이 각 코어에 별도의 스레드를 할당할 수 있기 때문에 일부 스레드가 병렬로 실행될 수 있음을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-2.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;병행성(Concurrency)과 병렬성(Parallelism)의 차이&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;병행 시스템은 모든 작업이 진행되게 하여 둘 이상의 작업을 지원한다.&lt;/p&gt;

  &lt;p&gt;병렬 시스템은 둘 이상의 작업을 동시에 수행할 수 있따.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;따라서 병렬성 없이 병행성을 가질 수 있다. (단일 프로세서의 멀티 태스킹)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;421-프로그래밍-도전과제-programming-challenges&quot;&gt;4.2.1 프로그래밍 도전과제 (Programming Challenges)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;일반적으로 다중 코어 시스템을 위해 프로그래밍하기 위해서는 5개의 극복해야 할 도전 과제가 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;태스크 인식(identifying tasks):&lt;/strong&gt; 어플리케이션을 분석하여 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;균형(balance):&lt;/strong&gt; 분석을 통해 찾은 태스크들이 전체 작업에 균등한 기여도를 가지도록 나누는 것이 중요하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;데이터 분리(data spliting):&lt;/strong&gt; 태스크가 접근하고 조작하는 데이터는 개별 코어에서 사용할 수 있도록 나누어져야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;데이터 종속성(data dependency):&lt;/strong&gt; 테스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다. (동기화 문제)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시험 및 디버깅(testing and debugging):&lt;/strong&gt; 병행 프로그램을 시험하고 디버깅&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;422-병렬-실행의-유형-types-of-parallelism&quot;&gt;4.2.2 병렬 실행의 유형 (Types of Parallelism)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;데이터 병렬 실행&lt;/strong&gt;은 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는데 초점을 맞춘다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;태스크 병렬 실행&lt;/strong&gt;은 데이터가 아니라 태스크(스레드)를 다수의 코어에 분배한다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 데이터 병렬 실행과 테스크 병렬 실행을 모델링한 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-3.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;43-다중-스레드-모델-multithreading-models&quot;&gt;4.3 다중 스레드 모델 (Multithreading Models)&lt;/h3&gt;

&lt;p&gt;스레드를 위한 지원은 &lt;strong&gt;사용자 스레드(user threads)를 위해서는 사용자 수준&lt;/strong&gt;에서, 또는 &lt;strong&gt;커널 스레드(kernel threads)를 위해서는 커널 수준&lt;/strong&gt;에서 제공된다.&lt;/p&gt;

&lt;p&gt;사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리되지만 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사용자 응용 프로그램은 사용자 수준 스레드를 생성하며, 이 스레드는 궁극적으로 CPU에서 실행되도록 커널 스레드에 매핑되어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;사용자 스레드와 커널 스레드의 연관 관계의 세 가지 일반적인 방법에 대해서 알아보자.&lt;/p&gt;

&lt;h4 id=&quot;431-다대일-모델-many-to-one-model&quot;&gt;4.3.1 다대일 모델 (Many to One Model)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;다대일(many to one) 모델은 아래 그림과 같이 많은 사용자 수준 스레드를 하나의 커널 스레드로 맵핑한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-4.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 스레드가 blocking 시스템 콜을 할 경우, 전체 프로세스가 봉쇄된다. 또한 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에, 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;432-일대일-모델-one-to-one-model&quot;&gt;4.3.2 일대일 모델 (One to One Model)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;일대일(one to one) 모델은 아래의 그림과 같이 각 사용자 스레드를 각각 하나의 커널 스레드로 맵핑한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-13.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 모델에서는 하나의 스레드가 blocking 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 떄문에 다대일 모델보다 &lt;strong&gt;더 많은 병렬성&lt;/strong&gt;을 제공한다. 또한 이 모델은 다중 프로세서에서 다중 스레드가 병렬로 수행되는 것을 허용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ex) Linux, Windows, … 등이 일대일 모델을 구현한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;433-다대다-모델-many-to-many-model&quot;&gt;4.3.3 다대다 모델 (Many to Many Model)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;다대다 모델은 아래의 그림과 같이 여러 개의 사용자 수준 스레드를 그 보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플렉스 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 플랙스라는 의미는 도메인마다 너무 다양하게 사용되어서 어떤 의미로써 해석되어야 하는지는 잘 모르겠지만 현재의 상황에서는 &lt;strong&gt;“할당하다, 맵핑하다”&lt;/strong&gt;가 가장 적절한 의미인 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-5.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발자는 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있다. 그리고 상응하는 커널 스레드가 다중 처리기에서 병렬로 수행될 수 있다. 또한 스레드가 blocking 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다.&lt;/p&gt;

&lt;p&gt;다대다 모델을 변형시켜 많은 사용자 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스 시키지만 또한 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용하는 &lt;strong&gt;두 수준 모델(two level model)&lt;/strong&gt;을 사용할 수도 잇다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 two level model을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-6.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;44-스레드-라이브러리-threads-library&quot;&gt;4.4 스레드 라이브러리 (Threads Library)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스레드 라이브러리(threads library)는 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스레드 라이브러리를 구현하는데에는 주된 두 가지 방법이 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;커널의 지원 없이 완전히 사용자 공간에서만 라이브러리를 제공하는 것&lt;/li&gt;
  &lt;li&gt;운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;현재는 POSIX Pthreads, Windows, Java의 세 종류 라이브러리가 주로 사용된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;다수의 스레드를 생성하는 전략 2가지는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;비동기 스레딩(asynchronous threading):&lt;/strong&gt; 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행되는 스레딩 방식 (다중 스레드 서버에서 주로 사용)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;동기 스레딩(synchronous threading):&lt;/strong&gt; 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 스레딩 방식 (상당한 양의 데이터 공유를 수반)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;441-pthreads&quot;&gt;4.4.1 Pthreads&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Pthreads는 POSIX(IEEE 1003.1c)가 스레드 생성과 동기화를 위해 재정한 표준 API이다.&lt;/strong&gt; 이것은 스레드의 동작에 관한 명세일 뿐이지 그것 자체를 구현한 것은 아니다.&lt;/p&gt;

&lt;p&gt;Linux와 macOS를 포함한 많은 시스템이 Pthreads 명세를 구현하고 있다.&lt;/p&gt;

&lt;h4 id=&quot;442-windows-스레드-windows-threads&quot;&gt;4.4.2 Windows 스레드 (Windows Threads)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Windows 스레드 라이브러리를 이용하여 스레드를 생성하는 기술은 많은 점에서 Pthreads 기법과 유사하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows API에서 스레드는 CreateThread() 함수에 의해 생성되고 Pthreads와 마찬가지로 이 함수에 스레드를 위한 속성의 집합이 전달된다.&lt;/p&gt;

&lt;p&gt;동기 스레딩 기법을 구현하기 위해서는 WaitForSingleObject(), WaitForMultipleObjects() API를 사용할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;443-java-스레드-java-thread&quot;&gt;4.4.3 Java 스레드 (Java Thread)&lt;/h4&gt;

&lt;p&gt;스레드는 Java 프로그램의 프로그램 실행의 근본적인 모델이고, Java 언어와 API는 스레드 생성과 관리를 지원하는 풍부한 특성을 제공한다. &lt;strong&gt;모든 Java 프로그램은 적어도 하나의 단일 제어 스레드를 포함하고 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java에서 스레드를 생성하려면 Thread 객체를 생성하고 Runnable을 구현하는 클래스의 인스턴스를 전달한 다음 Thread 객체의 start() 메소드를 호출해야 한다.&lt;/p&gt;

&lt;p&gt;아래는 Runnable 인터페이스를 구현하는 클래스가 스레드를 생성하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am a thread.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새 thread 객체에 start() 메소드를 호출하면 두 가지 작업이 수행된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메모리가 할당되고, JVM 내에 새로운 스레드가 초기화된다.&lt;/li&gt;
  &lt;li&gt;run() 메소드를 호출하면 스레드가 JVM에 의해 수행될 자격을 갖게 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;자바의 부모 스레드는 worker.join() 메소드를 통해서 자식 스레드를 기다릴 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4.3.1 Java Executor 프레임워크 (Java Executor Framework)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바 1.5부터 개발자에게 스레드 생성 및 통신에 대한 제어 기능을 크게 향상시키는 몇 가지 새로운 병행 처리 기능을 도입하였다. 이것이 바로 Executor Framework이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thread 객체를 명시적으로 생성하는 대신 Executor 인터페이스를 중심으로 스레드 생성을 구성한다.&lt;/p&gt;

&lt;p&gt;아래의 코드는 Executor 인터페이스를 나타낸다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이전에는 별도의 Thread 객체를 만들고 start() 메소드를 호출하였지만 그 대신 Executor를 사용하라는 것이다.&lt;/p&gt;

&lt;p&gt;아래의 코드는 Executor가 어떻게 사용되는지에 대해서 알려준다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Executor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 방법은 &lt;strong&gt;스레드 생성을 실행에서 분리할 뿐만 아니라 병행하게 실행되는 작업 간의 통신 기법을 제공한다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;결과를 반환할 수 없는 Runnable 과 달리 java.util.concurrent 패키지는 Callable 인터페이스를 추가로 정의하여 Future 객체를 반환할 수 있게 해준다.&lt;/u&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;JVM과 호스트 운영체제 (The JVM and the Host Operating System)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;JVM은 일반적으로 호스트 운영체제 위에서 구현된다. &lt;strong&gt;이 설정을 통해 JVM은 하부 운영체제의 구현 세부 사항을 숨기고 Java 프로그램이 JVM을 지원하는 모든 플랫폼에서 작동할 수 있도록 일관되고 추상적인 환경을 제공할 수 있다.&lt;/strong&gt; JVM 명세는 Java 스레드가 하부 운영체제에 매핑되는 방법을 명시하지 않고 대신 각 JVM의 구현에 맡긴다. 또한 Java 스레드 라이브러리와 호스트 운영체제의 스레드 라이브러리간(Pthreads API, Windows API, …)에 관계가 있을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;45-암묵적-스레딩-implicit-threading&quot;&gt;4.5 암묵적 스레딩 (Implicit Threading)&lt;/h3&gt;

&lt;p&gt;다중 코어 처리의 지속적 성장에 따라 수백 또는 수천 개의 스레드를 가진 응용이 등장하게 되었다.&lt;/p&gt;

&lt;p&gt;많은 수의 스레드를 사용하는 어플리케이션의 병행 및 병렬 설계를 도와주는 한 가지 방법은 &lt;strong&gt;스레딩의 생성과 관리 책임을 어플리케이션 개발자로부터 &lt;u&gt;컴파일러와 실행시간 라이브러리에게 넘겨주는 암묵적 스레딩 기법&lt;/u&gt;을 사용하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;암묵적 스레딩 전략은 일반적으로 응용 프로그램 개발자가 병렬로 실행할 수 있는 스레드가 아닌 작업을 식별해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉, 암묵적 스레딩 전략에서는 개발자는 병렬 작업만 식별하면 되고 라이브러리는 스레드 생성 및 관리에 대한 특정 세부 사항을 결정하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;451-스레드-풀&quot;&gt;4.5.1 스레드 풀&lt;/h4&gt;

&lt;p&gt;다중 스레드 프로세스의 여러 문제점을 해결해 줄 수 있는 방법이 &lt;strong&gt;스레드 풀(Thread pool) 방법&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스레드 풀의 기본 아이디어는 프로세스를 시작할 때 아예 일정한 수의 스레드들을 미리 풀로 만들어두는 것이다.&lt;/strong&gt; 이 스레드들은 평소에 하는 일 없이 일감을 기다리게 된다. 서버는 스레드를 생성하지 않고 요청을 받으면 대신 스레드 풀에 제출하고 추가 요청 대기를 재개한다. 풀에 사용 가능한 스레드가 있으면 깨어나고 요청이 즉시 서비스 된다. 스레드가 서비스를 완료하면 풀로 돌아가서 더 많은 작업을 기다린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스레드 풀의 장점&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 더 빠르다.&lt;/li&gt;
  &lt;li&gt;스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다.&lt;/li&gt;
  &lt;li&gt;태스크를 생성하는 방법을 태스크로부터 분리하면 태스크의 실행을 다르게 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;4.5.1.1 Java 스레드 풀&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java.util.concurrent 패키지의 여러 종류의 스레드 풀 구조에 대한 API에 대해 알아보도록 하겠다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;단일 스레드 Executor, newSingleThreadExecutor()는 크기가 1인 스레드 풀을 생성한다.&lt;/li&gt;
  &lt;li&gt;고정 스레드 Executor, newFixedThreadPool(int size)는 지정된 수의 스레드가 있는 스레드 풀을 생성한다.&lt;/li&gt;
  &lt;li&gt;캐시 스레드 Executor, newCachedThreadPool()는 많은 경우 스레드를 재사용하는 무제한 스레드 풀을 생성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;스레드 풀을 생성하고 execute() 메소드를 사용하여 풀의 스레드에서 실행할 작업을 제출한다. shutdown()메소드가 호출되면 스레드 풀은 추가 작업을 거부하고 기존의 모든 작업의 실행이 완료되면 종료한다.&lt;/p&gt;

&lt;h4 id=&quot;452-fork-join&quot;&gt;4.5.2 Fork Join&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;fork-join 모델이란 동기식 모델으로 암시적 스레딩에 사용된다면 라이브러리가 생성할 실제 스레드 수를 결정하는 동기 버전의 스레드 풀이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림은 fork-join 모델의 그림을 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-7.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.5.2.1 Java에서의 Fork Join&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java는 Quicksort 및 Mergesort와 같은 재귀 분할-정복 알고리즘과 함께 사용되도록 설계된 버전 1.7 API에 Fork join 라이브러리를 도입하였다.&lt;/p&gt;

&lt;p&gt;이 라이브러리를 사용하여 분할-정복 알고리즘을 구현할 때 분할 단계 동안 별도의 작업이 fork 되고 원래 문제의 작은 부분집합이 할당된다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 이 모델의 그림을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-8.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java의 fork-join 모델에서 흥미로운 점은 라이브러리가 작업자 스레드 풀을 생성하고 사용 가능한 작업자 간 부하의 균형을 조정하는 작업 관리에 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;453-openmp&quot;&gt;4.5.3 OpenMP&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;OpenMP는 C, C++, FORTRAN으로 작성된 API와 컴파일러 디렉티브의 집합이다.&lt;/strong&gt; OpenMP는 공유 메모리 환경에서 병렬 프로그래밍을 할 수 있도록 도움을 준다.&lt;/p&gt;

&lt;p&gt;OpenMP는 병렬로 실행될 수 있는 블록을 찾아 &lt;strong&gt;병렬 영역(parallel regions)&lt;/strong&gt;이라고 부른다. 어플리케이션 개발자는 자신들의 코드 중 병렬 영역에 컴파일러 디렉티브를 삽입한다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 OpenMP를 사용하는 C 프로그램의 예제이다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;omp.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// sequential code&lt;/span&gt;

    &lt;span class=&quot;cp&quot;&gt;#pragma omp parallel {
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am a parallel region.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// sequential code&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OpenMP가 &lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma omp parallel&lt;/code&gt;과 같은 컴파일러 디렉티브를 만나게 되면 &lt;strong&gt;시스템의 코어 개수만큼 스레드를 생성&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenMP는 병렬화를 위한 디렉티브를 제공할 뿐만 아니라 개발자가 병렬화 수준을 선택할 수 있게 한다.&lt;/strong&gt; (필요한 스레드 개수 지정 및 데이터 공유 여부, …)&lt;/p&gt;

&lt;h4 id=&quot;454-grand-central-dispatch&quot;&gt;4.5.4 Grand Central Dispatch&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Grand Central Dispatch(이하 GCD)는 macOS 및 iOS 운영체제를 위해 개발자가 병렬로 실행될 코드 섹션(태스크)을 식별할 수 있도록 하는 런타임 라이브러리, API 및 언어 확장의 조합이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GCD는 실행시간 수행을 위해 태스크를 디스패치 큐에 넣어서 스케줄 한다. 큐에서 태스크를 제거할 때 관리하는 스레드 풀에서 가용 스레드를 선택하여 태스크를 할당한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;디스패치 큐(Dispatch Queue)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;디스패치 큐(Dispatch Queue)라는건 일종의 스레드 개념과 비슷하다. 클로져로 구성된 태스크(Task)를 이 큐(Queue)에다 등록하면 별도의 스레드에서 이 큐의 내용물을 뽑아서 해당 스레드에서 태스크를 구동시키게 해 주는 문 역활을 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;GCD는 직렬(serial)과 병행(concurrent)의 두 가지 유형의 디스패치 큐를 유지한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;직렬 큐에 넣어진 태스크는 &lt;strong&gt;FIFO&lt;/strong&gt; 순서대로 제거된다.&lt;/li&gt;
  &lt;li&gt;병행 큐에 넣어진 태스크는 FIFO 순서로 제거되지만 한 번에 여러 태스크가 제거되어 &lt;strong&gt;병렬로 실행&lt;/strong&gt;될 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러 시스템 전체의 병행 큐가 존재하며 4가지 주요 서비스 품질 클래스로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;QOS_CLASS_USER_INTERACTIVE (사용자 대화형 클래스)&lt;/li&gt;
  &lt;li&gt;QOS_CLASS_USER_INITIATED (사용자 시작 클래스)&lt;/li&gt;
  &lt;li&gt;QOS_CLASS_UTILITY (유틸리티 클래스)&lt;/li&gt;
  &lt;li&gt;QOS_CLASS_BACKGROUND (백그라운드 클래스)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내부적으로 GCD의 스레드 풀은 POSIX 스레드로 구성된다. GCD는 풀을 적극적으로 관리하여 응용 프로그램 요구 및 시스템 용량에 따라 스레드 수가 늘어나거나 줄어들게 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;46-스레드와-관련된-문제들-threading-issues&quot;&gt;4.6 스레드와 관련된 문제들 (Threading Issues)&lt;/h3&gt;

&lt;h4 id=&quot;461-fork-및-exec-시스템-콜-the-fork-and-exec-system-calls&quot;&gt;4.6.1 Fork() 및 Exec() 시스템 콜 (The fork() and exec() System Calls)&lt;/h4&gt;

&lt;p&gt;우리는 &lt;strong&gt;다중 스레드 프로그램에서 fork()와 exec()의 의미&lt;/strong&gt;에 대해서 생각해 보아야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;만일 한 프로그램의 스레드가 fork()를 호출하면 새로운 프로세스는 모든 스레드를 복제해야 하는가 아니면 한 개의 스레드만 가지는 프로세스여야 하는가?
    &lt;ul&gt;
      &lt;li&gt;UNIX 시스템은 fork() API로써 이 둘의 기능을 다 지원한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보통 어떤 스레드가 exec() 시스템 콜을 부르면 exec()의 매개변수로 지정된 프로그램이 모든 스레드를 포함한 전체 프로세스를 대체시킨다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;우리는 운영체제에서 지원해주는 기능에 따라 적절히 fork()와 exec()를 사용해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;462-신호-처리-signal-handling&quot;&gt;4.6.2 신호 처리 (Signal Handling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;신호는 UNIX에서 프로세스에 어떤 이벤트가 일어났음을 알려주기 위해 사용된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;신호는 비동기적, 동기적으로 발생할 수 있는데 이와 상관없이 모든 신호는 다음과 같은 형태로 전달되어야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;신호는 특정 이벤트가 일어나야 생성된다.&lt;/li&gt;
  &lt;li&gt;생성된 신호가 프로세스에 전달된다.&lt;/li&gt;
  &lt;li&gt;신호가 전달되면 반드시 처리되어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 신호는 둘 중 하나의 처리기에 의해 처리된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;디폴트 신호 처리기&lt;/li&gt;
  &lt;li&gt;사용자 정의 신호 처리기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;프로세스가 여러 스레드를 가지고 있는 경우 동기식 신호는 그 신호를 야기한 스레드에 전달되어야 하고 다른 스레드에 전달되면 안 된다. 반면에 비동기 신호의 경우에는 그 프로세스 내 모든 스레드에 전달되어야 한다.&lt;/p&gt;

&lt;h4 id=&quot;463-스레드-취소-thread-cancellation&quot;&gt;4.6.3 스레드 취소 (Thread Cancellation)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;스레드 취소(thread cancellation)는 스레드가 끝나기 전에 그것을 강제 종료시키는 작업을 일컫는다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(ex. 여러 스레드가 데이터베이스를 병렬로 검색하고 있다가 그 중 한 스레드가 결과를 찾았다면 나머지 스레드는 취소 되어야 하는 경우, …)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 처럼 취소되어야 할 스레드를 &lt;strong&gt;목적 스레드(target thread)&lt;/strong&gt;라고 부른다. 목적 스레드는 다음과 같은 두 가지 방식으로 취소할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;비동기식 취소(asynchronous cancellation):&lt;/strong&gt; 한 스레드가 즉시 목적 스레드를 강제 종료시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;지연 취소(deferred cancellation):&lt;/strong&gt; 목적 스레드가 주기적으로 자신이 강제 종료 되어야 할지를 점검한다. (질서 정연하게 강제 종료 가능)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;스레드 취소를 어렵게 만드는 것은 취소 스레드들에 할당된 자원의 문제가 가장 크기 때문에 이를 잘 고려해서 스레드 취소를 해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pthreads에서는 pthread_cancel() 함수를 사용하여 스레드를 취소할 수 있다. pthread_cancel()을 호출하면 &lt;u&gt;대상 스레드를 취소하라는 요청만 표시&lt;/u&gt;된다. 그러나 실제 취소는 요청을 처리하기 위해 대상 스레드가 설정되는 방식에 달려 있다. 대상 스레드가 최종적으로 취소되면 취소 스레드의 pthread_join() 호출이 반환된다.&lt;/p&gt;

&lt;p&gt;Pthreads는 아래와 같이 3가지 취소 모드를 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-9.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본 스레드 취소 유형은 deferred 이다. 즉, 스레드가 취소 점에 도달한 경우에만 취소가 발생한다.&lt;/p&gt;

&lt;p&gt;또한 Pthreads는 스레드가 취소될 때 &lt;strong&gt;정리 핸들러(clean handler)&lt;/strong&gt;라고 하는 스레드가 획득한 모든 자원을 해제할 수 있는 함수를 제공한다.&lt;/p&gt;

&lt;p&gt;Java의 스레드 취소는 Pthread의 지연 취소와 유사한 정책을 사용한다. 스레드를 취소하려면 thread객체.interrupt() 메소드를 호출하여 대상 스레드의 인터럽트 상태를 true로 설정하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;464-스레드-로컬-저장장치-thread-local-storage&quot;&gt;4.6.4 스레드-로컬 저장장치 (Thread-Local Storage)&lt;/h4&gt;

&lt;p&gt;한 프로세스에 속한 스레드들은 그 프로세스의 데이터를 스레드간에 모두 공유한다. 하지만 상황에 따라서는 각 스레드가 &lt;strong&gt;자기만 액세스할 수 있는 데이터를 가져야 할 필요도 있다. 그러한 데이터를 스레드-로컬 저장장치(thread-local storage, TLS)&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ex) 트랜잭션 처리 시스템에서 각 트랜잭션을 독립된 스레드가 처리해 준다고 가정할 때 스레드마다 고유한 식별자를 연관시키기 위해서는 TLS가 있어야만 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;465-스케줄러-액티베이션-scheduler-activations&quot;&gt;4.6.5 스케줄러 액티베이션 (Scheduler Activations)&lt;/h4&gt;

&lt;p&gt;many to many 또는 two level model을 구현하는 많은 시스템은 사용자와 커널 스레드 사이에 중간 자료구조를 둔다. 이 자료구조는 통상 &lt;strong&gt;경량 프로세스 또는 LWP&lt;/strong&gt;라고 불리며 아래의 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사용자 스레드 라이브러리에 LWP 방식은 어플리케이션이 사용자 스레드를 수행하기 위하여 스케줄 할 가상 처리기(virtual processor)처럼 보인다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-10.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 LWP는 하나의 커널 스레드에 부속되어 있으며 Processor가 스케줄 하는 대상은 바로 이 커널 스레드이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사용자 스레드 라이브러리와 커널 스레드 간의 통신 방법의 하나는 스케줄러 액티베이션이라고 알려진 방법이다.&lt;/strong&gt; 커널은 어플리케이션에 LWP의 집합을 제공하고 어플리케이션은 사용자 스레드를 가용한 가상 처리기(LWP)로 스케줄 한다. 커널은 어플리케이션에 특정 이벤트에 대해 알려줘야 한다. 이 프로시저를 &lt;strong&gt;upcall&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;Upcall은 스레드 라이브러리의 upcall 처리기에 의해 처리되고, upcall 처리기는 가상 처리기상에서 실행되어야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;47-운영체제-사례-operating-system-examples&quot;&gt;4.7 운영체제 사례 (Operating System Examples)&lt;/h3&gt;

&lt;h4 id=&quot;471-windows-스레드-windows-threads&quot;&gt;4.7.1 Windows 스레드 (Windows Threads)&lt;/h4&gt;

&lt;p&gt;Windows 어플리케이션들은 프로세스 형태로 실행되며 이들 각 프로세스는 한개 또는 그 이상의 스레드를 가질 수 있다. &lt;u&gt;Windows는 사용자 수준 스레드 하나마다 커널 스레드 하나가 맵핑되는 일대일 대응을 사용한다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스레드의 일반적인 구성요소는 다음과 같다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;각 스레드를 유일하게 지목하는 스레드 ID&lt;/li&gt;
  &lt;li&gt;처리기의 상태를 나타내는 레지스터 집합&lt;/li&gt;
  &lt;li&gt;프로그램 카운터(PC)&lt;/li&gt;
  &lt;li&gt;사용자 모드에서 실행될 때 필요한 사용자 스택, 커널 모드에서 실행될 때 필요한 커널 스택&lt;/li&gt;
  &lt;li&gt;실행 시간 라이브러리와 동적 링크 라이브러리(DLL) 등이 사용하는 개별 데이터 저장 영역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;스레드의 주요 자료 구조는 다음과 같다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ETHREAD: 실행 스레드 블록(executive thread block)
    &lt;ul&gt;
      &lt;li&gt;스레드가 속한 프로세스를 가리키는 포인터와 스레드가 실행을 시작해야 할 루틴의 주소 등이 있다.&lt;/li&gt;
      &lt;li&gt;ETHREAD는 KTHREAD에 대한 포인터도 가지고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KTHREAD: 커널 스레드 블록(kernel thread block)
    &lt;ul&gt;
      &lt;li&gt;스레드의 스케줄링 및 동기화 정보를 가지고 있다.&lt;/li&gt;
      &lt;li&gt;커널 모드에서 실행될 때 사용되는 커널 스택과 TEB에 대한 포인터를 가지고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TEB: 스레드 환경 블록(thread environment block)
    &lt;ul&gt;
      &lt;li&gt;스레드 식별자, 사용자 모드 스택 및 TLS를 위한 배열을 가지고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ETHREAD와 KTHREAD는 모두 커널 안에 존재하지만 TEB는 사용자 모드에서 실행될 때 접근되는 사용자 공간 자료 구조이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림은 Windows 스레드의 구조를 나타낸 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-11.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;472-linux-스레드-linux-threads&quot;&gt;4.7.2 Linux 스레드 (Linux Threads)&lt;/h4&gt;

&lt;p&gt;Linux는 프로세스와 스레드를 구별하지 않는다. &lt;strong&gt;사실 Linux는 프로그램 내의 제어 흐름을 나타내기 위하여 프로세스나 스레드보다는 &lt;u&gt;태스크&lt;/u&gt;라는 용어를 사용한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;clone()이 호출될 때 부모와 자식 태스크가 자료구조를 얼마나 공유할지 결정하는 플래그의 집합이 전달된다. 이는 아래의 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/threads-and-concurrency-12.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linux 커널이 태스크를 표현하는 방식 때문에 다양한 공유 수준이 가능하다. 시스템의 태스크마다 고유한 커널 자료구조가(struct task_struct) 존재한다. 이 자료구조는 태스크의 데이터를 저장하는 것이 아니라 데이터가 저장된 다른 자료구조를 가리키는 포인터를 포함한다.&lt;/p&gt;

&lt;p&gt;이러한 태스크를 표현하는 방식 때문에 clone()을 사용해서 태스크간에 다양한 공유 수준이 가능하다. 또한 clone() 시스템 콜의 융통성은 컨테이너 개념으로 확장될 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이번 4장은 나에게 익숙하지 않은 개념들이 많아서 이해하는데 어려웠다!!! 하지만, 이러한 기반 기술 및 기법들은 모든 High Tech의 기초이기 때문에 추후에 꼭 한번 더 살펴볼 것을 기약하고 다음 장인 CPU Scheduling 으로 넘어가도록 하겠다.&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/computer-science(cs)/2020/10/14/Threads-and-Concurrency.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer-science(cs)/2020/10/14/Threads-and-Concurrency.html</guid>
        
        <category>Operating-System</category>
        
        <category>CS</category>
        
        <category>Threads</category>
        
        <category>Concurrency</category>
        
        
        <category>Computer-Science(CS)</category>
        
      </item>
    
      <item>
        <title>[Operating System - Chapter 3] 프로세스</title>
        <description>&lt;p&gt;이 포스팅은 공룡책으로 알려진 Operating System Concepts의 3장인 Process를 공부하면서 정리한 포스팅이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-프로세스-process&quot;&gt;3. 프로세스 (Process)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;프로세스 : 실행 중인 프로그램을 말한다. 프로세스는 현대의 컴퓨팅 시스템에서의 작업의 단위이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;시스템은 사용자 코드를 실행하는 프로세스와 운영체제 코드를 실행하는 프로세스들의 집합이다. 이들 모든 프로세스는 잠재적으로 병행 실행이 가능하고 CPU는 이들 프로세스 가운데서 &lt;strong&gt;다중화(multiplex)&lt;/strong&gt; 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;다중화(Multiplex)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;여러 프로세스들 사이에서 이들을 처리(?)한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;31-프로세스-개념-process-concept&quot;&gt;3.1 프로세스 개념 (Process Concept)&lt;/h3&gt;

&lt;h4 id=&quot;311-프로세스-the-process&quot;&gt;3.1.1 프로세스 (The Process)&lt;/h4&gt;

&lt;p&gt;비공식적으로, 프로세스란 실행 중인 프로그램이다. 프로세스의 현재 활동의 상태는 &lt;strong&gt;프로그램 카운터(PC) 값&lt;/strong&gt;과 &lt;strong&gt;프로세서 레지스터의 내용&lt;/strong&gt;으로 나타낸다.&lt;/p&gt;

&lt;p&gt;프로세스의 메모리는 아래의 그림과 같이 배치되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-1.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;text :&lt;/strong&gt; 실행 코드&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;data :&lt;/strong&gt; 전역 변수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;heap :&lt;/strong&gt; 프로그램 실행 중에 동적으로 할당되는 메모리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;stack :&lt;/strong&gt; 함수를 호출할 때 임시 데이터 저장장소 (ex. 함수 매개변수, 복귀 주소, 지역변수, …)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stack 및 heap 섹션은 Runtime에 서로의 방향으로 더 커질 수 있음으로 &lt;u&gt;운영체제는 서로 겹치지 않도록 해야 한다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그램(Program)은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일(실행 파일이라고 불림)과 같은 &lt;u&gt;수동적인 존재(passive entity)&lt;/u&gt;이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스(Process)는 다음에 실행할 명령어를 지정하는 프로그램 카운터(PC)와 관련 자원의 집합을 가진 &lt;u&gt;능동적인 존재(active entity)&lt;/u&gt;이다. &lt;u&gt;실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다는 사실에 주목해야 한다. (ex. JVM)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JVM은 적재된 Java 코드를 해석하고 그 코드를 대신하여 원 기계어를 이용하여 행동을 취하는 프로세스로서 프로그램을 실행한다.&lt;/p&gt;

  &lt;p&gt;java 명령어는 JVM을 보통의 프로세스처럼 실행시키고, JVM은 Java 프로그램을 가상기계 안에서 실행한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;312-프로세스-상태-process-state&quot;&gt;3.1.2 프로세스 상태 (Process State)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;프로세스는 실행되면서 그 상태가 변한다.&lt;/strong&gt; 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다.&lt;/p&gt;

&lt;p&gt;아래의 Status Diagram을 참고해 프로세스의 상태에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-2.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;new :&lt;/strong&gt; 프로세스가 생성 중이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;running :&lt;/strong&gt; 명령어들이 실행되고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;waiting :&lt;/strong&gt; 프로세스가 어떤 이벤트(입출력 완료 또는 신호의 수신 같은)가 일어나기를 기다린다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ready :&lt;/strong&gt; 프로세스가 Processor에 할당되기를 기다린다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;terminated :&lt;/strong&gt; 프로세스의 실행이 종료되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;어느 한 순간에 한 Processor의 코어에서는 오직 하나의 프로세스만이 실행된다는 것을 인식하는 것이 중요하다.&lt;/strong&gt; 그렇지만 많은 프로세스가 &lt;strong&gt;ready or waiting 상태&lt;/strong&gt;에 있을 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;313-프로세스-제어-블록-process-control-block&quot;&gt;3.1.3 프로세스 제어 블록 (Process Control Block)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;각 프로세스는 운영체제에서 프로세스 제어 블록(process control block, PCB)에 의해 표현된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림은 PCB를 나타내며 이를 통해 PCB에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-3.png&quot; style=&quot;width:40%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로세스 상태 :&lt;/strong&gt; 프로세스의 상태(new, ready, running, waiting, …)를 나타낸다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그램 카운터 :&lt;/strong&gt; 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU 레지스터들 :&lt;/strong&gt; 레지스터들과 상태 코드에 대한 정보가 포함된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU-스케줄링 정보 :&lt;/strong&gt; 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 관리 정보 :&lt;/strong&gt; 운영체제에 의해 사용되는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;회계 정보 :&lt;/strong&gt; CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;입출력 상태 정보 :&lt;/strong&gt; 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;요약하면 PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는데 필요한 모든 데이터를 위한 저장소의 역할을 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;314-스레드-threads&quot;&gt;3.1.4 스레드 (Threads)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;프로세스의 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 그들은 따라서 &lt;u&gt;프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용&lt;/u&gt;한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;스레드 활용 예시&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;ex) 다중 스레드 워드 프로세서는 하나의 스레드에 사용자 입력 관리를 맡기는 동안 다른 스레드가 철자 검사기를 수행하도록 만들 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;32-프로세스-스케줄링-process-scheduling&quot;&gt;3.2 프로세스 스케줄링 (Process Scheduling)&lt;/h3&gt;

&lt;p&gt;다중 프로그래밍의 목적은 &lt;strong&gt;CPU 이용을 최대화&lt;/strong&gt;하기 위하여 항상 어떤 프로세스가 실행되도록 하는 데 있다.&lt;/p&gt;

&lt;p&gt;시분할의 목적은 각 프로그램이 실행되는 동안 &lt;strong&gt;사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU코어를 빈번하게 교체&lt;/strong&gt;하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;위의 목적을 달성하기 위해 프로세스 스케줄러(Process Scheduler)는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다.&lt;/strong&gt; 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;현재 메모리에 있는 프로세스 수를 &lt;strong&gt;다중 프로그래밍 정도&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;321-스케줄링-큐-scheduling-queue&quot;&gt;3.2.1 스케줄링 큐 (Scheduling Queue)&lt;/h4&gt;

&lt;p&gt;프로세스가 시스템에 들어가면 &lt;strong&gt;준비 큐(Ready Queue)&lt;/strong&gt;에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.&lt;/p&gt;

&lt;p&gt;I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 &lt;strong&gt;대기 큐(Wait Queue)&lt;/strong&gt;에 삽입된다.&lt;/p&gt;

&lt;p&gt;프로세스 스케줄링의 일반적인 표현은 아래와 같은 &lt;strong&gt;큐잉 다이어그램&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-4.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원은 큐에 서비스를 제공하는 자원을 나타내고 화살표는 시스템의 프로세스의 흐름을 나타낸다. 이 다이어그램을 통해서 말하고 싶은 것은 3가지이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다.&lt;/li&gt;
  &lt;li&gt;프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.&lt;/li&gt;
  &lt;li&gt;인터럽트 또는 타임슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;322-cpu-스케줄링-cpu-scheduling&quot;&gt;3.2.2 CPU 스케줄링 (CPU Scheduling)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다.&lt;/strong&gt; CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;323-문맥-교환-context-switch&quot;&gt;3.2.3 문맥 교환 (Context Switch)&lt;/h4&gt;

&lt;p&gt;인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어 &lt;strong&gt;커널 루틴&lt;/strong&gt;을 실행할 수 있게 한다. 이러한 연산은 범용 시스템에서는 자주 발생한다. &lt;strong&gt;인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 &lt;u&gt;문맥(Context)&lt;/u&gt;을 복구할 수 있도록 현재 실행 중인 프로세스의 문맥을 저장할 필요가 있다. 이는 PCB에 저장된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;문맥(Context)은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.&lt;/p&gt;

&lt;p&gt;CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다. 이 작업은 &lt;strong&gt;문맥 교환(context switch)&lt;/strong&gt;이라고 하고 아래의 그림에 묘사되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-5.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;운영체제가 복잡할수록, 문맥 교환 시 해야만 하는 작업의 양이 더 많아진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;33-프로세스에-대한-연산-operation-on-processes&quot;&gt;3.3 프로세스에 대한 연산 (Operation on Processes)&lt;/h3&gt;

&lt;p&gt;대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다. 그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;331-프로세스-생성-process-creation&quot;&gt;3.3.1 프로세스 생성 (Process Creation)&lt;/h4&gt;

&lt;p&gt;프로세스가 실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;생성하는 프로세스를 &lt;strong&gt;부모 프로세스&lt;/strong&gt;라고 부르고, 새로운 프로세스는 &lt;strong&gt;자식 프로세스&lt;/strong&gt;라고 부른다. 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며 그 결과 &lt;strong&gt;&lt;u&gt;프로세스의 트리(The tree of processes)&lt;/u&gt;&lt;/strong&gt;를 형성한다.&lt;/p&gt;

&lt;p&gt;현대 운영체제들은 유일한 &lt;strong&gt;프로세스 식별자(pid)&lt;/strong&gt;를 사용하여 프로세스를 구분하는데 이 식별자는 보통 정수이다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 Linux 운영체제의 전형적인 프로세스 트리이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-6.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;언제나 pid가 1인 systemd 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행하고 시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스이다.&lt;/u&gt; 시스템이 부팅되면 systemd프로세스는 다양한 사용자 프로세스를 생성한다.&lt;/p&gt;

&lt;p&gt;일반적으로 프로세스가 자식 프로세스를 생성할 때, 그 &lt;strong&gt;자식 프로세스는 자신의 임무를 달성하기 위하여 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치)이 필요&lt;/strong&gt;하다. 이 자원은 운영체제로부터 직접 얻을 수도 있고, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한(시스템 과부하 방지)할 수도 있다.&lt;/p&gt;

&lt;p&gt;물리적, 논리적 자원을 제공하는 것 이외에 부모 프로세스는 자식 프로세스에 &lt;strong&gt;초기화 데이터(입력)를 전달&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스가 새로운 프로세스를 생성할 때, &lt;u&gt;두 프로세스를 실행시키는 데 두 가지 가능한 방법&lt;/u&gt;이 존재한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;부모와 자식은 병행하게 실행을 계속한다.&lt;/li&gt;
  &lt;li&gt;부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;&lt;u&gt;새로운 프로세스들의 주소 공간 측면&lt;/u&gt;에서 볼 때 다음과 같은 두 가지 가능성이 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.&lt;/li&gt;
  &lt;li&gt;자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;UNIX 운영체제에서 새로운 프로세스의 생성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-7.png&quot; style=&quot;width:90%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 프로세스는 fork() 시스템 콜로 생성되고, 원래 프로세스의 주소 공간의 복사본으로 구성된다.&lt;/li&gt;
  &lt;li&gt;exec() 시스템 콜은 이진 파일을 메로리로 적재(load)하고 그 프로그램을 실행을 시작한다.
    &lt;ul&gt;
      &lt;li&gt;원래의 프로그램의 메모리 이미지를 파괴한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모 프로세스는 자식 프로세스가 실행되는 동안 할 일이 없으면 자식이 종료될 때까지 준비 큐에서 자신을 제거하기 위해 wait() 시스템 콜을 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Windows 운영체제에서 새로운 프로세스의 생성&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows API의 CreateProcess() 함수를 이용하여 새로운 프로세스를 생성한다.
    &lt;ul&gt;
      &lt;li&gt;CreateProcess() API는 자식 프로세스가 생성될 때 주소 공간에 명시된 프로그램을 적재한다. (10개 이상의 매개변수를 요구)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WaitForSingleObject() 함수는 자식 프로세스의 핸들을 전달받고 이 프로세스가 종료되기를 기다린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;332-프로세스-종료-process-termination&quot;&gt;3.3.2 프로세스 종료 (Process Termination)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 콜을 사용하여 운영체제에 자신의 삭제를 요청하면 종료한다.&lt;/strong&gt; 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 할당 해제되고 운영체제로 반납된다.&lt;/p&gt;

&lt;p&gt;다른 방법으로 한 프로세스는 적당한 시스템 콜(ex. TerminateProcess())을 통해서 다른 프로세스의 종료를 유발할 수 있다. 통상적으로 그런 시스템 콜은 단지 종료될 프로세스의 부모만이 호출할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부모 프로세스는 다음과 같이 여러가지 이유로 자식 중 하나의 실행을 종료할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자식이 자신에게 할당된 자원을 초과하여 사용할 때&lt;/li&gt;
  &lt;li&gt;자식에게 할당된 태스트가 더이상 필요 없을 때&lt;/li&gt;
  &lt;li&gt;부모가 exit를 하는데, 운영체제는 부모가 exit 한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로세스가 종료하면 사용하던 자원은 운영체제가 되찾아 간다. &lt;strong&gt;종료되었지만 부모 프로세스가 아직 wait() 호출을 하지 않은 프로세스를 좀비(zombie) 프로세스라고 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부모 프로세스가 wait()을 호출해서 자식 프로세스의 종료를 기다리지 않고 자신을 종료해버린다면 이 상황에 부닥친 자식 프로세스를 &lt;u&gt;고아(orphan) 프로세스&lt;/u&gt;&lt;/strong&gt;라고 한다. UNIX의 경우 고아 프로세스는 init 프로세스(Linux의 systemd와 동일)가 상속하고 종료를 관리한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android 프로세스 계층 (Android Process Hierarchy)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Android는 임의의 프로세스를 종료하지 않고 프로세스의 &lt;strong&gt;중요도 계층&lt;/strong&gt;을 식별했으며, 시스템이 프로세스를 종료하여 새로운 또는 보다 중요한 프로세스를 위한 자원을 확보해야 할 경우 &lt;strong&gt;중요도가 낮은 프로세스부터 종료한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The order of process importance in android&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;forground processs&lt;/li&gt;
  &lt;li&gt;visible process&lt;/li&gt;
  &lt;li&gt;service process&lt;/li&gt;
  &lt;li&gt;background process&lt;/li&gt;
  &lt;li&gt;empty process&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉, 시스템 자원을 회수해야만 하는 경우 Android는 먼저 empty process -&amp;gt; background process -&amp;gt; … 순서로 종료한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;34-프로세스-간-통신-interprocess-communication&quot;&gt;3.4 프로세스 간 통신 (Interprocess Communication)&lt;/h3&gt;

&lt;p&gt;운영체제 내에서 실행되는 &lt;strong&gt;병행 프로세스들은 독립적이거나 또는 협력적인 프로세스들&lt;/strong&gt; 일 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스 협력을 허용하는 환경을 제공하는 데는 몇 가지 이유가 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;정보 공유(information sharing) :&lt;/strong&gt; 여러 응용 프로그램이 동일한 정보에 흥미를 느낄 수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;계산 가속화(computation speedup) :&lt;/strong&gt; 만일 우리가 특정 태스크를 빨리 실행하고자 한다면, 우리는 그것을 서브태스크로 나누어 이들 각각이 다른 서브태스크들과 병렬로 실행되게 해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈성(modularity) :&lt;/strong&gt; 시스템 기능을 별도의 프로세스들 또는 스레드들로 나누어, 모듈식 형태로 시스템을 구성하기를 원할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;협력적 프로세스들은 데이터를 교환할 수 있는, &lt;strong&gt;즉 서로 데이터를 보내거나 받을 수 있는 프로세스 간 통신(IPC) 기법&lt;/strong&gt;이 필요하다. 프로세스 간 통신에는 기본적으로 &lt;strong&gt;공유 메모리(sharing memory)&lt;/strong&gt;와 &lt;strong&gt;메시지 전달(message passing)&lt;/strong&gt;의 두 가지 모델이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 메모리 모델에서는 협력 프로세스들에 의해 공유되는 메모리의 영역이 구축된다.
    &lt;ul&gt;
      &lt;li&gt;공유 메모리 영역을 구축할 때만 시스템 콜이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메시지 전달 모델에서는 통신이 협력 프로세스들 사이에 교환되는 메시지를 통하여 이루어진다.
    &lt;ul&gt;
      &lt;li&gt;분산 시스템에서 공유메모리보다 구현하기 쉽다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;메시지 전달 시스템은 통상 시스템 콜을 사용하여 구현되므로 커널 간섭 등의 부가적인 시간 소비 작업이 필요하기 때문에 공유 메모리 모델이 메시지 전달보다 더 빠르다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림은 위에 소개된 2가지의 통신 모델(공유 메모리, 메시지 전달)의 그림을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-8.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;35-공유-메모리-시스템에서의-프로세스-간-통신-ipc-in-shared-memory-systems&quot;&gt;3.5 공유 메모리 시스템에서의 프로세스 간 통신 (IPC in Shared-Memory Systems)&lt;/h3&gt;

&lt;p&gt;공유 메모리를 사용하는 프로세스 간 통신에서는 &lt;strong&gt;통신하는 프로세스들이 공유 메모리 영역을 구축&lt;/strong&gt;해야 한다.&lt;/p&gt;

&lt;p&gt;통상 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다. &lt;u&gt;이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가하여야 한다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;협력하는 프로세스의 개념을 설명하기 위해서, 협력하는 프로세스의 일반적인 패러다임인 생산자-소비자 문제를 생각해 보자. 생산자 프로세스는 정보를 생성하고 소비자 프로세스는 정보를 소비한다. 생산자-소비자 문제의 하나의 해결책은 &lt;strong&gt;공유 메모리(buffer)를 사용&lt;/strong&gt;하는 것이다.&lt;/p&gt;

&lt;p&gt;생산자와 소비자가 병행하게 공유 버퍼를 접근하는 상황에 대한 고려 즉, &lt;strong&gt;동기화&lt;/strong&gt;도 고려해야만 한다. (Locking을 사용할 수 있다.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;36-메시지-전달-시스템에서의-프로세스-간-통신-ipc-in-message-passing-systems&quot;&gt;3.6 메시지 전달 시스템에서의 프로세스 간 통신 (IPC in Message-Passing Systems)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다.&lt;/strong&gt; 특히 분산된 환경에서 유용하다.&lt;/p&gt;

&lt;p&gt;만약 프로세스 P와 Q가 통신을 원하면, 반드시 서로 메시지를 보내고 받아야 한다. 이들 사이에 &lt;strong&gt;통신 연결(communication link)&lt;/strong&gt;이 설정되어야 한다. 이 연결은 다양한 논리적 방법으로 구현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;직접 또는 간접 통신&lt;/li&gt;
  &lt;li&gt;동기식 또는 비동기식 통신&lt;/li&gt;
  &lt;li&gt;자동 또는 명시적 버퍼링&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;361-명명-naming&quot;&gt;3.6.1 명명 (Naming)&lt;/h4&gt;

&lt;p&gt;통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다. 이들은 간접 통신 또는 직접 통신을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;직접 통신하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;send(P, message) : 프로세스 P에 메시지를 전송한다.&lt;/li&gt;
  &lt;li&gt;receive(Q, message) : 프로세스 Q로부터 메시지를 수신한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;직접 통신 기법에서 통신 연결은 다음의 특성을 가진다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축된다. 프로세스들은 통신하기 위해 상대방의 신원(identity)만 알면 된다.&lt;/li&gt;
  &lt;li&gt;연결은 정확히 두 프로세스 사이에만 연관된다.&lt;/li&gt;
  &lt;li&gt;통신하는 프로세스들의 각 쌍 사이에는 정확히 하나의 연결이 존재해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 기법은 주소 방식에서 대칭성을 보이나, 주소 지정 시에 비대칭을 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;간접 통신에서 메시지들은 &lt;u&gt;메일박스(mailbox) 또는 포트(port)&lt;/u&gt;로 송신되고, 그것으로부터 수신된다.&lt;/strong&gt; 포트는 추상적으로 프로세스들에 의해 메시지들이 넣어지고 메시지들이 제거될 수 있는 객체라고도 볼 수 있다.&lt;/p&gt;

&lt;p&gt;각 포트(메일박스)는 고유의 id를 가지고 두 프로세스들이 공유 포트(메일박스)를 가질 때만 이들 프로세스가 통신할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;send(A, message) : 메시지를 메일박스 A로 송신한다.&lt;/li&gt;
  &lt;li&gt;receive(A, message) : 메시지를 메일박스 A로부터 수신한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;간접 통신 방법에서 통신 연결은 다음의 성질을 가진다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축된다.&lt;/li&gt;
  &lt;li&gt;연결은 두 개 이상의 프로세스들과 연관될 수 있다.&lt;/li&gt;
  &lt;li&gt;통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, &lt;strong&gt;각 연결은 하나의 메일박스(포트)에 대응된다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;메일박스는 한 프로세스 또는 운영체제에 의해 소유될 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;362-동기화-synchronization&quot;&gt;3.6.2 동기화 (Synchronization)&lt;/h4&gt;

&lt;p&gt;프로세스 간의 통신은 send와 receive 프리미티브에 대한 호출에 의해 발생한다. 각 프리미티브를 구현하기 위한 서로 다른 설계 옵션이 있다. &lt;strong&gt;메시지 전달은 봉쇄형(blocking)이거나 비봉쇄형(nonblocking) 방식으로 전달된다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;blocking send : 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 봉쇄된다.&lt;/li&gt;
  &lt;li&gt;nonblocking send : 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.&lt;/li&gt;
  &lt;li&gt;blocking receive : 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.&lt;/li&gt;
  &lt;li&gt;nonblocking receive : 송신하는 프로세스가 유효한 메시지 또는 null을 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send()와 receive()가 모두 봉쇄형일 때, 우리는 송신자와 수신자 간에 &lt;strong&gt;랑데부(rendezvous)&lt;/strong&gt;를 하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;363-버퍼링-buffering&quot;&gt;3.6.3 버퍼링 (Buffering)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;통신이 직접적이든 간접적이든 간에, 통신하는 프로세스에 의해 교환되는 메시지는 임시 큐에 들어 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 큐를 구현하는 방식은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;무 용량(zero capacity) :&lt;/strong&gt; 큐의 최대 길이가 0이다. 즉, 링크는 자체 안에 대기하는 메시지들을 가질 수 없다. 이 경우에,송신자는 메시지를 수신할 때까지 기다려야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유한 용량(bounded capacity) :&lt;/strong&gt; 큐는 유한한 길이 n을 가진다. 즉, 최대 n개의 메시지가 그 안에 들어 있을 수 있다. 큐가 가득 차면 봉쇄된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;무한 용량(unbounded capacity) :&lt;/strong&gt; 큐는 잠재적으로 무한한 길이를 가진다. 따라서 메시지들이 얼마든지 큐 안에서 대기할 수 있다. 송신자는 절대 봉쇄되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;37-ipc-시스템의-사례-examples-of-ipc-systems&quot;&gt;3.7 IPC 시스템의 사례 (Examples of IPC Systems)&lt;/h3&gt;

&lt;p&gt;네 가지 다른 IPC 시스템을 탐구해 보자.&lt;/p&gt;

&lt;h4 id=&quot;371-posix-공유-메모리-posix-shared-memory&quot;&gt;3.7.1 POSIX 공유 메모리 (POSIX Shared Memory)&lt;/h4&gt;

&lt;p&gt;POSIX 공유 메모리는 memory-mapped 파일을 사용하여 구현된다. memory-mapped 파일은 공유 메모리의 특정 영역을 파일과 연관시킨다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;fd = shm_open(name,  O_CREAT | O_RDWR, 0666)&lt;/code&gt; 와 같이 시스템 콜을 사용하여 공유 메모리 객체를 생성한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ftruncate(fd, SIZE)&lt;/code&gt;와 같은 함수를 사용하여 공유 메모리 객체의 크기를 바이트 단위로 설정한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ptr = (char *)mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)&lt;/code&gt;와 같은 함수를 사용하여 공유 메모리 객체를 포함하는 memory-mapped 파일을 구축한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;372-mach-메시지-전달-mach-message-passing&quot;&gt;3.7.2 Mach 메시지 전달 (Mach Message Passing)&lt;/h4&gt;

&lt;p&gt;모든 태스크 간 통신을 포함하여 Mach에서 대부분의 통신은 &lt;strong&gt;메시지(Message)&lt;/strong&gt;로 수행된다. Mach에서 &lt;strong&gt;포트(port)&lt;/strong&gt;라고 하는 메일박스로 메시지를 주고 받는다. 포트는 크기가 정해져 있고 단방향이다.
양방향 통신의 경우 메시지가 한 포트로 전송되고 응답이 별도의 응답 포트로 전송된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;각 포트에는 여러 송신자가 있을 수 있지만 수신자는 오직 하나만 존재한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;태스크가 생성되면 Task Self 포트와 Notify 포트라는 두 개의 특별한 포트도 생성된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;커널은 Task Self 포트에 대한 수신 권한을 가지고 있어 태스크가 커널에 메시지를 보낼 수 있다.&lt;/li&gt;
  &lt;li&gt;커널의 이벤트 발생 알림을 작업의 Notify 포트로 보낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mach_port_allocate() API는 새 포트를 작성하고 메시지 큐를 위한 공간을 할당한다. 또한 포트에 대한 권한을 식별한다.&lt;/p&gt;

&lt;p&gt;각 태스크는 또한 &lt;strong&gt;부트스트랩 포트&lt;/strong&gt;에 액세스 할 수 있어서 태스크가 생성한 포트를 시스템 전체의 &lt;strong&gt;부트스트랩 서버&lt;/strong&gt;에 등록할 수 있다. &lt;u&gt;포트가 부트스트랩 서버에 등록되면 다른 태스크가 이 레지스트리에서 포트를 검색하여 포트로 메시지를 보낼 수 있는 권한을 얻을 수 있다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;mach_msg() 함수는 메시지를 보내고 받는 표준 API이다. mach_msg()가 호출되면 이는 mach_msg_trap() 함수를 호출하고 mach_msg_trap()은 mach_msg_overwrite_trap()함수를 호출하여 메시지의 실제 전달을 처리한다.&lt;/p&gt;

&lt;p&gt;포트(메일박스)가 가득 찼을 경우 mach_msg()에서 설정할 수 있는 옵션&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;큐에 공간이 생길 때까지 무기한 기다린다.&lt;/li&gt;
  &lt;li&gt;최대 n 밀리초 동안 기다린다.&lt;/li&gt;
  &lt;li&gt;기다리지 말고 즉시 복귀한다.&lt;/li&gt;
  &lt;li&gt;메시지를 일시적으로 캐시 한다. 메시지가 전송되는 큐가 가득 차더라도 운영체제에 전달하여 보존한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;메시지 시스템의 주요 문제점은 일반적으로 송신자의 포트에서 수신자의 포트로 메시지를 복사해야 하므로 발생하는 성능 저하이다.&lt;/strong&gt;(가상 메모리 관리 기술을 사용하면 같은 시스템 내의 메시지 전송간에 성능 저하를 최소화 할 수 있다.)&lt;/p&gt;

&lt;h4 id=&quot;373-windows&quot;&gt;3.7.3 Windows&lt;/h4&gt;

&lt;p&gt;Windows는 다중 운영 환경 또는 서브시스템을 지원하며, &lt;strong&gt;Application은 메시지 전달(Message Passing) 기법을 통해 이들과 통신한다.&lt;/strong&gt; 따라서 응용 프로그램은 서브시스템 서버의 클라이언트로 간주할 수 있다.&lt;/p&gt;

&lt;p&gt;Windows의 메시지 전달 설비는 &lt;strong&gt;고급 로컬 프로시저 호출 설비(advanced local procedure call facility, ALPC)&lt;/strong&gt;라 불린다. &lt;strong&gt;ALPC는 동일 기계상에 있는 두 프로세스간의 통신에 사용한다.&lt;/strong&gt; 원격 프로시저 호출(RPC) 기법과 같으나, Windows에 맞게 특별히 최적화 되었다.&lt;/p&gt;

&lt;p&gt;Windows는 두 프로세스 간에 연결을 구축하고 유지하기 위해 &lt;strong&gt;포트 객체&lt;/strong&gt;를 사용한다. Windows는 &lt;strong&gt;연결 포트(Connection port)&lt;/strong&gt;와 &lt;strong&gt;통신 포트(communication port)&lt;/strong&gt;의 두 가지 유형의 포트를 사용한다.&lt;/p&gt;

&lt;p&gt;다음은 Windows의 ALPC 과정의 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-9.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALPC 채널이 생성되면 다음 3가지 중 하나의 메시지 전달 기법의 하나가 선택된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;256바이트까지의 작은 메시지의 경우, &lt;u&gt;포트의 메시지 큐가 중간 저장소로 사용되고&lt;/u&gt;, 메시지는 프로세스에서 프로세스로 복사된다.&lt;/li&gt;
  &lt;li&gt;대용량 메시지는 반드시 &lt;strong&gt;섹션 객체(Section Object)&lt;/strong&gt;를 통하여 전달되어야 한다. 섹션 객체란 채널과 연관된 공유 메모리의 영역을 말한다.&lt;/li&gt;
  &lt;li&gt;데이터의 양이 너무 많아서 섹션 객체에 저장될 수 없는 경우, 서버 프로세스가 클라이언트의 주소 공간을 직접 읽거나 쓸 수 있는 API를 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;클라이언트는 채널을 설정할 때 메시지 전달 기법을 설정해야만 한다. (즉, 대용량 메시지 전송의 필요 여부)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;Windows의 ALPC는 Windows API의 부분이 아니기 때문에 응용 프로그래머는 사용할 수 없다.&lt;/u&gt; Windows API를 사용하는 어플리케이션은 RPC(Remote Procedure Calls)를 부르고, &lt;strong&gt;같은 시스템 상에 존재하는 프로세스의 경우 RPC가 호출되면 이 RPC는 간접적으로 ALPC를 호출&lt;/strong&gt;하여 처리된다.&lt;/p&gt;

&lt;h4 id=&quot;374-파이프-pipes&quot;&gt;3.7.4 파이프 (Pipes)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;파이프는 두 프로세스가 통신할 수 있게 하는 전달자로서 동작한다.&lt;/strong&gt; 파이프는 초기 UNIX 시스템에서 제공하는 IPC 기법의 하나였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.7.4.1 일반 파이프 (Ordinary Pipes)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반 파이프는 생산자-소비자 형태로 두 프로세스 간에 통신을 허용한다.&lt;/strong&gt; 생산자는 파이프의 한 종단(쓰기 종단)에 쓰고, 소비자는 다른 종단(읽기 종단)에서 읽는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결과적으로 일반 파이프는 한쪽으로만 데이터를 전송할 수 있으며 오직 단방향 통신만을 가능하게 한다.&lt;/strong&gt; 양방향 통신이 필요하다면 각각 다른 방향으로 데이터를 전송할 수 있는 두 개의 파이프를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반 파이프는 파이프를 생성한 프로세스 이외에는 접근할 수 없다.&lt;/strong&gt; 따라서 통상 부모 프로세스가 파이프를 생성하고 fork()로 생성한 자식 프로세스와 통신하기 위해 사용한다.&lt;/p&gt;

&lt;p&gt;다음의 그림은 일반 파이프를 위한 파일 디스크립터를 나타낸 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-10.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;fd 배열은 파일 디스크립터와 부모 및 자식 프로세스의 관계를 보여준다. 이 그림에서 보듯이 부모가 파이프의 쓰기 종단(fd[1])에 데이터를 쓰면 파이프의 읽기 종단(fd[0])에서 자식이 읽을 수 있다.&lt;/p&gt;

&lt;p&gt;Windows 시스템은 일반 파이프를 &lt;strong&gt;익명 파이프(anonymous pipe)&lt;/strong&gt;라고 부른다. &lt;strong&gt;UNIX와 Windows 시스템 모두에서 통신하는 두 프로세스는 부모-자식 관계를 가져야 한다는 것을 꼭 명심하라!! 이 유형의 파이프는 동일한 기계상의 두 프로세스끼리만 통신이 가능하다는 것을 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.7.4.2 지명 파이프 (Named Pipes)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;지명 파이프(Named Pipes)는 양방향으로 통신이 가능하며 부모-자식 관계도 필요로 하지 않는다. &lt;u&gt;Named Pipes가 구축되면 여러 프로세스들이 이를 사용하여 통신할 수 있다.&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;통신 프로세스가 종료하더라도 지명 파이프는 계속 존재한다. UNIX와 Windows 시스템은 구현상에 차이점은 있지만 모두 지명 파이프를 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UNIX에서 지명 파이프는 FIFO&lt;/strong&gt;라고 부른다. 생성되면 지명 파이프는 파일 시스템의 보통 파일처럼 존재한다. 시스템 콜로 생성 및 조작되며 명시적으로 파일 시스템에서 삭제될 때까지 존재한다. 
&lt;strong&gt;FIFO는 반이중 전송만이 가능하다.&lt;/strong&gt; 서로 다른 기계에 존재하는 프로세스 사이에 통신이 필요하다면 소켓을 사용해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;반이중 통신 :&lt;/strong&gt; 양방향으로 데이터가 전송될 수는 있으나 양쪽에서 동시에 전송하는 것은 불가능한 방식&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;전이중 통신 :&lt;/strong&gt; 양쪽에서 동시에 데이터를 전송할 수 있는 방식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Windows 시스템의 지명 파이프는 전이중 통신을 허용하며, 통신하는 두 프로세스는 같은 기계 또는 다른 기계상에 존재할 수 있다.&lt;/strong&gt; 또한 Windows 시스템은 바이트-단위 또는 메시지-단위 데이터의 전송을 허용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;실제-파이프-사용-예시-in-unix&quot;&gt;실제 파이프 사용 예시 in UNIX&lt;/h4&gt;

  &lt;p&gt;&lt;strong&gt;파이프는 UNIX 명령어 라인 환경에서 한 명령의 출력이 다른 명령의 입력으로 사용되는 상황에서 자주 사용된다.&lt;/strong&gt; 파이프는 명령어 라인에서 | 문자를 사용하여 구축될 수 있다.&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ex) ls | less&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;이 시나리오에서 ls 명령은 생산자 역할을 하며 출력은 less 명령에 의해 소비된다.&lt;/p&gt;

  &lt;p&gt;Dos Shell도 파이프를 구축하기 위하여 | 문자를 사용한다.&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ex) dir | more&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;38-클라이언트-서버-환경에서-통신-communication-in-client-server-systems&quot;&gt;3.8 클라이언트 서버 환경에서 통신 (Communication in Client-Server Systems)&lt;/h3&gt;

&lt;p&gt;클라이언트 서버에서 사용할 수 있는 &lt;strong&gt;두 가지 다른 통신 전략(Socket, RPC)&lt;/strong&gt;에 대해서 설명하도록 하겠다.&lt;/p&gt;

&lt;h4 id=&quot;381-소켓-socket&quot;&gt;3.8.1 소켓 (Socket)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;소켓(socket)은 통신의 극점(endpoint)을 뜻한다.&lt;/strong&gt; 두 프로세스가 네트워크상에서 통신을 하려면 양 프로세스마다 하나씩, 총 두 개의 소켓이 필요하다. &lt;strong&gt;각 소켓은 IP 주소와 포트 번호 두가지를 접합(concatenate)해서 구별한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트 프로세스가 연결을 요청하면 호스트 컴퓨터가 포트 번호를 부여한다. 이 번호는 1024보다 큰 임의의 정수가 된다.&lt;/p&gt;

&lt;p&gt;아래의 그림을 통해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-11.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;두 호스트 사이에 패킷들이 오갈 때 그 패킷들은 이 목적지 포트 번호가 지정하는 데 따라 적절한 프로세스로 배달된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모든 연결은 유일한 소켓 쌍으로 구성되어야 한다!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;책에는 Java를 사용한 Socket 프로그래밍 예제가 아주 잘 나와 있음으로 이를 참고해 보자!!&lt;/p&gt;

&lt;p&gt;소켓을 이용한 통신은 분산된 프로세스 간에 널리 사용되고 효율적이기는 하나 스레드 간에 구조화되지 않은 바이트 스트림만을 통신하도록 하기 때문에 너무 낮은 수준이다. 이 바이트 스트림의 해석은 오롯이 클라이언트와 서버의 책임이 되기 때문에 더 높은 수준의 소켓 기반 통신을 사용해 보자.&lt;/p&gt;

&lt;h4 id=&quot;382-원격-프로시저-호출-remote-procedure-calls-rpc&quot;&gt;3.8.2 원격 프로시저 호출 (Remote Procedure Calls, RPC)&lt;/h4&gt;

&lt;p&gt;원격 서비스와 관련한 가장 보편적인 형태 중 하나는 RPC 패러다임으로서, &lt;strong&gt;네트워크에 연결된 두 시스템 사이의 통신에 사용하기 위하여 프로시저 호출 기법을 추상화하는 방법으로 설계되었다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원격 프로시저 호출(RPC)&lt;/strong&gt; (From Wiki)&lt;/p&gt;

  &lt;p&gt;별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다. 다시 말해, 
원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;RPC에서는 프로세스들이 서로 다른 시스템 위에서 돌아가기 때문에 원격 서비스를 제공하기 위해서는 &lt;u&gt;메시지 기반 통신&lt;/u&gt;을 해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RPC 통신에서 전달되는 &lt;strong&gt;메시지는 구조화 되어&lt;/strong&gt; 있고, &lt;strong&gt;데이터 패킷 수준을 넘어선다.&lt;/strong&gt; 각 메시지에는 원격지 포트에서 listen 중인 &lt;strong&gt;RPC 디먼&lt;/strong&gt;의 주소가 지정되어 있고 &lt;strong&gt;실행되어야 할 함수의 식별자&lt;/strong&gt;, 그리고 그 &lt;strong&gt;함수에게 전달되어야 할 매개변수&lt;/strong&gt;가 포함된다. 그런 후에 요청된 함수가 실행되고 &lt;strong&gt;어떤 출력이든지 별도의 메시지를 통해 요청자에게 반환&lt;/strong&gt;된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;데몬(디먼, Daemon)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;멀티태스킹 운영 체제에서 데몬(daemon, 발음: 데이먼/’deɪmən/ 또는 디먼 /’dimən/[1])은 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다.&lt;/strong&gt; 시스템 로그를 남기는 syslogd처럼 보통 데몬을 뜻하는 ‘d’를 이름 끝에 달고 있으며, 일반적으로 프로세스로 실행된다.&lt;/p&gt;

  &lt;p&gt;데몬은 대개 부모 프로세스를 갖지 않으며, 즉 PPID가 1이며, 따라서 &lt;strong&gt;프로세스 트리에서 init 바로 아래에 위치&lt;/strong&gt;한다. 데몬이 되는 방법은 일반적으로 자식 프로세스를 포크(fork)하여 생성하고 자식을 분기한 자신을 죽이면서 init이 고아가 된 자식 프로세스를 자기 밑으로 데려가도록 하는 방식이다. 이러한 방법을 ‘fork off and die’라 부르기도 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;원격 프로세스가 어떤 서비스를 받고자 하면 그 서비스에 대응되는 RPC 디먼이 listen하고 있는 포트 주소로 메시지를 보내야 한다. (보통 이를 도와주기 위해 &lt;strong&gt;matchmaker&lt;/strong&gt;가 존재한다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;matchmaker :&lt;/strong&gt; 클라이언트가 원하는 RPC Daemon의 포트번호를 알려주는 랑데부용 디먼이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RPC는 클라이언트가 원격 호스트의 프로시저 호출하는 것을 마치 자기의 프로시저 호출하는 것처럼 해준다. &lt;strong&gt;RPC 시스템은 클라이언트 쪽에 스텁을 제공하여 통신을 하는데 필요한 자세한 사항들을 숨겨준다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트 측에서는 서버에게 데이터를 보내기 전 매개변수 정돈 작업의 일환으로 전송할 데이터를 &lt;strong&gt;기종 중립적인 XDR 형태&lt;/strong&gt;로 바꾸어서 보낸다.&lt;/p&gt;

&lt;p&gt;RPC는 분산 파일 시스템(distributed file system, DFS)을 구현하는 데 유용하다. DFS는 몇 개의 RPC daemon과 클라이언트로 구현할 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 RPC의 실행을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/process-12.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.8.2.1 Android RPC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Android 운영체제는 바인더 프레임워크에 포함된 풍부한 IPC기법의 집합을 가지고 있는데, 이 중 RPC는 프로세스가 다른 프로세스의 서비스를 요청할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;Android 응용 프로그램 구성요소 중 하나는 사용자 인터페이스가 없지만 백그라운드로 실행되며 장기 실행 연산을 실행하거나 원격 프로세스에 대한 작업을 수행하는 서비스이다.&lt;/p&gt;

&lt;p&gt;이 서비스를 이용해 백그라운드에서 음악을 재생하고 다른 프로세스 대신 네트워크 연결을 통해 데이터를 검색하여 데이터를 다운로드 할 때 다른 프로세스가 실행 중단되는 것을 방지할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;여기까지 3장 Process에 대한 정리는 마치도록 하고 다음에는 4장 Threads &amp;amp; Concurrency로 돌아오도록 하겠다. Coming Soon~&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/computer-science(cs)/2020/10/02/Process.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer-science(cs)/2020/10/02/Process.html</guid>
        
        <category>Operating-System</category>
        
        <category>OS</category>
        
        <category>CS</category>
        
        <category>Computer</category>
        
        <category>Process</category>
        
        
        <category>Computer-Science(CS)</category>
        
      </item>
    
      <item>
        <title>CORS with Spring (MVC, Security)</title>
        <description>&lt;p&gt;이번 포스팅에서는 &lt;strong&gt;CORS with Spring (MVC, Security)&lt;/strong&gt;에 대해서 다루어 보도록 하겠다.&lt;/p&gt;

&lt;p&gt;프로젝트 진행간에 CORS(Cross-Origin Resource Sharing) 이슈를 경험하고 대략 두달이 지나서야 이 글을 작성한다. 다른 일들에 밀려 이제 글을 작성하는 것이 조금 못마땅하기도 하지만 블로깅을 놓지 않고 열심히 하는 내 모습이 대견하기도 하다.&lt;/p&gt;

&lt;p&gt;어쨋든 이 포스팅의 목적은 &lt;strong&gt;Spring에서 CORS이슈를 해결하는 방법&lt;/strong&gt;에 대해서 알아보기로 한 것이니 CORS란 무엇이고, 왜 나왔는지에 대해서 먼저 알아보도록 하자~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매번 느끼는 거지만, 무언가를 배우기 앞서 본질을 파악하는 것이 가장 중요한 것 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cors란-무엇인가&quot;&gt;CORS란 무엇인가?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CORS란 Cross-Origin Resource Sharing의 약자이다. 영어 그대로 해석해 보면 교차 출처 리소스 공유이다. 즉, 한 출처에서 실행중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 정책이다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;그렇다면 출처(Origin)이란 무엇일까?&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;도메인 + 프로토콜 + 포트를 통틀어 출처(Origin)이라고 한다.&lt;/strong&gt; 이 글에서는 출처를 오리진 or Origin이라고 부르도록 하겠다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;즉, 프로토콜, 포트, 호스트(도메인) 중 서로 하나라도 다를 경우 Cross Origin이라고 이해하면 된다.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;ex) http://localhost:8080/api 와 https://localhost:8080/api 은 Cross Origin이다. (프로토콜이 다르기 때문)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 CORS가 무엇인지에 대해서 알아보았음으로, 왜 CORS가 나오게 되었는지에 대해서 알아보도록 하자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cors는-왜-필요한가&quot;&gt;CORS는 왜 필요한가?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;보안 상의 이유로, 브라우저는 스크립트에서 시작한 Cross Origin HTTP Request를 제한한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ex) &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHttpRequest&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch API&lt;/code&gt;는 &lt;strong&gt;동일 출처 정책(SOP)&lt;/strong&gt;을 따른다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 이 API를 사용하는 웹 애플리케이션은 자신의 Origin과 동일한 리소스만 불러올 수 있으며, &lt;strong&gt;다른 Origin의 리소스를 불러오려면 그 Origin에서 올바른 CORS 헤더를 포함한 응답을 반환해야만 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;동일 출처 정책 (Same-Origin Policy)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;불러온 문서나 스크립트가 다른 출처(Origin)에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 이것은 잠재적 악성 문서를 격리하여, 공격 경로를 
줄이는데 도움이 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결국 대부분의 웹 어플리케이션의 Web API Client는 XMLHttpRequest 또는 Fetch API를 사용하기 떄문에 Cross Origin HTTP Request를 위해선 CORS 정책을 따라야만 한다.&lt;/p&gt;

&lt;p&gt;CORS란 무엇이고, 왜 필요한지에 대해서 알아보았으니, 우리는 Cross-Origin HTTP Request 간에 발생하는 여러 시나리오에 대해서 알아보도록 하자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;접근-제어-시나리오&quot;&gt;접근 제어 시나리오&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Simple Request (단순 요청)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Simple Request 조건을 모두 충족하는 요청을 Preflight request 없이 보내 서버는 이에 대한 응답으로 Access-Control-Allow-Origin 헤더를 응답하는 방식&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Access-Control-Allow-Origin : &amp;lt;origin&amp;gt; | *&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Origin을 지정하여 브라우저가 해당 Origin이 리소스에 접근하도록 허용한다. Credential이 없는 요청의 경우 &quot;*&quot; 와일드 카드는 브라우저의 origin에 상관없이 모든 리소스에 접근하도록 허용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;The Communication between client and server using simple request 
 &lt;img src=&quot;/assets/spring/cors-with-spring-2.png&quot; style=&quot;width:100%&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;preflighted request (프리플라이트 요청)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;OPTIONS&lt;/code&gt; 메서드를 통해 다른 도메인의 리소스로 HTTP request를 보내 실제 요청이 전송하기에 안전한지 확인한다. Cross-site request는 유저 데이터에 영향을 줄 수 있기 때문에 이와 같이 미리 전송(preflighted)한다.&lt;/li&gt;
      &lt;li&gt;The Communication between client and server using preflighted request
 &lt;img src=&quot;/assets/spring/cors-with-spring-3.png&quot; style=&quot;width:100%&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Access-Control-Request-Method: &amp;lt;method&amp;gt;&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Access-Control-Request-Method 헤더는 실제 요청에서 어떤 HTTP 메서드를 사용할지 서버에게 알려주기 위해, preflight request 할 때에 사용된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Access-Control-Allow-Methods: &amp;lt;method&amp;gt;[, &amp;lt;method&amp;gt;]*&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Access-Control-Allow-Methods 헤더는 리소스에 접근할 때 허용되는 메서드를 지정한다. 이 헤더는 preflight request에 대한 응답으로 사용된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Access-Control-Request-Headers: &amp;lt;header-name&amp;gt;[, &amp;lt;header-name&amp;gt;]*&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Access-Control-Request-Headers 헤더는 실제 요청에서 어떤 HTTP 헤더를 사용할지 서버에게 알려주기 위해, preflight request 할 때에 사용된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Access-Control-Allow-Headers: &amp;lt;header-name&amp;gt;[, &amp;lt;header-name&amp;gt;]*&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;preflight request 에 대한 응답으로 Access-Control-Allow-Headers 헤더가 사용된다. 실제 요청시 사용할 수 있는 HTTP 헤더를 나타낸다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;credentialed request (인증정보를 포함한 요청)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;credentialed requests는 HTTP cookies 와 HTTP Authentication 정보를 인식한다. 기본적으로 cross-site &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHttpRequest&lt;/code&gt; 나 Fetch 호출에서 브라우저는 자격 증명을 보내지 않는다. XMLHttpRequest 객체나 Request 생성자가 호출될 때 특정 플래그를 설정해야만 한다.&lt;/li&gt;
      &lt;li&gt;Access-Control-Allow-Credentials: true 로 응답하지 않으면, 응답은 무시되고 웹 컨텐츠는 제공되지 않는다.&lt;/li&gt;
      &lt;li&gt;The Communication between client and server using credentialed request
 &lt;img src=&quot;/assets/spring/cors-with-spring-4.png&quot; style=&quot;width:100%&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Access-Control-Allow-Credentials: true&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Access-Control-Allow-Credentials 헤더는 credentials 플래그가 true일 때 요청에 대한 응답을 표시할 수 있는지를 나타낸다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CORS에서 발생할수 있는 접근 제어 시나리오에 대해서 알아보았다. 이제는 스프링에서 어떻게 이러한 접근 제어 시나리오를 적절히 활용하는지에 대해서 알아보자!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cors-configuration-in-spring&quot;&gt;CORS Configuration in Spring&lt;/h2&gt;

&lt;p&gt;Spring에서 CORS 정책을 따르기 위한 설정에 대해서 알아보도록 하자!!&lt;/p&gt;

&lt;p&gt;나의 프로젝트에서는 Sprint Security와 MVC 모두 사용하였음으로 CORS를 위해서 Security와 MVC 설정이 모두 필요하였다.&lt;/p&gt;

&lt;h3 id=&quot;cors-with-spring-security&quot;&gt;CORS with Spring Security&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring Security에서 CORS를 다루는 가장 확실하고 쉬운 방법은 CorsFilter를 사용하는 것이다.&lt;/strong&gt; 사용자는 다음과 같이 CorsConfigurationSource를 제공하여 CorsFilter를 Spring Security와 통합 할 수 있다.&lt;/p&gt;

&lt;p&gt;Spring Security 사용시 CORS에 걸리지 않으려면 Authentication Filter 인증 보다 앞단계의 필터/인터셉터에서 path 검증로직이 일어나야만 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The CORS configuration in Spring Security&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebSecurityConfig&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebSecurityConfigurerAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpSecurity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// by default uses a Bean by the name of corsConfigurationSource&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;and&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// You can configure allowed Origin, Method, Header and Credential &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// and how long, as a duration, the response from a pre-flight request can be eached by clients&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;CorsConfigurationSource&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;corsConfigurationSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;CorsConfiguration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CorsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAllowedOrigins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://example.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAllowedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// you can configure many allowed CORS headers&lt;/span&gt;

		&lt;span class=&quot;nc&quot;&gt;UrlBasedCorsConfigurationSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UrlBasedCorsConfigurationSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerCorsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/**&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cors-with-spring-mvc&quot;&gt;CORS with Spring MVC&lt;/h3&gt;

&lt;p&gt;Spring MVC에서 CORS를 적용하는 방법은 크게 총 2가지로 나뉜다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;부분적으로 컨트롤러에서 CORS를 설정하는 방법 (Annotation based)&lt;/li&gt;
  &lt;li&gt;전역적으로 Spring MVC 설정에서 CORS를 설정하는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;컨트롤러에서-부분적으로-cors를-설정하는-방법&quot;&gt;컨트롤러에서 부분적으로 CORS를 설정하는 방법&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Handler 메소드에 @CrossOrigin 애노테이션을 붙이는 방법&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/account&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AccountController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;nd&quot;&gt;@CrossOrigin&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retrieve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;모든 Origin이 허용되고&lt;/li&gt;
  &lt;li&gt;@RequestMapping 애노테이션에서 명시되어진 HTTP 메소드가(GET Method) 허용된다.&lt;/li&gt;
  &lt;li&gt;preflight 응답이 캐시되어지는 시간은 30분이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Controller에 @CrossOrigin 애노테이션을 붙이는 방법&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@CrossOrigin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://example.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxAge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/account&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AccountController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retrieve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래스 레벨에 @CrossOrigin 애노테이션을 추가 했고, 해당 컨트롤러에 속해있는 두 핸들러 메소드 모두에게 클래스 레벨에서 설정한 CORS정책이 적용된다.&lt;/p&gt;

&lt;p&gt;@CrossOrigin 애노테이션을 통해 origins, methods, allowedHeaders, exposedHeaders, allowCredentials, maxAge 모두 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클래스 레벨과 메소드 레벨 모두에게 @CrossOrigin 애노테이션을 붙이는 방법&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@CrossOrigin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxAge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/account&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AccountController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;nd&quot;&gt;@CrossOrigin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://example.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retrieve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클래스 레벨의 @CrossOrigin 애노테이션이 기본으로 적용되고 핸들러 메소드의 @CrossOrigin 애노테이션이 추가로 적용된다.&lt;/p&gt;

&lt;h4 id=&quot;spring-mvc-설정에서-전역적으로-cors를-설정하는-방법&quot;&gt;Spring MVC 설정에서 전역적으로 CORS를 설정하는 방법&lt;/h4&gt;

&lt;p&gt;부분적으로 컨트롤러 마다 설정하는 애노테이션 기반 설정의 대안으로 Spring은 컨트롤러 외부에서 전역으로 CORS 설정을 할 수 있게 해준다. 이는 필터 기반 솔루션을 사용하는 것과 유사하지만 Spring MVC 내에서 선언하고 @CrossOrigin 설정과 결합할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaConfig를 통해 CORS 전역 설정&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@EnableWebMvc&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebConfig&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebMvcConfigurer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addCorsMappings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CorsRegistry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/**&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowedOrigins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.example.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowCredentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;maxAge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 JavaConfig를 통해 paths, origins, methods, allowedHeaders, exposedHeaders, allowCredentials, maxAge 모두 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;XML을 통해 CORS 전역 설정&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:cors&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/api/**&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;allowed-origins=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://domain1.com, http://domain2.com&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;allowed-methods=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET, PUT&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;allowed-headers=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;header1, header2, header3&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exposed-headers=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;header1, header2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;allow-credentials=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;max-age=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/resources/**&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;allowed-origins=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://domain1.com&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:cors&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 XMLConfig를 통해 paths, origins, methods, allowedHeaders, exposedHeaders, allowCredentials, maxAge 모두 설정할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;integration-cors-configuration-with-spring-mvc-and-security&quot;&gt;Integration CORS configuration with Spring MVC and Security&lt;/h3&gt;

&lt;p&gt;만약 Spring MVC의 CORS 지원을 사용한다면, Spring Security의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CorsConfigurationSource&lt;/code&gt; 설정을 생략(omit)할 수 있다. &lt;strong&gt;Spring Security는 Spring MVC에서 제공되어지는 CORS 설정을 활용(leverage)할 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기까지 CORS에 대해서 알아 보았다!!! 아래의 자료는 이 글을 작성하면서 참고한 문서이니 독자 여러분들도 참고 바란다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/spring-cors&quot;&gt;https://www.baeldung.com/spring-cors&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/4.2.x/reference/html/cors.html&quot;&gt;https://docs.spring.io/spring-security/site/docs/4.2.x/reference/html/cors.html&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/CORS&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP/CORS&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 01 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2020/10/01/CORS-with-Spring.html</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2020/10/01/CORS-with-Spring.html</guid>
        
        <category>CORS</category>
        
        <category>MVC</category>
        
        <category>Security</category>
        
        <category>Spring</category>
        
        
        <category>Spring</category>
        
      </item>
    
      <item>
        <title>[Operating System - Chapter 2] 운영체제 구조</title>
        <description>&lt;p&gt;이 포스팅은 공룡책으로 알려진 Operating System Concepts의 2장인 Operating System Structures를 공부하면서 정리한 포스팅이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-운영체제-구조-operating-system-structures&quot;&gt;2. 운영체제 구조 (Operating System Structures)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;운영체제는 그 속에서 프로그램이 실행되는 환경을 제공해 준다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;운영체제를 살펴보기 위한 몇가지 &lt;strong&gt;유리한 관점&lt;/strong&gt;에 대해서 소개하겠다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;운영체제가 제공하는 &lt;strong&gt;서비스에 초점&lt;/strong&gt;을 맞추는 것이다.&lt;/li&gt;
  &lt;li&gt;운영체제가 사용자와 &lt;strong&gt;프로그래머에게 제공하는 인터페이스에 초점&lt;/strong&gt;을 맞추는 것이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시스템의 구성요소와 그들의 상호 연결에 초점&lt;/strong&gt;을 맞추는 것이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 포스팅에서는 운영체제가 제공하는 서비스는 무엇이며, 이 서비스는 어떤 방식으로 제공되는지, 이 서비스들이 어떻게 디버깅 되며, 이러한 시스템을 설계하기 위해서는 어떤 다양한 방법들이 사용되는지 고려한다. 마지막으로 운영체제가 어떻게 만들어지고 컴퓨터가 운영체제를 구동시키는 방법에 관해 설명한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;21-운영체제-서비스-operating-system-services&quot;&gt;2.1 운영체제 서비스 (Operating System Services)&lt;/h3&gt;

&lt;p&gt;운영체제는 프로그램 &lt;strong&gt;실행 환경&lt;/strong&gt;을 제공한다. 운영체제는 프로그램과 그 프로그램의 사용자에게 &lt;strong&gt;특정 서비스&lt;/strong&gt;를 제공한다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 다양한 운영체제 서비스에 대한 한 가지 관점(계층적 관점)과 그들의 상호 관계를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-1.png&quot; style=&quot;width:90%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;운영체제가 제공하는 서비스에 대해서 소개하도록 하겠다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사용자 인터페이스(user interface)&lt;/strong&gt; : 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다. 이 인터페이스는 여러 형태로 제공될 수 있으며 대표적으로 &lt;strong&gt;Graphic User Interface(GUI), TouchScreen Interface, Command Line Interface&lt;/strong&gt;등이 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로그램 수행(program execution)&lt;/strong&gt; : 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 연산(I/O operation)&lt;/strong&gt; : 수행 중인 프로그램은 입출력을 요구할 수 있다. 이러한 입출력에는 파일 혹은, 입출력 장치가 연관될 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;파일 시스템 조작(file system manipulation)&lt;/strong&gt; : 프로그램은 파일을 읽고 쓸 필요가 있고, 이름에 의해 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을 수 있어야 하고 파일의 정보를 열거할 수 있어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;통신(communication)&lt;/strong&gt; : 프로세스 사이에 정보 교환(IPC)을 지원해 준다. (Shared Memory, Message-Passing)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;오류 탐지(error detection)&lt;/strong&gt; : 운영체제는 모든 가능한 오류를 항상 의식하고 탐지해야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자원 할당(resource allocation)&lt;/strong&gt; : 다수의 프로세스나 다수의 작업이 동시에 실행될때, 그들 각각에 자원을 할당해 주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기록 작성(logging)&lt;/strong&gt; : 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지에 대해서 기록 작성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;보호(protection)와 보안(security)&lt;/strong&gt; : 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장, 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;22-사용자와-운영체제-인터페이스-user-and-operating-system-interface&quot;&gt;2.2 사용자와 운영체제 인터페이스 (User and Operating System Interface)&lt;/h3&gt;

&lt;h4 id=&quot;221-명령-인터프리터-command-interpreter&quot;&gt;2.2.1 명령 인터프리터 (Command Interpreter)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Linux, UNIX 및 Windows를 포함한 운영체제 대부분은 프로세스가 시작되거나 사용자가 (대화형 시스템상에서) 처음 로그온 할 때 명령 인터프리터를 특수한 프로그램으로 취급한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 이 해석기는 &lt;strong&gt;&lt;u&gt;셸(shell)&lt;/u&gt;&lt;/strong&gt;이라고 불린다.&lt;/p&gt;

&lt;p&gt;명령 인터프리터의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다. 이 명령어들은 &lt;strong&gt;두 가지 일반적인 방식&lt;/strong&gt;으로 구현될 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시스템 프로그램에 의해 대부분의 명령을 구현하는 경우&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;인터프리터는 해당 명령에 대해서 전혀 알지 못하며, 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다.
        &lt;blockquote&gt;
          &lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;

          &lt;p&gt;&lt;strong&gt;rm file.txt라는 명령어를 예로 들어보면 “rm이라 불리는 파일을 찾아서, 그 파일을 메모리에 적재하고, rm 이라 불리는 파일을 매개변수 file.txt로 수행한다”&lt;/strong&gt; 라는 의미이다. rm명령과 관련된 로직은 rm이라는 파일 내의 코드로 완전하게 정의되기 때문에 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있다. &lt;strong&gt;해당 방법을 사용할 시 명령 인터프리터 프로그램은 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없다.&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;222-그래픽-기반-사용자-인터페이스-graphical-user-interface&quot;&gt;2.2.2 그래픽 기반 사용자 인터페이스 (Graphical User Interface)&lt;/h4&gt;

&lt;p&gt;그래픽 기반 사용자 인터페이스란 CLI를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 &lt;strong&gt;데스크톱이라고 특정지어지는 마우스를 기반으로 하는 윈도 메뉴 시스템을 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;223-터치스크린-인터페이스touch-screen-interface&quot;&gt;2.2.3 터치스크린 인터페이스(Touch Screen Interface)&lt;/h4&gt;

&lt;p&gt;대부분의 모바일 시스템에는 명령 라인 인터페이스나 마우스 및 키보드 시스템이 실용적이지 않기 떄문에 &lt;strong&gt;스마트폰 및 휴대용 태블릿 컴퓨터는 일반적으로 터치스크린 인터페이스(TouchScreen Interface)를 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ex) iPad와 iPhone에서의 Springboard 터치스크린 인터페이스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;224-인터페이스-선택-choice-of-interface&quot;&gt;2.2.4 인터페이스 선택 (Choice of Interface)&lt;/h4&gt;

&lt;p&gt;컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워 유저들은 &lt;strong&gt;명령어 라인 인터페이스(CLI)&lt;/strong&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;몇몇 시스템에서는 GUI를 통해서는 시스템 기능의 일부만을 이용할 수 있고 자주 쓰이지 않는 나머지 기능은 CLI를 사용할 수 있는 사용자만이 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;셸 스크립트(shell scripts)는 UNIX와 Linux와 같이 명령어-라인 인터페이스에 기반을 둔 시스템에서는 매우 흔한 형태이다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;셸 스크립트(shell script)는 셸이나 Command Line 인터프리터에서 돌아가도록 작성되었거나 한 운영 체제를 위해 쓰인 스크립트이다.&lt;/strong&gt; 단순한 도메인 고유 언어로 여기기도 한다. 셸 스크립트가 수행하는 일반 기능으로는 &lt;u&gt;파일 이용, 프로그램 실행, 문자열 출력 등&lt;/u&gt;이 있다.&lt;/p&gt;

  &lt;p&gt;셸 스크립트라는 말은 유닉스 셸을 위해 쓰인 스크립트를 말하는 반면, COMMAND.COM(도스)과 cmd.exe (윈도) Command Line 스크립트는 보통 Batch File이라고 불리지만 이 글에는 두 개의 속성 모두를 논한다.&lt;/p&gt;

  &lt;p&gt;.sh라는 파일 확장자를 가진 파일이 특정 종류의 셸 스크립트를 가리키는 것이 보통이지만, 대부분의 셸 스크립트는 파일 확장자를 지니지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;23-시스템-콜-system-calls&quot;&gt;2.3 시스템 콜 (System Calls)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;시스템 콜은 운영체제에 의해 사용 가능하게 된 서비스에 대한 &lt;u&gt;인터페이스를 제공&lt;/u&gt;한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;특정 저수준 작업(ex. 하드웨어를 직접 접근해야 하는 작업)은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C와 C++ 언어로 작성된 함수 형태로 제공된다.&lt;/p&gt;

&lt;h4 id=&quot;232-응용-프로그래밍-인터페이스-application-programming-interface-api&quot;&gt;2.3.2 응용 프로그래밍 인터페이스 (Application Programming Interface, API)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;대부분의 Application 개발자들은 API에 따라 프로그램을 설계한다.&lt;/strong&gt; API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 Application 프로그래머가 사용 가능한 함수의 집합을 명시한다.&lt;/p&gt;

&lt;p&gt;프로그래머가 사용 가능한 가장 흔한 3가지의 API는 &lt;u&gt;Windows API, POSIX API, Java API&lt;/u&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최종적으로 API를 구성하는 함수들은 통상 Application Programmer를 대신하여 실제 시스템 콜을 호출한다.&lt;/strong&gt; (ex. Windows 함수 CreateProcess() API는 실제로 Windows 커널의 NTCreateProcess() 시스템 콜을 부른다.)&lt;/p&gt;

&lt;p&gt;시스템 콜을 처리하는데 있어 중요한 또 다른 요소는 &lt;strong&gt;실행시간 환경(RTE, 런타임 환경)&lt;/strong&gt;이다. RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 &lt;strong&gt;시스템 콜 인터페이스&lt;/strong&gt;를 제공한다. 이 시스템 콜 인터페이스는 API 함수의 호출을 intercept해서 필요한 운영체제 시스템 콜을 부른다.&lt;/p&gt;

&lt;p&gt;통상 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다. 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 돌려준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;운영체제 인터페이스에 대한 대부분의 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 RTE에 의해 관리된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림에서는 API가 open() 시스템 콜을 불렀을 떄 운영체제가 어떻게 처리하는지 설명하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-2.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시스템 콜 호출을 위해서는 운영체제에 매개변수를 전달해야만 한다. 이를 위해서 보통 운영체제는 3개의 일반적인 방법을 사용한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;매개변수를 레지스터 내에 전달하는 방법&lt;/li&gt;
  &lt;li&gt;매개변수를 메모리 내의 블록이나 테이블에 저장하고, 블록의 주소가 레지스터 내에 매개변수로 전달되는 방법&lt;/li&gt;
  &lt;li&gt;매개변수를 메모리 내의 스택에 push &amp;amp;&amp;amp; pop 하는 방법.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;233-시스템-콜의-유형-types-of-system-calls&quot;&gt;2.3.3 시스템 콜의 유형 (Types of System Calls)&lt;/h4&gt;

&lt;p&gt;시스템 콜은 다섯 가지의 중요한 범주, 즉 &lt;strong&gt;프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수, 통신, 보호&lt;/strong&gt;등으로 묶을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스 제어 (Prcess Control)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스에 실행 중인 프로그램은 수행을 정상적으로(end()) 또는 비정상적으로(abort()) 멈출 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재(load())하고 실행(execute()) 할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;운영체제는 프로세스의 속성들을 결정하고 재설정(reset)할 수 있는 능력이 있어야 한다.&lt;/li&gt;
  &lt;li&gt;특정 이벤트가 일어날 때까지 프로세스를 기다려야 할 수도 있다.&lt;/li&gt;
  &lt;li&gt;프로세스 간에 공유되는 일관성을 보장하기 위해서 운영체제는 종종 프로세스가 공유 데이터를 잠글(lock) 수 있는 시스템 콜을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;파일 관리 (File Management)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파일을 생성(create())하고 삭제(delete())할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;파일을 열고(open())고 읽고(read()), 쓰고(write()), 위치 변경(reposition()), 되감기(rewind()), 파일 닫기(close())를 할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;파일에 대한 속성을 얻을(get_file_attribute()) 수 있어야 하고 파일 속성을 설정(set_file_attribute())할 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;장치 관리 (Device Management)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 우선 그 장치를 요청(request())할 수 있어야 하고 그 장치의 사용이 끝나면 우리는 방출(release())할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;장치를 읽고(read()), 쓰고(write()), 위치 변경(reposition())할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;장치의 속성을 얻을 수 있어야 하고, 설정할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;논리적으로 장치를 붙이고 제거할 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정보 유지 관리 (Information Maintenance)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;현재 시간(time())과 날짜 정보를(date()) 제공할 수 있어야 하고 설정할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;프로그램이 특정 위치, 혹은 위치의 집합에서 수행한 시간의 양을 나타내는 시간 프로파일(time profile)을 제공한다.&lt;/li&gt;
  &lt;li&gt;프로세스, 파일, 장치에 대한 속성을 얻을 수 있고 설정할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;시스템 데이터를 얻을 수 있어야 하고, 설정할 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;통신 (Communications)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메시지 전달을 위해 communication connection을 생성할 수 있어야하고 삭제할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;메시지를 받을 수 있어야 하고 보낼 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;상태 정보를 전송할 수 잇어야 한다.&lt;/li&gt;
  &lt;li&gt;원격 장치를 붙이고 땔 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;보호 (Protection)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자원 접근 허가를 얻을 수 있어야 하고 설정할 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;24-시스템-서비스-system-services&quot;&gt;2.4 시스템 서비스 (System Services)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;시스템 서비스는, 시스템 유틸리티(system utility)로도 알려진, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.&lt;/strong&gt; 이 중 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며, 반면에 나머지는 훨씬 더 복잡하다.&lt;/p&gt;

&lt;p&gt;다음에서는 시스템 서비스를 중요한 몇가지 범주로 나누었다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;파일 관리 :&lt;/strong&gt; 파일과 디렉터리를 생성, 삭제, 복사, rename, 인쇄, 열거할 수 있는 서비스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태 정보 :&lt;/strong&gt; 시스템의 날짜, 시간, 사용 가능한 메모리와 디스크 공간의 양, 사용자 수, 로깅 및 디버깅 정보 등의 상태 정보를 제공하는 서비스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일 변경 :&lt;/strong&gt; 파일의 내용을 생성하고 변경하기 위한 서비스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어 지원:&lt;/strong&gt; 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 인터프리터가 운영체제와 함께 제공되는 서비스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그램 적재와 수행 :&lt;/strong&gt; 프로그램이 어셈블되거나 컴파일된 후, 그것이 수행하기 앞서 메모리에 적재시키는 서비스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;통신 :&lt;/strong&gt; 프로세스, 사용자, 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공하는 서비스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;백그라운드 서비스 :&lt;/strong&gt; 네트워크 디먼, 프로세스 스케줄러 등과 같은 백그라운드 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;사용자 대부분이 보는 운영체제의 관점은 실제의 시스템 콜에 의해서보다는 시스템 프로그램과 Application에 의해 정의된다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;25-링커와-로더linkers-and-loaders&quot;&gt;2.5 링커와 로더(Linkers and Loaders)&lt;/h3&gt;

&lt;p&gt;일반적으로 프로그램은 디스크에 이진 실행 파일(ex. a.out 또는 prog.exe)로 존재한다. &lt;strong&gt;CPU에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 한다.&lt;/strong&gt; 이 절에서는 프로그램을 컴파일하고 메모리에 배치하여 사용 가능한 CPU 코어에서 실행할 수 있게 되기까지의 이러한 절차를 단계별로 설명한다.&lt;/p&gt;

&lt;p&gt;이 절차를 설명한 그림은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-4.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일 된다. 이러한 형식을 &lt;strong&gt;재배치 가능 오브젝트 파일&lt;/strong&gt;이라고 한다.&lt;/li&gt;
  &lt;li&gt;다음으로 &lt;strong&gt;링커&lt;/strong&gt;는 이러한 재배치 가능 오브젝트 파일을 하나의 &lt;strong&gt;이진 실행 파일&lt;/strong&gt;로 결합한다. (다른 오브젝트 파일 또는 라이브러리도 포함될 수 있다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;로더&lt;/strong&gt;는 이진 실행 파일을 &lt;strong&gt;메모리에 적재하는데 사용&lt;/strong&gt;되며, &lt;strong&gt;실행 파일이 CPU 코어에서 실행할 수 있는 상태가 된다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;링크 및 로드와 관련된 활동은 재배치로, 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UNIX 시스템(ex. ./main)의 명령어 라인에 프로그램 이름을 입력하면 셸은 먼저 fork()시스템 콜을 사용하여 프로그램을 실행하기 위한 &lt;strong&gt;새 프로세스를 생성&lt;/strong&gt;한다. 그런 다음 셸은 exec() 시스템 콜로 &lt;strong&gt;로더를 호출&lt;/strong&gt;하고 exec()에 실행 파일 이름을 전달한다. 그런 다음 로더는 새로 생성된 프로세스의 주소 공간을 사용하여 &lt;strong&gt;지정된 프로그램을 메모리에 적재&lt;/strong&gt;한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;실제 시스템 대부분에서는 프로그램이 적재될 때 라이브러리를 동적으로 링크할 수 있는 기능을 지원한다.&lt;/strong&gt; (ex. The dynamic linked library(DLL) of Windows) 링커는 프로그램이 적재될 때 동적으로 링크되고 적재될 수 있도록 재배치 정보를 삽입하기 때문에 &lt;u&gt;여러 프로세스가 동적으로 링크된 라이브러리를 공유할 수 있어 메모리 사용이 크게 절약&lt;/u&gt;될 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;26-응용-프로그램이-운영체제마다-다른-이유-why-applications-are-operating-system-specific&quot;&gt;2.6 응용 프로그램이 운영체제마다 다른 이유 (Why Applications Are Operating-System Specific)&lt;/h3&gt;

&lt;p&gt;기본적으로 한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Application이 여러 운영체제에서 실행될 수 있게 만드는 방법 3가지&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;운영체제마다 인터프리터가 제공되는 인터프리터 언어로 Application을 만드는 방법 (ex. Python, Ruby)&lt;/li&gt;
  &lt;li&gt;실행 중인 Application을 포함하고 있는 가상 머신을 가진 언어로 Application을 만드는 방법 (ex. JAVA)&lt;/li&gt;
  &lt;li&gt;컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API를 사용하는 방법 (ex. POSIX API)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;27-운영체제-설계-및-구현-operating-system-design-and-implementation&quot;&gt;2.7 운영체제 설계 및 구현 (Operating SYstem Design and Implementation)&lt;/h3&gt;

&lt;h4 id=&quot;271-설계-목표-design-goals&quot;&gt;2.7.1 설계 목표 (Design Goals)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;시스템을 설계하는 데에 첫째 문제점은 시스템의 목표와 명세를 정의하는 일이다.&lt;/strong&gt; 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 유형의 선택에 의해 영향을 받을 것이다.&lt;/p&gt;

&lt;p&gt;최상위 설계 수준을 넘어서면 요구 조건들을 &lt;strong&gt;사용자 목적&lt;/strong&gt;과 &lt;strong&gt;시스템 목적&lt;/strong&gt;의 두 그룹으로 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;운영체제의 명세와 설계는 매우 창조적인 일이며, 어떤 책에서도 이런 문제점을 해결하는 방법을 알려줄 수는 없지만, 특별히 운영체제에 적용 가능한 일반적인 원칙들은 존재한다.&lt;/p&gt;

&lt;h4 id=&quot;272-기법과-정책-mechanisms-and-policies&quot;&gt;2.7.2 기법과 정책 (Mechanisms and Policies)&lt;/h4&gt;

&lt;p&gt;한 가지 중요한 원칙은 &lt;strong&gt;기법(Mechanism)&lt;/strong&gt;으로부터 &lt;strong&gt;정책(Policy)&lt;/strong&gt;를 분리하는 것이다. 기법은 어떤 일을 어떻게 할 것인가를 결정하는 것이고, 정책은 무엇을 할 것인가를 결정하는 것이다. (ex. 타이머, 마이크로 커널 기반 운영체제)&lt;/p&gt;

&lt;h4 id=&quot;273-구현-implementation&quot;&gt;2.7.3 구현 (Implementation)&lt;/h4&gt;

&lt;p&gt;초기 운영체제는 어셈블리 언어로 작성되었다. 이제 대부분은 C 또는 C++와 같은 고급 언어로 작성되며, 극히 일부의 시스템이 어셈블리 언어로 작성된다.&lt;/p&gt;

&lt;p&gt;운영체제의 주요 성능 향상은 운영체제를 구현하는 고급 언어의 유/무 보다는 좋은 자료구조와 알고리즘의 결과일 가능성이 크다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;28-운영체제-구조-operating-system-structures&quot;&gt;2.8 운영체제 구조 (Operating System Structures)&lt;/h3&gt;

&lt;p&gt;이 절에서는 운영체제의 공통적인 구성요소들이 어떤 방법으로 상호 연결되고 하나의 커널로 결합되는지에 대해서 알아보도록 하겠다.&lt;/p&gt;

&lt;h4 id=&quot;281-모놀리식-구조-monolithic-structure&quot;&gt;2.8.1 모놀리식 구조 (Monolithic Structure)&lt;/h4&gt;

&lt;p&gt;운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것이다. &lt;strong&gt;즉, 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것이다. 즉, 이 방법을 모놀리식 구조라고 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;제한적인 구조를 가진 운영체제의 예는 최초의 UNIX 운영체제로 커널과 시스템 프로그램의 두 부분으로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-5.png&quot; style=&quot;width:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linux 운영체제는 UNIX에 기반을 두고 있으며 위의 그림과 유사하게 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모놀리식 커널의 명백한 단순성에도 불구하고 이 구조는 구현 및 확장하기 어렵다. 그러나 모놀리식 커널은 성능 면에서 뚜렷한 이점이 있다. 시스템 콜 인터페이스에는 오버헤드가 거의 없고 커널 안에서의 통신 속도가 빠르다.&lt;/strong&gt; 따라서 모놀리식 커널의 단점에도 불구하고, 속도와 효율성은 이 구조의 증거를 여전히 UNIX, Linux 및 Windows 운영체제에서 발견할 수 있는 이유이다.&lt;/p&gt;

&lt;h4 id=&quot;282-계층적-접근-layered-approach&quot;&gt;2.8.2 계층적 접근 (Layered Approach)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;계층적 접근 방법은 운영체제가 여러 개의 층으로 나뉘어진다. 최하위 층은 하드웨어이고 최상위 층은 사용자 인터페이스이다.&lt;/strong&gt; 이 계층 구조는 아래의 그림에 나와 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-6.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체의 구현이다. 전형적인 운영체제 층은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;계층화된 시스템은 컴퓨터 네트워크(TCP/IP) 및 웹 응용 프로그램에서 성공적으로 사용됐다.&lt;/p&gt;

&lt;h4 id=&quot;283-마이크로커널-microkernels&quot;&gt;2.8.3 마이크로커널 (MicroKernels)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;마이크로커널 방법은 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다.&lt;/strong&gt; (ex. Mach 운영체제) 결과는 더 작은 커널이다.&lt;/p&gt;

&lt;p&gt;마이크로커널의 주 기능은 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공하는 것이다. 통신은 메시지 전달에 의해 제공된다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 전형적인 마이크로커널의 구조를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-7.png&quot; style=&quot;width:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;마이크로커널 접근법의 한 가지 장점은 운영체제의 확장이 쉽다는 것이다.&lt;/strong&gt; 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널을 변경할 필요가 없다. 커널이 변경되어야만 할 때는, &lt;u&gt;마이크로커널이 작은 커널이기 떄문에 변경할 대상이 비교적 적은 경향이 있다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;마이크로커널은 서비스 대부분이 커널이 아니라 &lt;strong&gt;사용자 프로세스로 수행&lt;/strong&gt;되기 떄문에 또한 더욱 높은 보안성과 신뢰성을 제공한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;마이크로 커널의 운영체제의 가장 잘 알려진 실례는 macOS 및 iOS 운영체제의 커널 구성요소인 &lt;strong&gt;Darwin&lt;/strong&gt;이다. 실제로 Darwin은 두 개의 커널로 구성되며 그 중 하나는 Mach 마이크로커널이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;마이크로커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나쁘다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;284-모듈-modules&quot;&gt;2.8.4 모듈 (Modules)&lt;/h4&gt;

&lt;p&gt;운영체제를 설계하는 데 이용되는 최근 기술 중 최선책은 아마도 &lt;strong&gt;적재가능 커널 모듈(loadable kernel modules, LKM)&lt;/strong&gt; 기법의 사용일 것이다. &lt;strong&gt;LKM에서는 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;설계의 주안점은 &lt;u&gt;커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현&lt;/u&gt;하는 것이다.&lt;/p&gt;

&lt;p&gt;전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았지만 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하다. 중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과도 유사하다. 그러나 &lt;strong&gt;통신하기 위하여 메시지 전달을 호출할 필요가 없기 때문에 더 효율적이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;285-하이브리드-시스템-hybrid-systems&quot;&gt;2.8.5 하이브리드 시스템 (Hybrid Systems)&lt;/h4&gt;

&lt;p&gt;사실 엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않는다. 대신 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;macOS와 iOS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Apple의 macOS 운영체제는 주로 데스크톱 및 랩톱 컴퓨터 시스템에서 실행되도록 설계되었으며 iOS는 iPhone 스마트폰 및 iPad 태블릿 컴퓨터용으로 설계된 모바일 운영체제이다.&lt;/li&gt;
  &lt;li&gt;macOS와 iOS는 Darwin이라고 불리는 하이브리드 커널 환경을 사용한다.
    &lt;ul&gt;
      &lt;li&gt;Darwin은 주로 Mach 마이크로커널과 BSD UNIX 커널로 구성된 계층화된 시스템이다.&lt;/li&gt;
      &lt;li&gt;Darwin 구조 그림은 아래에 명시되어 있다.&lt;/li&gt;
      &lt;li&gt;Mach는 메모리 관리, CPU 스케줄링 및 메시지 전달 및 원격 프로시저 호출과 같은 프로세스간 통신 기능을 포함한 기본 운영체제 서비스를 제공한다. (커널 추상화를 통해 사용 가능)&lt;/li&gt;
      &lt;li&gt;마이크로커널의 성능 문제를 해결하기 위해 Darwin은 Mach, BSD, I/O 키트 및 모든 커널 확장을 단일 주소 공간으로 결합한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-8.png&quot; style=&quot;width:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Android 운영체제는 Open Handset Alliance가 설계하였으며 Android 스마트폰과 태블릿을 위해 개발되었다.&lt;/li&gt;
  &lt;li&gt;Android 장치의 소프트웨어 설계자는 Java 언어로 응용 프로그램을 개발하지만 일반적으로 표준 Java API를 사용하지 않고 별도의 Android API를 사용한다.&lt;/li&gt;
  &lt;li&gt;Java 응용 프로그램은 Android RunTime(ART)에서 실행할 수 있는 형식으로 컴파일된다.
    &lt;ul&gt;
      &lt;li&gt;ART는 Android용으로 설계되어 메모리와 CPU 처리 능력이 제한적인 모바일 장치에 최적화된 가상 머신이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Android 개발자는 개발자가 가상 머신을 우회할 수 있게 하는 Java 네이티브 인터페이스를 사용하여 Java 프로그램을 작성하여 특정 하드웨어 기능에 액세스 할 수 있는 프로그램을 작성할 수 있다.&lt;/li&gt;
  &lt;li&gt;하드웨어 추상화 계층 또는 HAL을 통해 물리적 하드웨어를 추상화한다.&lt;/li&gt;
  &lt;li&gt;Android 소프트웨어 스택의 맨 아래에는 Linux 커널이 있다.&lt;/li&gt;
  &lt;li&gt;Android 구조 그림은 아래에 명시되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-science/operating-system-structures-9.png&quot; style=&quot;width:50%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;29-운영체제-빌딩과-부팅-building-and-booting-an-operating-system&quot;&gt;2.9 운영체제 빌딩과 부팅 (Building and Booting an Operating System)&lt;/h3&gt;

&lt;h4 id=&quot;291-운영체제-생성-operating-system-generation&quot;&gt;2.9.1 운영체제 생성 (Operating System Generation)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;운영체제를 처음부터 생성(또는 빌딩)하는 경우 절차&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;운영체제 소스 코드를 작성한다(또는 이전에 작성된 소스 코드를 확보한다.)&lt;/li&gt;
  &lt;li&gt;실행될 시스템을 위해 운영체제를 구성한다.&lt;/li&gt;
  &lt;li&gt;운영체제를 컴파일 한다.&lt;/li&gt;
  &lt;li&gt;운영체제를 설치한다.&lt;/li&gt;
  &lt;li&gt;컴퓨터와 새 운영체제를 부팅한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시스템을 구성하려면 어떤 기능이 포함되는지 명시해야 하며 이는 운영체제에 따라 다르다. 일반적으로 시스템 구성 방법을 설명하는 매개변수는 특정 유형의 구성 파일에 저장되며 이 파일을 만든 후에는 여러가지 방법으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;상세한 조정을 할 수 없는 수준에서는 시스템 설명을 통하여 기존 라이브러리에서 사전 컴파일된 오브젝트 모듈을 선택할 수 있다. &lt;strong&gt;이 모듈들이 서로 링크되어 새 운영체제가 생성된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;다른 경우에는 완전히 모듈 방식으로 시스템을 구성할 수 있다. 여기서 선택은 컴파일 또는 링크 시간이 아닌 &lt;strong&gt;실행 시간(Runtime)&lt;/strong&gt;에 일어난다. 시스템 생성은 단순히 시스템 구성을 설명하는 매개변수의 설정만 하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;292-시스템-부트-system-boot&quot;&gt;2.9.2 시스템 부트 (System Boot)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;커널을 적재하여 컴퓨터를 시작하는 과정을 시스템 부팅(Booting)이라고 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;대부분 시스템의 부팅 과정&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;부트스트랩 프로그램(Bootstrap Program)&lt;/strong&gt; 또는 &lt;strong&gt;부트 로더(Boot Loader)&lt;/strong&gt;라고 불리는 작은 코드가 커널의 위치를 찾는다.&lt;/li&gt;
  &lt;li&gt;커널이 메모리에 적재되고 시작된다.&lt;/li&gt;
  &lt;li&gt;커널은 하드웨어를 초기화 한다.&lt;/li&gt;
  &lt;li&gt;루트 파일 시스템이 마운트 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;많은 최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 UEFI(Unified Extensible Firmware Interface)로 대체하였다.
&lt;u&gt;UEFI의 큰 장점은 UEFI가 하나의 완전한 부팅 관리자이므로 다단계 BIOS 부팅 과정보다 빠르다는 것이다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부트스트랩 프로그램&lt;/strong&gt;은 커널 프로그램이 포함된 파일을 메모리에 적재하는 것외에도 진단을 실시하여 메모리와 CPU를 점검하고 장치 검색과 같은 시스템 상태를 확인한다. 진단을 통과하면 프로그램은 부팅 과정을 계속 진행할 수 있다. 부트스트랩은 CPU 레지스터에서 장치 컨트롤러 및 메인 메모리의 내용에 이르기까지 시스템의 모든 측면을 초기화 할 수 있다. 조만간 운영체제를 시작하고 루트 파일 시스템을 마운트 한다. 바로 이 시점에서 &lt;strong&gt;시스템이 실행 중&lt;/strong&gt;이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GRUB&lt;/strong&gt;는 Linux 및 UNIX 시스템을 위한 &lt;strong&gt;공개 소스 부트스트랩 프로그램&lt;/strong&gt;이다. 시스템의 부트 매개변수는 GRUB 구성 파일에 설정되며 GRUB의 실행 시작 시점에 적재된다.&lt;/p&gt;

&lt;p&gt;부팅 과정에서 &lt;strong&gt;부트 로더&lt;/strong&gt;는 일반적으로 &lt;strong&gt;initramfs로 알려진 임시 RAM 파일 시스템을 생성&lt;/strong&gt;한다. 이 파일 시스템에는 실제 루트 파일 시스템을 지원하기 위해 설치해야하는 드라이버와 커널 모듈이 저장되어 있다. &lt;strong&gt;커널이 시작되고 필요한 드라이버가 설치되면 커널은 루트 파일 시스템을 임시 RAM 위치(initramfs)에서 적절한 루트 파일 시스템 위치로 전환&lt;/strong&gt;한다. 마지막으로 Linux는 시스템의 초기 프로세스인 &lt;strong&gt;systemd&lt;/strong&gt; 프로세스를 생성한 다음 다른 서비스를 시작한다. (UNIX는 init 프로세스)&lt;/p&gt;

&lt;p&gt;Windows, Linux, macOS, iOS 및 Android를 비롯한 대부분의 운영체제의 &lt;strong&gt;부트 로더&lt;/strong&gt;는 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등의 작업을 할 수 있는 &lt;strong&gt;복구 모드&lt;/strong&gt; 또는 &lt;strong&gt;단일 사용자 모드&lt;/strong&gt;로 부팅할 수 있는 기능을 제공한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;210-운영체제-디버깅-operating-system-debugging&quot;&gt;2.10 운영체제 디버깅 (Operating System Debugging)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;디버깅(Debugging)은 하드웨어와 소프트웨어에서의 시스템의 오류를 발견하고 수정하는 행위이다.&lt;/strong&gt; 이 절에서는 커널과 프로세스 오류 및 성능 문제의 디버깅에 관해 탐구한다. (병목 현상을 제거하여 성능을 향상시키려는 성능 조정(performance turning)도 디버깅이다.)&lt;/p&gt;

&lt;h4 id=&quot;2101-장애-분석-failure-analysis&quot;&gt;2.10.1 장애 분석 (Failure Analysis)&lt;/h4&gt;

&lt;p&gt;만일 프로세스가 실패한다면, 운영체제 대부분은 시스템 관리자 또는 문제를 발생시킨 사용자에게 문제가 발생했다는 것을 경고하기 위해 오류 정보를 &lt;strong&gt;로그 파일&lt;/strong&gt;에 기록한다. 운영체제는 또한 프로세스가 사용하던 메모리를 캡처한 &lt;strong&gt;코어 덤프(core dump)&lt;/strong&gt;를 취하고 차후 분석을 위해 파일로 저장한다.&lt;/p&gt;

&lt;p&gt;커널 장애는 &lt;strong&gt;크래시(crash)&lt;/strong&gt;라고 불린다. 프로세스 장애와 마찬가지로 커널 장애는 오류 정보가 로그 파일에 저장되고 메모리의 상태가 &lt;strong&gt;크래시 덤프(crash dump)&lt;/strong&gt;에 저장된다.&lt;/p&gt;

&lt;h4 id=&quot;2102-성능-관찰-및-조정-performance-monitoring-and-turning&quot;&gt;2.10.2 성능 관찰 및 조정 (Performance Monitoring and Turning)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;성능 관찰 및 조정(Performance Monitoring and Turning)을 위해 시스템은 동작을 측정하고 표시할 수 있는 방법을 가지고 있어야 한다.&lt;/strong&gt; 도구는 &lt;strong&gt;프로세스별&lt;/strong&gt; 또는 &lt;strong&gt;시스템 전체&lt;/strong&gt;의 관찰을 제공하느냐로 특징이 묘사될 수 있다. 이러한 관찰을 위해 도구는 &lt;strong&gt;카운터&lt;/strong&gt; 또는 &lt;strong&gt;추적&lt;/strong&gt;의 두 가지 접근 방식 중 하나를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;카운터 (Counters)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제는 &lt;strong&gt;일련의 카운터를 통해&lt;/strong&gt; 호출된 시스템 콜 횟수 또는 네트워크 장치 또는 디스크에 수행된 작업 수와 같은 &lt;strong&gt;시스템 활동을 추적&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Linux 도구 예시&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;프로세스별&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;ps : 하나의 프로세스 또는 선택된 프로세스에 대한 정보를 보고&lt;/li&gt;
    &lt;li&gt;top : 현재 프로세스에 대한 실시간 통계를 보고한다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;시스템 전체&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;vmstat : 메모리 사용량 통계를 보고한다.&lt;/li&gt;
    &lt;li&gt;netstat : 네트워크 인터페이스에 대한 통계를 보고한다.&lt;/li&gt;
    &lt;li&gt;iostat - 디스크의 I/O 사용량을 보고한다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Linux 시스템의 카운터 기반 도구 대부분은 /proc 파일 시스템에서 통계를 읽는다. /proc은 커널 메모리에만 존재하는 “의사” 파일 시스템이며, 주로 다양한 프로세스별
통계와 커널 통계를 질의하는데 사용된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;추적 (Tracing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;추적 도구(Tracing Tool)는 시스템 콜과 관련된 단계와 같은 특정 이벤트에 대한 데이터를 수집한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Linux 도구 예시&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;프로세스별&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;strace : 프로세스에 의해 호출된 시스템 콜을 추적한다.&lt;/li&gt;
    &lt;li&gt;gdb : 소스 레벨 디버거&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;시스템 전체&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;perf : 리눅스 성능 도구 모음&lt;/li&gt;
    &lt;li&gt;tcpdump : 네트워크 패킷을 수집한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;2104-bcc&quot;&gt;2.10.4 BCC&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;BCC(BPF Compiler Collection)는 Linux 시스템을 위한 추적 기능을 제공하는 풍부한 툴킷이다.&lt;/strong&gt; BCC는 eBPF 도구에 대한 프론트-엔드 인터페이스이다. BPF 기술은 컴퓨터 네트워크에서 트래픽을 필터링하기 위해 1990년대 초에 개발되었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;BPF(Berkeley Packet Filter)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;버클리 패킷 필터는 네트워크 트래픽을 분석해야하는 프로그램을 위해 특정 컴퓨터 운영 체제에서 사용되는 기술입니다. 데이터 링크 계층에 대한 원시 인터페이스를 제공하여 
원시 링크 계층 패킷을 보내고 받을 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;eBPF 명령어는 특정 이벤트를 캡처하거나 시스템 성능을 관찰하는데 사용될 수 있다. 하지만 eBPF 명령어는 Linux 커널에 삽입하기 전에 &lt;strong&gt;검증기&lt;/strong&gt;를 통과해야한다.&lt;/p&gt;

&lt;p&gt;BCC는 eBPF를 사용하는 도구를 더 쉽게 작성할 수 있도록 개발되었으며 Python 언어로 작성된 &lt;strong&gt;프론트-엔드 인터페이스를 제공&lt;/strong&gt;한다. BCC도구는 Python으로 작성되며 eBPF 계측 기능과 인터페이스 하는 C 코드를 내장한다. 이 계측 기능은 이어서 커널과 인터페이스 한다. &lt;strong&gt;BCC도구는 또한 C 프로그램을 eBPF 명령어로 컴파일하고, probe 또는 tracepoint를 사용하여 커널에 삽입한다.&lt;/strong&gt; Probe와 tracepoint는 Linux 커널에서 이벤트 추적을 허용하는 두가지 기술이다.&lt;/p&gt;

&lt;p&gt;BCC패키지는 실행 중인 Linux 커널에서 여러 활동 영역을 관찰하는 여러 기존 도구를 제공한다. 또한 BCC가 제공하는 많은 도구는 MySQL 데이터베이스, Java 및 Python 프로그램과 같은 특정 응용 프로그램에 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BCC를 특히 강력하게 만드는 것은 시스템에 해를 끼치지 않고 중요한 응용 프로그램을 실행하는 실제 프로덕션 시스템에서 해당 도구를 사용할 수 있다는 것이다.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/computer-science(cs)/2020/09/03/Operating-System-Structures.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer-science(cs)/2020/09/03/Operating-System-Structures.html</guid>
        
        <category>Operating-System</category>
        
        <category>OS</category>
        
        <category>CS</category>
        
        <category>Computer</category>
        
        
        <category>Computer-Science(CS)</category>
        
      </item>
    
  </channel>
</rss>