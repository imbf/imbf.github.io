---
layout: post
title: "[실무 면접 준비 - 2] 운영체제 (Operating System)"
date: 2021-02-28
author: Green Frog Developer
categories: Interview
tags: Operating-System OS Thread Process Async Sync Concurrent-Control Memory
---

---

## Process & Thread

----

### Core는 무엇인가요?

Core란 Processor의 한 종류인 **CPU의 기본 계산 단위를 의미합니다.**

### 프로세스와 스레드는 각각 무엇이고 어떠한 차이가 존재하나요?

**Process란 메모리에 올라와서 실행 중인 프로그램을 의미하구요, Thread란 프로세스 내에서 실행되는 실행 흐름의 단위를 의미합니다.** 프로세스와 스레드는 CPU를 여러 실행 흐름으로 나누어서 실행한다는 것은 동일하지만 이들간에 공유되는 자원에서 차이가 발생합니다.

**Process는 text, data, heap, stack 영역을 포함하는 구조의 메모리를 가지며 이들은 Process간에 공유되어지지 않습니다.  Thread는 프로세스 내에서 Stack만 할당받으며 Code, Data, Heap 영역을 같은 Process내의 Thread간에 공유합니다.** 

> ### Process와 Thread를 위한 참고 자료
>
> <img src="/assets/interview/naver-practical-interview-preparation2-1.png" style="width:100%">
>
> **메모리 컴포넌트**
>
> - **text :** 실행 코드가 저장되는 영역
> - **data :** 전역 변수 등을 기록하는 영역
> - **heap :** 프로그램 실행 중에 동적으로 할당되는 메모리 영역
> - **stack :** 함수를 호출할 때 임시 데이터 저장장소를 위한 영역 (ex. 함수 매개변수, 복귀 주소, 지역변수, …)



### 스택을 스레드마다 독립적으로 할당하는 이유가 있나요?

Stack은 함수의 Argument, Return Address & Value, Local Variable 등을 저장하기 위해 사용되는 메모리 공간입니다. **이들은 프로세스 내에서 독립적인 함수 호출을 위해서 필요한 데이터들이며 스레드별로 스택을 독립적으로 할당함을 통해 독립적인 실행 흐름을 수행할 수 있는 스레드를 만들 수 있다는 것을 의미합니다.** 프로세스를 여러 개의 실행 흐름인 스레드의 집합으로 만들고 싶다면 스레드마다 스택을 할당하는 것은 어쩌면 당연합니다.



### 멀티 프로세스와 멀티 스레드에 대해서 알려주세요.

**하나의 프로그램을 여러 프로세스로 동작시키는 것을 멀티 프로세스라고 하구요, 여러 스레드로 동작시키는 것을 멀티 스레드라고 합니다.**

 

### 멀티 프로세스와 멀티 스레드의 장단점에 대해서 알려주세요.

**멀티 프로세스의 장점**으로는 여러 프로세스 중 하나의 프로세스에 문제가 발생한다면 해당 프로세스에서만 문제를 해결하면 되기 때문에 멀티 스레드에서 비해서 상대적으로 안정적입니다.

**멀티 프로세스의 단점**으로는 프로세스간에 공유 되어지는 메모리가 없기 때문에 프로세스 간의 통신을 위해서 통신 기법이 필요합니다. 이 뿐만 아니라 Context Switching 이나 자식 프로세스 생성 시 많은 오버헤드가 발생하기 떄문에 여러 프로세스가 존재하는 경우 프로그램의 수행 시간이 전체적으로 시간이 느려질 수 있다.

**멀티 스레드의 장점**으로는 자식 프로세스를 생성하거나 Context Switching과 같은 오버헤드가 많이 발생하는 작업이 없어짐으로 시스템의 처리량이 증가합니다.

**멀티 스레드의 단점**으로는 프로세스의 Code, Heap, Data 메모리 영역을 공유하기 때문에 동기화 문제가 발생할 수 있다는 점입니다. 또한 하나의 스레드에서 문제가 발생하면 전체 프로세스가 영향을 받을 수 있어서 이러한 부분을 주의해야 합니다.

> ### Context Switching
>
> CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데 이 과정을 Context Switching 이라고 한다.



### 멀티 프로세스와 멀티 스레드는 각각 언제 사용하는것이 좋을까요?

**CPU가 처리해야하는 task의 특성이 크기가 크지 않으면서 개수가 많을 경우나 실시간성이 중요한 웹과 같은 경우 멀티 스레드를 사용하는 것이 좋구요, CPU가 처리해야하는 task의 특성이 크기가 크면서 개수가 적은 경우나 실시간성이 중요하지 않은 일괄 처리 같은 경우 멀티 프로세스를 사용하면 좋습니다.**



---

## Async & Sync

---

### blocking과 non-blocking에 대해서 설명해주시고 언제 사용하면 좋을지 알려주세요.

**하나의 실행 흐름에서 요청이 일어난 후 응답을 얻기까지 다른 실행 흐름들이 기다리는 전략을 Blocking이라고 하구요, 다른 실행 흐름이 요청에 대한 응답을 기다리지 않고 자유롭게 CPU나 메모리 등을 이용하는 전략을 Non-Blocking이라고 합니다.** 작업간에 공유 자원이 존재하지 않고 CPU 코어에 여유가 많은 경우 Non-Blocking을 사용하면 좋을 것 같구요, 작업간에 공유 자원이 많이 존재하고 CPU 코어에 여유가 없는 경우 Blocking을 사용하면 좋을것 같습니다.



### 동기와 비동기에 대해서 설명해주시고 언제 사용하면 좋을지 알려주세요.

**동기는 요청에 대한 결과가 동시에 일어나는 경우를 의미하구요, 비동기는 요청에 대한 결과가 동시에 일어나지 않는 경우를 의미합니다.**<u>(Javascript의 setTimeOut())</u> 동기의 경우 프로세스의 순서가 정말 중요한 은행권과 같은 프로세스에서 사용하면 좋을 것 같구요, 비동기는 작업의 순서가 그다지 중요하지 않지만 작업을 빠르게 처리해야하는 환경에서 사용하면 좋을 것 같습니다. 



### 멀티 스레드 환경에서 비동기가 동기보다 무조건 빠를까요?

**멀티 스레드 환경에서 비동기가 동기보다 빠를 수 있는 확률이 많다는 것은 동의하지만 빠르지 않을 수도 있겠다는 생각이 듭니다.** 만약 비동기 환경에서 작업간에 공유자원이 많을 경우 동기화 문제를 해결 해야만 합니다. 이러한 경우 지연이 발생하며 비동기 작업이 동기 작업에 비해서 빠르지 않을 수도 있겠다는 생각이 듭니다.  



---

## Process Synchronization

---

### 프로세스 동기화는 왜 필요하나요?

**공유 자원을 참조하는 프로세스 간에 질서 있는 실행을 보장하여 <u>데이터의 일관성을 유지하고자 프로세스 동기화가 필요</u>합니다.**



### Critical Section은 무엇인가요?

**동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역을 Critical Section** 이라고 합니다.



### Race Condition이란 무엇인가요?

**여러 프로세스가 동시에 공유 자원을 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 경쟁 상황(race condition)이라고 합니다.**



### Critical Section Problem을 해결하기 위한 조건이 무엇일까요?

1. **특정 프로세스가 Critical Section을 수행하고 있다면 다른 프로세스는 이 Critical Section에 들어오지 못하게 하는 <u>상호 배제(Mutual Exclusion)</u>** 조건입니다.
2. **Critical Section 에는 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로 참여할 수 있다는 조건인 <u>진행(Progress)</u>** 입니다.
3. **특정 프로세스가 Ciritcal Section에 진입 신청 후 받아들여지기까지 기간이 한정되어야 함을 나타내는 <u>한정된 대기(Bounded Waiting)</u>** 입니다.



### Critical Section Problem을 해결하기 위한 기법에는 무엇이 있나요?

- **하드웨어 기반 해결책인 Lock**입니다. Critical Section에 진입하기전에 Lock을 얻고, Critical Section에서 빠져 나올 때 Lock을 방출함으로써 프로세스간에 동기화를 유지하는 방법입니다.

- **소프트웨어 기반 해결책인 Semaphores**입니다. 두 개의 프로세스 사이에서 동기화를 유지할 수 있는 이진 세마포와 세 개 이상의 프로세스 사이에서 동기화를 유지할 수 있는 카운팅 세마포가 있습니다.
- **세 번째 해결책은 모니터 입니다. 모니터는 내부에서 프로그래머가 정의한 상호 배제가 보장되는 일련의 연산자 집합을 포함하는 추상화된 데이터 타입입니다.** 모니터에는 한번에 하나의 프로세스만 들어갈 수 있으며 모니터에 들어가야만 공유 자원에 접근할 수 있습니다.



---

## DeadLock

---

### 교착상태(Deadlock)란 무엇인가요?

**두 개 이상의 프로세스가 서로 상대방의 작업이 끝나기만을 기다려서 결과적으로 아무도 완료되지 못하는 상태를 가리킵니다.**



### 교착상태(Deadlock)가 발생하는 조건은 무엇인가요?

교착상태가 발생하려면 4가지의 조건이 필요합니다.

1. **상호배제(Mutual Exclusion) :** 한번에 한개의 프로세스만이 공유 자원을 사용할 수 있어야 합니다.
2. **점유대기(Hold and wait)** : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다려야 합니다.
3. **비선점(No preemption) :** 프로세스에게 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 합니다.
4. **환형 대기(Circular Wait) :** 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있어야 합니다. 즉, 이러한 요구는 환형이 되어야 합니다.



### 교착상태(Deadlock)을 해결할 수 있는 방법은 무엇인가요?

- **교착 상태의 예방**  (교착 상태 예방 방법들은 자원 사용의 효율성이 떨어지고 비용이 많이 듭니다.)
  - **상호배제 조건의 제거 :** 한번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 합니다.
  - **점유와 대기 조건의 제거 :** 프로세스가 실행되기 전에 필요한 모든 자원을 할당하여 대기를 없애거나, 자원이 점유되지 않은 상태에서만 자원을 요구하도록 합니다.
  - **비선점 조건의 제거 :** 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 줍니다.
  - **환형 대기 조건의 제거** : 환형을 없애기 위해 자원 유형에 따라 순서를 매깁니다.
- **교착 상태의 회피**
  - 자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다. 교착 상태 회피 알고리즘으로는 **자원 할당 그래프 알고리즘**과 **은행원 알고리즘**이 존재한다.
- **교착 상태의 무시**
  - 예방 혹은 회피 기법을 프로그래밍해서 넣으면 성능에 큰 영향을 미칠 수 있기 때문에 데드락의 발생 확률이 비교적 낮은 경우 교착 상태를 무시한다.
- **교착 상태의 발견**
  - 교착 상태를 감시/발견을 하는 detection 알고리즘으로 Deadlock 발생을 체크하는 방식을 의미한다.



---

## Memory Management

---

### Swapping에 대해서 알려주실 수 있나요?

**Swapping이란 CPU 할당 시간이 끝난 프로세스의 메모리를 디스크로 보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.** 프로세스를 디스크에서 메모리로 불러오는 과정을 Swap-in, 보조 기억장치로 내보내는 과정을 Swap-out 이라고 합니다.



### Swapping을 하면서 발생할 수 있는 문제점에 대해서 알고 있으시나요?

네! Swapping을 하면서 발생할 수 있는 대표적인 문제는 **단편화(Fragmentation) 문제** 입니다. **단편화(Fragmentation)란 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면서 메모리 사이 사이에 사용하지 못할 만큼의 작은 자유공간들을 의미합니다.**



### 단편화(Fragmentation)는 어떻게 나눌 수 있을까요?

단편화 종류는 크게 외부 단편화(External Fragmentation)와 내부 단편화(Internal Fragmentation)로 나눌 수 있습니다. **외부 단편화란 메모리에서 프로세스와 프로세스 사이에 남는 공간들을 의미하는 것이구요, 내부 단편화란 프로세스가 사용하는 메모리 공간 내부에서 사용하지 않고 남는 공간들을 의미합니다.**



### 외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?

**외부 단편화를 없애기 위해서 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아 분산된 자유 공간을 확보하는 방법인 메모리 압축(Memory Compression)이 있습니다.** 



### 외부 단편화를 해결할 수 있는 또 다른 방법인 페이징 기법에 대해서 들어보셨나요?

**페이징(Paging) 기법이란 물리 메모리를 Frame이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.**  즉, 하나의 프로세스가 사용하는 공간을 여러개의 페이지로 나뉘어서 논리 메모리에서 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리의 프레임에 맵핑되어 저장하는 방법입니다.

> 페이징 기법을 통해서 외부 단편화는 없앨 수 있지만, 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있습니다.



### 세그멘테이션이란 무엇일까요?

**세그멘테이션(Segmentation)은 프로세스를 물리적 크기의 단위가 아니라 <u>논리적 내용의 단위인 세그먼트로 분할</u>하여 메모리에 저장하는 방법입니다.** 논리적 내용의 단위로 분할된 세그먼트는 내부 단편화는 방지할 수 있지만 세그먼트별로 서로 단위가 다르기 때문에 외부 단편화가 발생하는 문제점이 존재합니다.



---

## Virtual Memory

---

### 가상 메모리란 무엇인가?

**가상 메모리를 통해 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리해서 프로세스 전체가 메모리에 올라오지 않더라도 프로그램의 실행이 가능하도록 하는 기법을 말합니다.**



### 가상 메모리를 도입할 시 어떠한 효과를 얻을 수 있나요?

**가상 메모리를 통해 프로그램의 일부분만 물리 메모리에 올릴 수 있게 되었고 이를 통해 물리 메모리 크기에 제약을 받지 않게 되었습니다.** 결국 더 많은 프로그램을 동시에 실행할 수 있게 되었고, swap에 필요한 입출력이 줄었기 때문에 프로그램들이 빠르게 실행되어지는 효과를 얻을 수 있습니다.



### 가상 주소 공간은 무엇인가요?

**가상 주소 공간이란 한 프로세스가 물리 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간을 의미합니다.** 프로세스가 요구하는 메모리 공간을 물리 메모리가 아닌 가상 메모리에서 제공함으로써 현재 직접적으로 필요치 않는 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 메모리를 절약할 수 있습니다.

> ### Tip
>
> - **가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에서 공유되어질 수 있도록 합니다.** 실제 물리 메모리는 공유되어지지만 각 프로세스는 각자 자신의 주소 공간처럼 인식합니다.
> - **프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있습니다.** 이 또한 각 프로세스들은 공유 메모리를 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있습니다.



### 요구 페이징(Demand Paging)이란 무엇인가요?

요구 페이징(Demand Paging)이란 가상 메모리 시스템에서 많이 사용하는 메모리 관리 기법 중 하나로 **프로그램 실행 시작 시 초기에 필요한 페이지만 메모리에 Load하고 이후 실행 과정에서 페이지들이 실제로 필요할 때만 Load하는 방식을 의미합니다.**



### 페이지 교체 알고리즘이란 무엇인가요?

프로그램 실행시 모든 페이지가 물리 메모리에 올라오지 않기 때문에 실행 과정에서 프로세스의 동작에 필요한 페이지를 요청하는 과정이 필요합니다. **페이지를 요청하는 과정에서 페이지 부재(page fault)가 발생하게 되면, 원하는 페이지를 디스크에서 가져오게 되는데 물리 메모리가 모두 사용중인 상황이라면 페이지 교체가 이루어져야 합니다. 이러한 상황에서 사용하는 알고리즘을 페이지 교체 알고리즘이라고 합니다.**



### 페이지 교체 과정에 대해서 아시나요?

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 물리 메모리에서 빈 페이지 프레임을 찾는다.
   1. 빈 프레임이 없을 경우 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작



### 페이지 교체 알고리즘에 대해서 알고계신 것 모두 말씀해주세요.

1. **FIFO(First-in-First-out) 페이지 교체 :** 먼저 메모리에 들어온 페이지 순서대로 페이지를 교체한다.
2. **최적(Optimal) 페이지 교체 :** 메모리에서 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다.
3. **LRU(Least Recently Used) 페이지 교체 :** 메모리에서 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
4. **LFU(Least Frequently Used) 페이지 교체 :** 메모리에서 가장 참조되지 않은 페이지를 선택하여 교체한다.
5. **MFU(Most Frequently Used) 페이지 교체 :** 메모리에서 가장 많이 참조되는 페이지를 선택하여 교체한다.



---

## Caching

---

### 캐싱(Caching)이란 무엇인가요?

**캐싱이란 특정 데이터를 빠르게 접근할 수 있도록 임시적인 저장 위치에 데이터를 저장해두는 방법을 의미합니다.** 캐싱을 통해서 속도가 빠른 장치와 느린 장치 사이에서 발생하는 병목 현상을 줄일 수 있습니다.



### 캐싱 작업시 가장 신경써야 하는 문제는 무엇인가요?

**캐시의 역할을 극대화 시키기 위해서는 얼마나 데이터가 많이 참조 되는지를 고려해서 많이 참조되는 데이터들을 캐싱해야 합니다. 즉, 적중률(hit ratio)를 극대화 시켜야 합니다.**



### 캐시 적중률(hit ratio)을 어떻게 극대화 시킬 수 있을까요?

적중률(hit ratio)을 극대화 시키기 위해서 **지역성(Locality)의 원리**를 사용할 수 있습니다. **지역성의 원리 즉, Locality Principle이란 메모리 내의 정보는 균일하게 Access 되는 것이 아닌 <u>어느 한 순간에 특정 부분이 집중적으로 참조</u>된다는 원리입니다.**



### Locality는 어떻게 나눌 수 있나요?

Locality는 크게 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉩니다. **시간 지역성이란 최근에 참조된 메모리의 특정 주소는 곧 다시 참조된다는 특성을 의미하구요, 공간 지역성이란 참조된 메모리의 주소와 인접한 주소의 내용이 곧 다시 참조된다는 특성을 의미합니다.**



### Caching Line이란 무엇인가요?

**캐시에 데이터를 저장할 때 특정 자료구조를 사용하여 묶음으로 저장하게 되는데 이를 <u>캐싱 라인(Caching Line)</u>이라고 합니다.** 프로세스는 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소 또한 흩어져 있습니다. 따라서 캐시에 저장하는 데이터에는 데이터의 메모리 주소 등을 기록해 둔 태그를 달아놓을 필요가 있다. 이러한 태그들의 묶음을 캐싱 라인이라고 하고 메모리로부터 데이터를 가져올 때도 캐싱 라인을 기준으로 가져옵니다.

> **캐싱 라인의 종류**
>
> 1. Full Associative
> 2. Set Associative
> 3. Direct Map

