---
layout: post
title:  "[기술 면접 준비 - 3일차] 자바 & 객체 지향 프로그래밍"
date:   2020-12-11
author: Green Frog Developer
categories: Interview
tags: Java OOP
---

# Java

### Java 8을 많이 공부하셨다고 했는데 Java 8의 특징이 뭔가요?

Java 8은 Java에 **함수형 프로그래밍이 처음으로 도입된 버젼**이며 새롭게 도입된 기능으로는 **Stream API, Lamda 표현식, Method Reference, Default Method, Optional Class** 등이 있습니다. 

### Stream API란 무엇인가요?

**Stream API란 자바에서의 일련의 데이터 요소인 배열이나 컬렉션 등의 데이터를 처리하기 위한 API 입니다.** Stream API의 특징은 멀티 스레드를 활용해서 병렬로 연산을 수행할 수 있고, 내부 반복으로 연산을 수행하기 때문에 코드가 매우 간단해진다는 것을 알 수 있습니다.

### Lamda Expression은 무엇인가요?

**Lamda Expression이란 Functional Interface를 구현하는 객체를 만들지 않고도 메서드로 전달할 수 있는 익명 함수를 단순화한 것입니다.** 즉, 특정 메소드의 사용을 위해서 일회용 객체를 만들지 않아도 됨으로 성능면에서 좋다고 생각합니다.

### Functional Interface란 무엇인가요?

**Functional Interface란 정확히 하나의 추상 메서드가 정의된 인터페이스**를 의미합니다. 예로는 Predicate, Comparator, Runnable 인터페이스등이 존재합니다.

### Method Reference는 무엇인가요?

**람다 표현식 직접 작성하는 대신해 기존의 메서드 정의를 이용하는 방법**입니다. 기존의 메서드의 정의와 동일한 람다 표현식을 매번 작성하는 불편함에서 나온 기법이며, 가독성을 높일 수 있다고 생각합니다. 하지만, 저는 아직은 잘 익숙하지 않아서 IDE에 도움을 많이 받고 있습니다.

### Optional 클래스는 무엇인가요?

Optional 클래스란 Java 8에서 새롭게 등장한 클래스이구요 **util 패키지** 속해 있습니다. **Optional 클래스는 자바 프로그래머들이 가장 자주 접하는 예외인 NPE를 관리 하기 위해 기존 객체를 감싼 Wrapper Class 입니다.**

### Default Method 란 무엇인가요?

**메서드 구현을 포함하는 인터페이스를 정의하기 위해 사용되어집니다.** 이 인터페이스를 구현하는 클래스는 인터페이스에 디폴트 메소드도 상속받게 되기 때문에 서브클래스는 최소한의 메소드만 구현해도 됩니다. **즉, 인터페이스는 서브클래스가 구현해야 하는 최소한의 인터페이스를 유지할 수 있습니다.**

### 추상 클래스와 인터페이스의 차이는 무엇인가요?

추상 클래스와 인터페이스의 가장 큰 차이는 사용법에서 존재한다고 생각합니다. **추상 클래스는 멤버와, 메소드 명세, 구현 등 모든 부분이 상속이 되기 때문에 대부분의 경우 코드의 재사용을 위해서 사용되는 경우가 많고, 인터페이스는 메소드 Java 8 이전에는 명세만 상속되었기 때문에 메소드 명세의 상속을 위해서 사용**된다고 생각합니다. 또한 단일 상속을 지원하는 자바의 특성상 클래스를 상속하는 추상화 계층이 많아질 수록 결합도가 증가하기 때문에 도메인에 맞추어서 잘 사용해야 한다고 생각합니다.

### 오버라이딩과 오버로딩의 차이는 무엇인가요?

**오버라이딩이란 서브클래스가 상속받은 메소드를 클래스에 맞게 재구현 하는 것을 의미**하구요 **오버로딩이란 동일한 메서드 이름이지만 매개 변수 타입이나 개수가 다른 즉, 다른 명세를 가진 함수를 같은 클래스 내에 만드는 것을 의미**합니다.

### 업캐스팅과 다운캐스팅의 차이는 무엇인가요?

**일단 Java에서는 슈퍼 클래스의 변수에 서브 클래스의 객체가 들어가는 것을 업캐스팅**이라구 하구요, **업캐스팅 된 변수의 타입을 서브 클래스로 변경하는 것을 다운 캐스팅**이라고 합니다. <u>서브 클래스 객체는 슈퍼 클래스의 메소드 명세를 상속 받기 때문에 슈퍼 클래스의 변수에 들어가 슈퍼 클래스 인 것처럼 사용될 수 있는 것은 당연하구요, 업 캐스팅 된 변수의 타입이 다시 서브 클래스로 돌아와 본인의 클래스 객체인 것처럼 사용할 수 있는 것도 당연합니다.</u>

### 제네릭은 이란 무엇인가?

**제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다.** 이를 통해서 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다. 기존에는 Object객체를 사용 했지만 이제는 \<T>를 사용함으로써 컴파일 시에 타입을 지정할 수 있게 되었고 다운 캐스팅이 필요없게 되었습니다.

### 어디에서 제네릭을 보았나요??

여러 프로젝트를 진행하면서 제네릭을 보았는데, 특히 Pinpoint 프로젝트를 진행하면서 제네릭을 보았던 경험이 기억에 남습니다. Checker 도메인이 검색하는 Metric 타입을 제네릭 와일드 카드로 지정해 놓고 이를 상속해 서브 타입의 Checker에서 제네릭 타입을 설정해 구현한 경험이 생각 납니다.

**이를 통해 얻었던 장점은 특정 Metric을 검색하는 Checker 클래스를 여러개 만들 필요가 없었고, 컴파일 시에 타입 에러를 받을 수 있어서 확실한 장점이 있었지만, 처음 코드를 보는 사람들한테는 조금 어렵게 보여 가독성 측면에서는 좋지 않았던 것 같습니다.**

### 자바 컬렉션에 대해서 설명해 주실 수 있나요?

**자바에서 컬렉션이란 데이터의 집합, 그룹을 의미하며 이를 저장하고 연산할 수 있는 집합을 의미합니다.** **Collection 프레임워크는 크게 두개로 나눌 수 있는데요 순서나 집합적인 저장 공간의 명세를 나타내는 Collection 인터페이스와 키와 값으로 데이터를 핸들링하는 명세를 정의하는 Map 인터페이스로 나눌 수 있습니다.**

Set, List, Queue 인터페이스가 Collection 인터페이스를 상속해서 각 특성에 맞게 명세를 구체화하고 HashMap, TreeMap 등이 Map 인터페이스를 구현해서 컬렉션 프레임 워크를 형성합니다.

### Set, List, Queue의 차이를 설명해 주실 수 있나요?

**List 인터페이스는 객체의 순서가 있고, 원소가 중복될 수 있는 명세**를 가지고 있으며 구현체는 ArrayList(동기화 보장 x)가 있습니다.

**Queue 인터페이스는 객체를 입력한 순서대로 저장하며, 원소가 중복될 수 있는 명세**를 가지고 있으며 구현체로는 LinkedList 등이 있습니다.

**Set 인터페이스는 객체의 순서가 없으며, 동일한 원소를 중복 저장 할 수 없는 명세**를 가지고 있으며 구현체로는 HashSet, TreeSet 등이 있습니다.

### LinkedList와 ArrayList의 차이는 무엇인가요?

**ArrayList는 내부적으로 특정 데이터 타입의 배열에서 데이터를 관리하고, LinkedList는 노드에 데이터를 저장하고 앞 뒤 노드의 주소값을 연결지어 데이터를 관리**합니다.

<u>삽입 및 삭제시 LinkedList는 O(1)의 시간이 걸리고, ArrayList는 O(n)의 시간이 걸립니다. 하지만 인덱스를 통해서 검색시 ArrayList는 O(1)의 시간이 걸리고 링크르 리스트는 O(n)의 시간이 걸립니다.</u>

### HashMap은 무엇인가요?

**HashMap은 Hashing을 사용해서 Map 데이터를 관리 및 연산하는 데이터 구조를 의미합니다.** key 값을 hash 함수를 이용해서 hash code로 바꾸고 이를 저장해서 hashcode를 기반으로 검색하는 자료구조 입니다.

### HashMap과 HashTable의 차이를 아시나요?

**HashTable은 동기화 기능을 제공해 주기 때문에 멀티 스레드 환경에서 스레드 세이프하고, HashMap은 동기화 기능을 제공해 주지 않기 때문에 멀티 스레드 환경에서 스레드 세이프 하지 않습니다.**

### ArrayList와 Vector의 차이는?

**ArrayList와 Vector의 차이는 동기화 제공해주는 자료구조의 차이라고 생각합니다. Vector는 멀티스레드 환경에서 스레드 세이프하고, ArrayList는 스레드세이프 하지 않습니다.**

### TreeMap과 TreeSet의 차이는?

**TreeSet과 TreeMap은 둘다 Red Black Tree를 기반으로 이루어져 있습니다. 가장 큰 차이라고 하면 Set과 Map의 차이** 입니다.

**red black tree는 balanced binary search tree의 한 종류 로써 BST에서 발생하는 불균형 문제를 색깔을 통해서 자체적으로 해결하는 자료구조 입니다.**

### Garbage Collection이란 무엇인가요?

가비지 콜렉션이랑 자동 메모리 관리를 구현한 것입니다. 더 이상 사용하지 않는 객체들이 차지하는 Heap 메모리를 관리한다고 알고 있습니다.

---

# 객체 지향 프로그래밍(OOP)

### 객체 지향 프로그래밍이란 무엇인가요?

**객체 지향 프로그래밍이란 데이터와 프로세스를 동일한 모듈인 객체에 위치하도록 만들어 객체 간의 협력을 통해서 프로그래밍하는 방식이다.** 

### 절차 지향 프로그래밍이란 무엇인가요?

**절차 지향 프로그래밍이란 데이터와 프로세스를 별도의 모듈에 위치시키고 위에서부터 순차적으로 실행하는 프로그래밍 방식이다.**

### 객체 지향의 3대 특징인 캡슐화, 상속, 다형성에 대해서 설명해주세요

**캡슐화란 데이터와 프로세스를 하나의 객체에 위치하도록 만드는 것을 말한다.** 이를 통해 객체는 자율적으로 다른 객체들과 협력할 수 있는 객체가 되며 자연스레 시스템의 결합도는 떨어지고 응집도는 올라가게 된다. 이의 결과로서 시스템 전체는 유지보수하기 쉬워지고 추후 변경에 유연하게 대처할 수 있다.

**상속이란 부모 객체의 특징을 그대로 물려받는 것을 의미하고, 자바에서는 인터페이스 상속과 클래스 상속으로 나뉜다.** 이를 통해 모듈의 재사용성이 높아지고, 다형성을 구현할 수 있다. 하지만 무분별한 상속의 남용은 시스템의 결합도를 올려 추후 변경에 유연하게 대응하지 못하기 때문에 자제해야한다.

**객체지향에서 다형성이란 같은 요청으로부터 응답이 객체의 타입에 따라 다르게 나타나는 것을 의미합니다.** 이를 통해 객체지향은 더 유연한 설계를 가질 수 있습니다.

### Object와 Class의 차이는 무엇인가요?

Class는 시스템의 정적인 구성요소를 나타내는 것이구요, Object는 클래스의 인스턴스로써 시스템의 동적인 구성 요소를 나타냅니다.

### 추상화란 무엇인가요??

**추상화란 특정 개념이나 개체를 보았을 때 특정 관점에서 관심있거나 중요한 부분만 추려내는 작업을 의미합니다.** 즉, OOP에서 중요한 정보만 객체의 인터페이스로써 표시하고 구현 세부 정보를 숨길 수 있는 OOP의 매우 중요한 기능입니다.

### 디자인 패턴이란 무엇인가요??

**소프트웨어를 설계할 때 특정 문맥에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 수 있는 설계 패턴**을 의미합니다.

### Singleton Pattern에 대해서 설명해주세요.

**Singleton 패턴이란 시스템에서 인스턴스가 오직 1개만 생성되어야 하는 경우에 사용되는 패턴입니다. 하지만 동시성 문제를 꼭 고려**해야만 합니다.

자바와 스프링의 싱글톤 차이점은, 싱글톤 객체의 생명주기가 다르다는 것입니다. **자바에서 싱글톤 객체의 범위는 클래스 로더가 기준이지만, 스프링에서는 어플리케이션 컨텍스트가 기준이 됩니다.**

스프링에서 빈을 등록할 때 범위(scope)를 지정할 수 잇는데 디폴트가 Singleton이고, prototype, request, session 등이 존재합니다.

- prototype: 컨테이너에 빈을 요청할 때마다 매번 새로운 객체를 만드는 범위를 의미합니다.
- request: HTTP 요청 하나당 하나의 객체를 만드는 범위를 의미합니다.

### Proxy Pattern에 대해서 설명해주세요.

**프록시 패턴이란 특정 객체를 대신해서 프록시 객체가 해당 역할을 수행해주는 것을 의미합니다.(다형성)** 특정 인터페이스를 상속받는 A 클래스와 Proxy 클래스가 존재하고 Proxy 클래스 내부적으로 A 객체를 사용한다면 인터페이스의 특정 메소드 명세를 사용 했을 때 프록시처럼 동작하게 만들 수 있겠군!

### Association vs Composition vs Aggregation

Associaton의 부분 집합으로 Aggregation과 Composition이 존재한다.

Composition은 A클래스에서 B를 Composition 한다고 했을 때 A가 죽으면 B도 죽는다.

Aggregation은 A클래스에서 B를 Aggregation 한다고 했을 때 A가 죽어도 B는 죽지 않는다.


### Decorator Pattern

데코레이터 패턴은 프록시 패턴과 구현 방법은 비슷하지만 프록시 패턴은 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달하는 반면 **데코레이터 페턴은 클라이언트가 받는 반환값에 장식을 덧입힌다.**

특정 인터페이스를 상속받는 A 클라스와 Decorator 클래스가 존재하고 Decorator 클래스 내부에서 A 클래스 객체를 사용한다면 인터페이스의 특정 메소드 명세를 사용 했을 때 A 클라스 객체의 반환값에 추가적으로 장식을 덧 붙일 수 있다.


